var documenterSearchIndex = {"docs":
[{"location":"developer_note/#Elemental-and-internal-variables","page":"Developer note","title":"Elemental and internal variables","text":"","category":"section"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"There are several types of partial separability. We write a partially-separable function f R^n to R in the form","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"  f(x) = sum_i=1^N f_i (U_i(x)) f_i  R^n_i to R  U_i in R^n_i times n n_i ll n","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"where:","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"f_i\nis the i-th element function whose dimension is smaller than f;\nU_i\nis the linear operator selecting the linear combinations of variables that parametrize f_i.","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"Uᵢ may be based on the elemental variables or the internal variables of f_i:","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"the elemental variables represent the subset of variables that parametrizes f_i, i.e. the rows of U_i are vectors from the Euclidean basis;\nthe internal variables are linear combinations of the variables that parametrize f_i, i.e. U_i may be a dense matrix.","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"The implementation of the linear-operator U_i, which describe entirely the partially-separable structure of f, changes depending on wether we use internal or elemental variables. At the moment, we only developed the elemental partitioned structures, but we left the door open to the development of internal partitioned structures in the future.","category":"page"},{"location":"developer_note/#Abbreviations-in-the-code","page":"Developer note","title":"Abbreviations in the code","text":"","category":"section"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"If you take a look at the code, you will see the following acronyms","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"Acronyms Description\neev elemental element vector\nepv elemental partitioned vector\neem elemental element matrix\neelo elemental partitioned limited-memory operator\nepm elemental partitioned matrix\neplo elemental partitioned limited-memory operator\nees elemental element structure\neps elemental partitioned structure","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PartitionedStructures, M_abstract_part_struct, M_abstract_element_struct, M_elt_vec, ModElemental_ev,ModElemental_pv, M_elt_mat, M_part_mat, M_part_v, ModElemental_pm, ModElemental_em, Utils, Link, PartitionedQuasiNewton, PartitionedLOQuasiNewton, ModElemental_elo_bfgs, ModElemental_plo_bfgs, ModElemental_elo_sr1, ModElemental_plo_sr1, ModElemental_plo, Instances, PartMatInterface]","category":"page"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.AbstractPartitionedStructure","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.AbstractPartitionedStructure","text":"Supertype of every partitioned-structure, ex: Elemental_pv, Elemental_pm, Elemental_plo_bfgs, Internal_pv...\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractPartitionedStructure","page":"Reference","title":"Base.:==","text":"(==)(ps1::T, ps2::T) where T <: AbstractPartitionedStructure\n\nReturn true if both partitioned-structures are composed of the same amont of element-structures, and have the same size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y<:AbstractPartitionedStructure, Z<:AbstractPartitionedStructure}","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.check_epv_epm","text":"bool = check_epv_epm(epm::Y, epv::Z) where {Y <: AbstractPartitionedStructure, Z <: AbstractPartitionedStructure}\n\nSimilar to ==, but it can compare different partitioned-structures, example: an Elemental_pv and an Elemental_pm. check_epv_epm is a superficial test, see full_check_epv_epm(epm, epv) for a complete check of the partitioned-structure (i.e. if each element depends of the same variable subset).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.full_check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y<:AbstractPartitionedStructure, Z<:AbstractPartitionedStructure}","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.full_check_epv_epm","text":"full_check_epv_epm(ep1::Y, ep2::Z) where {Y <: AbstractPartitionedStructure, Z <: AbstractPartitionedStructure}\n\nCheck if each element-structure of both partitioned-structures depend of the same subset of variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_N-Tuple{T} where T<:AbstractPartitionedStructure","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_N","text":"get_N(ps::T) where T <: AbstractPartitionedStructure\n\nReturn the number of element composing the partitioned-structure ps.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_component_list-Tuple{T} where T<:AbstractPartitionedStructure","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_component_list","text":"list = get_component_list(ps::T) where T <: AbstractPartitionedStructure\nith_component = get_component_list(ps::T, i::Int) where T <: AbstractPartitionedStructure\n\nReturn either the list of every element-structure composing the partitioned-structure ps or the i-th element-structure of ps.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Tuple{T} where T<:AbstractPartitionedStructure","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"ee_vector = get_ee_struct(eps::AbstractPartitionedStructure{T}) where T\nee = get_ee_struct(eps::AbstractPartitionedStructure{T}, i::Int) where T\n\nReturn the vector composed of every elemental element ee_vector from the elemental element-vector eev or the i-th elemental element of eps.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_n-Tuple{T} where T<:AbstractPartitionedStructure","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_n","text":"get_n(ps::T) where T <: AbstractPartitionedStructure\n\nReturn the total size of the partitioned-structure ps.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{T} where T<:AbstractPartitionedStructure","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.initialize_component_list!","text":"initialize_component_list!(ps::T) where T <: AbstractPartitionedStructure)\n\nBuild for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.Element_struct","text":"Supertype of every element-structure, ex : Elemental_elt_vec, Elemental_em, Elemental_elo_bfgs, Internal_elt_vec...\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.get_indices-Tuple{T} where T<:Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.get_indices","text":"indices = get_indices(elt::T) where T <: Element_struct\nindice = get_indices(elt::T, i::Int) where T <: Element_struct\n\nEvery element-structure is based on a variable subset of a partitioned-structure. get_indices(elt) retrieves the variable set of an element elt. get_indices(elt, i) retrieves the i-th variable associated to elt.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.get_nie-Tuple{T} where T<:Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.get_nie","text":"nie = get_nie(elt::T) where T <: Element_struct\n\nReturn the elemental size of the element elt.nie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.set_indices!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.set_indices!","text":"set_indices!(elt::T, indices::Vector{Int}) where T <: Element_struct\n\nSet the indices of the element elt.indices to indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.set_nie!-Union{Tuple{T}, Tuple{T, Int64}} where T<:Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.set_nie!","text":"set_nie!(elt::T, nie::Int) where T <: Element_struct\n\nSet the element size of elt to nie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_vec.Elt_vec","page":"Reference","title":"PartitionedStructures.M_elt_vec.Elt_vec","text":"Supertype of element-vectors.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_vec.get_vec-Tuple{T} where T<:Elt_vec","page":"Reference","title":"PartitionedStructures.M_elt_vec.get_vec","text":"vec = get_vec(ev::T) where T <: Elt_vec\nvec_i = get_vec(ev::T, i::Int) where T <: Elt_vec\n\nReturn the vector ev.vec or ev.vec[i] from an element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_vec.set_add_vec!-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T<:Elt_vec, Y<:Number}","page":"Reference","title":"PartitionedStructures.M_elt_vec.set_add_vec!","text":"set_add_vec!(ev::T, vec::Vector{Y}) where {T <: Elt_vec, Y <: Number}\n\nAdd vec to the vector ev.vec of the element-vector ev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_vec.set_minus_vec!-Tuple{T} where T<:Elt_vec","page":"Reference","title":"PartitionedStructures.M_elt_vec.set_minus_vec!","text":"set_minus_vec!(ev::T) where T <: Elt_vec\n\nMultiply by -1 the vector inside the element-vector ev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_vec.set_vec!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y<:Number, T<:Elt_vec{Y}}","page":"Reference","title":"PartitionedStructures.M_elt_vec.set_vec!","text":"set_vec!(ev::T, vec::Vector{Y}) where {Y <: Number, T <: Elt_vec{Y}}\nset_vec!(ev::T, i::Int, val::Y) where {Y <: Number, T <: Elt_vec{Y}}\n\nSet ev.vec to vec or ev.vec[i] = val of the element-vector ev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.Elemental_elt_vec","page":"Reference","title":"PartitionedStructures.ModElemental_ev.Elemental_elt_vec","text":"Elemental_elt_vec{T} <: Elt_vec{T}\n\nRepresent an elemental element-vector. indices retains the indices of the elemental variables. nie is the elemental size (=length(indices)). vec is the current value of the elemental element vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_ev.create_eev-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.create_eev","text":"eev = create_eev(elt_var::Vector{Int}; type=Float64)\n\nCreate a random elemental element-vector eev from the elemental variables elt_var. eev is set to random values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.eev_from_sparse_vec-Union{Tuple{SparseArrays.SparseVector{T, Y}}, Tuple{Y}, Tuple{T}} where {T, Y}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.eev_from_sparse_vec","text":"eem = eev_from_sparse_vec(sparsevec::SparseVector{T,Y})\n\nDefine an elemental element-vector from a sparsevec::SparseVector. The indices and the values are define with findnz(sparse_vec).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.new_eev-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.new_eev","text":"eem = new_eev(nᵢ::Int; T=Float64, n=nᵢ^2)\n\nCreate an elemental element-vector of size nie, with random values and whose the indices are within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.ones_eev-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.ones_eev","text":"eem = ones_eev(nᵢ::Int; T=Float64, n=nᵢ^2)\n\nCreate an elemental element-vector of size nie with values set to 1 and whose the indices are within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.sparse_vec_from_eev-Union{Tuple{Elemental_elt_vec{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_ev.sparse_vec_from_eev","text":"sp_vec = sparse_vec_from_eev(eev::Elemental_elt_vec{T}; n::Int=maximum(get_indices(eev))) where T\n\nCreate a SparseVector from the element element-vector eev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.specific_ones_eev-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.specific_ones_eev","text":"eem = specific_ones_eev(nie::Int, index::Int; T=Float64, mul::Float64=1.)\n\nCreate an elemental element-vector of size nie, of random values multiplied by mul and whose indices are in range index:index+nie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.Elemental_pv","page":"Reference","title":"PartitionedStructures.ModElemental_pv.Elemental_pv","text":"Elemental_pv{T} <: Part_v{T}\n\nRepresent an elemental partitioned-vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_v.build_v!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_v.build_v!","text":"build_v!(epv::Elemental_pv{T}) where T\n\nBuild the vector epv.v by accumulating the contribution of each elemental element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.add_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.add_epv!","text":"add_epv!(epv1::Elemental_pv{T}, epv2::Elemental_pv{T})\n\nBuild in place of epv2 the elementwise addition of epv1 and epv2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.create_epv-Union{Tuple{Array{SparseArrays.SparseVector{T, Y}, 1}}, Tuple{Y}, Tuple{T}} where {T, Y}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.create_epv","text":"epv = create_epv(sp_set::Vector{SparseVector{T,Y}}; kwargs...) where {T,Y}\nepv = create_epv(eev_set::Vector{Elemental_elt_vec{T}}; n=max_indices(eev_set)) where T\n\nCreate an elemental partitioned-vector from a vector eev_set of: SparseVector, elemental element-vector or a vector of indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.epv_from_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.epv_from_epv!","text":"epv_from_epv!(epv1::Elemental_pv{T}, epv2::Elemental_pv{T}) where T\n\nSet the elemental partitioned-vector epv1 to epv2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.epv_from_v!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.epv_from_v!","text":"epv_from_v!(epv_x::Elemental_pv{T}, x::Vector{T}) where T\n\nSet the values of the element partitioned-vector epv to x. Usefull to define Uᵢ x, ∀ i ∈ {1,...,N}.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.epv_from_v-Union{Tuple{T}, Tuple{Vector{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.epv_from_v","text":"epv = epv_from_v(x::Vector{T}, shape_epv::Elemental_pv{T}) where T\n\nDefine a new elemental partitioned-vector from x that have the same structure than shape_epv. The value of each elemental element-vector comes from the corresponding indices of x. Usefull to define Uᵢ x, ∀ x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.get_eev_set-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.get_eev_set","text":"eev_set = get_eev_set(epv::Elemental_pv{T}) where T\n\nReturn either the vector of every elemental element-vector of the elemental partitioned-vector epv or the i-th elemental element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.get_eev_subset-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{Int64}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.get_eev_subset","text":"eev_subset = get_eev_subset(epv::Elemental_pv{T}, indices::Vector{Int}) where T\n\nReturn a subset of the elemental element vector composing the elemental partitioned-vector epv. indices selects the differents elemental element-vector needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.get_eev_value-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.get_eev_value","text":"eev_i_value = get_eev_value(epv::Elemental_pv{T}, i::Int) where T\neev_ij_value = get_eev_value(epv::Elemental_pv{T}, i::Int, j::Int) where T\n\nReturn either the value of the i-th elemental element-vector of the elemental partitioned-vector epv or only the j-th component of the i-th elemental element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.minus_epv!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.minus_epv!","text":"minus_epv!(epv::Elemental_pv{T}) where T <: Number\n\nBuild in place the -epv, by inversing the value of each elemental element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.ones_kchained_epv-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.ones_kchained_epv","text":"epv = ones_kchained_epv(N::Int, k::Int; T=Float64)\n\nConstruct an elemental partitioned-vector of N elemental element-vector of size k which overlaps the next element-vector on k-1 variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.part_vec-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.part_vec","text":"epv = part_vec(;n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1, mul::Float64=1.)\n\nDefine an elemental partitioned-vector formed by N (deduced from n and nie) elemental element-vectors of size nie. Each elemental element-vector overlaps the previous and the next element by overlapping.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.prod_part_vectors-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.prod_part_vectors","text":"(acc, res) = prod_part_vectors(epv1::Elemental_pv{T}, epv2::Elemental_pv{T}) where T\n\nPerform an elementwise scalar product between the two elemental partitioned-vector epv1 and epv2. acc accumulates the sum of the element-vectors scalar product. res contrains the details of every element-vector scalar product.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.rand_epv-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.rand_epv","text":"epv = rand_epv(N::Int,n::Int; nie=3, T=Float64)\n\nDefine an elemental partitioned-vector of N elemental element-vector of size nᵢ whose values are randoms and the indices are in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.scale_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.scale_epv!","text":"v = scale_epv!(epv::Elemental_pv{T}, scalars::Vector{T}) where T\n\nReturn a vector v from epv where the contribution of each element-vector is multiply by the corresponding value from scalars. v is extract from epv.v\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.scale_epv-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.scale_epv","text":"v = scale_epv(epv::Elemental_pv{T}, scalars::Vector{T}) where T <: Number\n\nReturn a vector v from epv where the contribution of each element-vector is multiply by the corresponding value from scalars.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.set_eev!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64, Int64, T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.set_eev!","text":"set_eev!(epv::Elemental_pv{T}, i::Int, vec::Vector{T}) where T\nset_eev!(epv::Elemental_pv{T}, i::Int, j::Int, val:: T) where T\n\nSet either the i-th elemental element-vector epv to vec or its j-th component to val.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.set_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Array{Vector{T}, 1}}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.set_epv!","text":"set_epv!(epv::Elemental_pv{T}, vec_value_eev::Vector{Vector{T}}) where T <: Number\n\nSet the values of the elemental element-vectors of epv with the components of vec_value_eev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.Counter_elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.Counter_elt_mat","text":"Counter_elt_mat\n\nCount for an element-matrix the updates performed on it, from its allocation. total_update + total_reset + total_untouched == attempt, .\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.DenseEltMat","page":"Reference","title":"PartitionedStructures.M_elt_mat.DenseEltMat","text":"Supertype of every dense element-matrix, ex: Elemental_em\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.Elt_mat","text":"Supertype of every element-matrix, ex: Elemental_em, Elemental_elo_sr1, Elemental_elo_bfgs\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.LOEltMat","page":"Reference","title":"PartitionedStructures.M_elt_mat.LOEltMat","text":"Supertype of every element linear-operator, ex: Elemental_elo_sr1, Elemental_elo_bfgs\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_Bie-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_Bie","text":"get_Bie(elt_mat::T) where T <: Elt_mat\n\nReturn the element-matrix elt_mat.Bie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_Bsr-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_Bsr","text":"get_Bsr(elt_mat::T) where T <: Elt_mat\n\nReturn the temporary vector elt_mat._Bsr.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_cem-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_cem","text":"cem = get_cem(elt_mat::T) where T <: Elt_mat\n\nReturn the Counter_elt_mat of the elemental element-matrix elt_mat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_counter_elt_mat-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_counter_elt_mat","text":"cem = get_counter_elt_mat(elt_mat::T) where T <: Elt_mat\n\nReturn the Counter_elt_mat of the elemental element-matrix elt_mat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_current_untouched-Tuple{Counter_elt_mat}","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_current_untouched","text":"index = get_current_untouched(cem::Counter_elt_mat)\n\nReturn index: the number of the last partitioned-updates that did not update the element-matrix elt_mat. If the last partitioned-update updates elt_mat then index will be equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_index-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_index","text":"index = get_index(elt_mat::T) where T <: Elt_mat\n\nReturn index: the number of the last partitioned-updates that did not update the element-matrix elt_mat. If the last partitioned-update updates elt_mat then index will be equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.iter_info-Tuple{Counter_elt_mat}","page":"Reference","title":"PartitionedStructures.M_elt_mat.iter_info","text":"(current_update, current_untouched, current_reset) = iter_info(cem::Counter_elt_mat)\n\nReturn the information about the last partitioned quasi-Newton update applied onto the element counter cem (associated to an element-matrix).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.total_info-Tuple{Counter_elt_mat}","page":"Reference","title":"PartitionedStructures.M_elt_mat.total_info","text":"(total_update, total_untouched, current_reset) = iter_info(cem::Counter_elt_mat)\n\nReturn the informations about all the quasi-Newton updates applied onto the element associated to the counter cem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.update_counter_elt_mat!-Tuple{Counter_elt_mat, Int64}","page":"Reference","title":"PartitionedStructures.M_elt_mat.update_counter_elt_mat!","text":"update_counter_elt_mat!(cem::Counter_elt_mat, qn::Int)\n\nUpdate the cem counter given the index qn from the quasi-Newton update BFGS!, SR1!, SE!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.Part_LO_mat","text":"Supertype of every partitioned limited-memory operator, ex: Elemental_plo_bfgs, Elemental_plo_sr1, Elemental_plo.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_mat.Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.Part_mat","text":"Supertype of every partitioned-matrix, ex: Elemental_pm, Elemental_plo_bfgs, Elemental_plo_sr1, Elemental_plo.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_mat.get_L-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_L","text":"L = get_L(pm::T) where T <: Part_mat\n\nReturn the sparse matrix pm.L, who aims to store a Cholesky factor. By default pm.L is not instantiate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_L-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_L","text":"L_ij = get_L(pm::T, i::Int, j::Int) where T <: Part_mat\n\nReturn the value pm.L[i,j], from the sparse matrix pm.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_ee_struct_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_ee_struct_Bie","text":"get_ee_struct_Bie(pm::T, i::Int) where T <: Part_mat\n\nReturn the i-th elemental element-matrix of the partitioned-matrix pm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelo_set-Tuple{T} where T<:Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelo_set","text":"eelo_set = get_eelo_set(plm::T) where T <: Part_LO_mat\neelo = get_eelo_set(plm::T, i::Int) where T <: Part_LO_mat\n\nReturn either the vector of every elemental element linear-operator plm.eelo_set or the i-th elemental element linear-operator plm.eelo_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelo_set_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T<:Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelo_set_Bie","text":"Bie = get_eelo_set_Bie(plm::T, i::Int) where T <: Part_LO_mat\n\nReturn the linear-operator of the i-th elemental element linear-operator of plm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelo_sub_set-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelo_sub_set","text":"eelo_subset = get_eelo_sub_set(plm::T, indices::Vector{Int}) where T <: Part_LO_mat\n\nReturn a subset of the elemental element linear-operators composing the elemental partitioned limited-memory operator plm. indices selects the differents elemental element linear-operators needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_permutation-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_permutation","text":"perm = get_permutation(pm::T) where T <: Part_mat\n\nGet the current permutation of the partitioned-matrix pm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_spm-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_spm","text":"spm = get_spm(pm::T) where T <: Part_mat\nspm_ij = get_spm(pm::T, i::Int, j::Int) where T <: Part_mat\n\nGet either the sparse matrix associated to the partitioned-matrix pm or pm[i,j].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.hard_reset_L!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.hard_reset_L!","text":"hard_reset_L!(pm::T) where T <: Part_mat\n\nReset the sparse matrix pm.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.hard_reset_spm!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.hard_reset_spm!","text":"hard_reset_spm!(pm::T) where T <: Part_mat\n\nReset the sparse matrix pm.spm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.reset_L!-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.M_part_mat.reset_L!","text":"reset_L!(pm)\n\nSet the elements of sparse matrix pm.L to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.reset_spm!-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.M_part_mat.reset_spm!","text":"reset_spm!(pm::T) where {Y <: Number, T <: Part_mat{Y}}\n\nSet the elements of sparse matrix pm.spm to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_L!-Union{Tuple{P}, Tuple{T}, Tuple{P, Int64, Int64, T}} where {T<:Number, P<:Part_mat{T}}","page":"Reference","title":"PartitionedStructures.M_part_mat.set_L!","text":"set_L!(pm::P, i::Int, j::Int, value::T) where {T <: Number, P <: Part_mat{T}}\n\nSet the value of pm.L[i,j] = value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_L_to_spm!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.set_L_to_spm!","text":"set_L_to_spm!(pm::T) where T <: Part_mat\n\nSet the sparse matrix plm.L to the sparse matrix plm.spm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_eelo_set!-Tuple{T} where T<:Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.set_eelo_set!","text":"set_eelo_set!(eplo::P, i::Int, eelo::Y) where {T, P <: Part_LO_mat{T}, Y <: LOEltMat{T}}\n\nSet the i-th elemental element linear-operator eplo.eelo to eelo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_permutation!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.set_permutation!","text":"set_permutation!(pm::T, perm::Vector{Int}) where T <: Part_mat\n\nSet the permutation of the partitioned-matrix pm to perm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_spm!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.set_spm!","text":"set_spm!(pm::P) where {T <: Number, P <: Part_mat{T}}\n\nBuild the sparse matrix of the partitioned-matrix pm in pm.spm by gathering the contribution of every element-matrix. The sparse matrix is built with respect to the indices of each elemental element linear-operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.Part_v","text":"Supertype of every partitioned-vectors, ex : Elementaleltvec, Internaleltvec.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_v.add_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Int64, Y}} where {Y, T<:Part_v{Y}}","page":"Reference","title":"PartitionedStructures.M_part_v.add_v!","text":"add_v!(pv::T, i::Int, value::Y) where {Y, T <: Part_v{Y}}\nadd_v!(pv::T, indices::Vector{Int}, values::Vector{Y}) where {Y, T <: Part_v{Y}}\n\nAdd value (resp values) to the vector of the partitioned-vector pv.v at the indice i (resp indices).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.build_v!-Tuple{T} where T<:Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.build_v!","text":"build_v!(pv::T) where T <: Part_v\n\nAccumulate in pv.v the contributions of every element-vector of the partitioned-vector pv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.build_v-Tuple{T} where T<:Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.build_v","text":"vec = build_v(pv::T) where T <: Part_v\n\nBuild the vector v = pv.v by accumulating inside pv.v the contributions of every element-vector of the partitioned-vector pv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.get_v-Tuple{T} where T<:Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.get_v","text":"v = get_v(pv::T) where T <: Part_v\n\nReturn the vector pv.v of the partitioned-vector pv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.reset_v!-Union{Tuple{T}, Tuple{Y}} where {Y, T<:Part_v{Y}}","page":"Reference","title":"PartitionedStructures.M_part_v.reset_v!","text":"reset_v!(pv::T) where {Y, T <: Part_v{Y}}\n\nReset the vector embedded in the partitioned-vector pv, i.e. pv.v .= (Y)(0).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.set_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y, T<:Part_v{Y}}","page":"Reference","title":"PartitionedStructures.M_part_v.set_v!","text":"set_v!(pv::T, v::Vector{Y}) where {Y, T <: Part_v{Y}}\nset_v!(pv::T, i::Int, value::Y) where {Y, T <: Part_v{Y}}\n\nSet the components of the vector pv.v (resp. pv.v[i]) from the partitioned-vector pv to the vector v (resp. value).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.Elemental_pm","page":"Reference","title":"PartitionedStructures.ModElemental_pm.Elemental_pm","text":"Elemental_pm{T} <: Part_mat{T}\n\nRepresent an elemental partitioned quasi-Newton linear-operator. Each element is an elemental element-matrix which may apply a BFGS or a SR1 update. N is the number of elements. n is the size of the elemental partitioned limited-memory operator. eelo_set is the set of elemental element linear-operators. spm and L are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of spm. component_list summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i. permutation is the current permutation of the elemental partitioned limited-memory operator ([1:n;] initially).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.permute!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T","page":"Reference","title":"Base.permute!","text":"permute!(epm::Elemental_pm{T}, p::Vector{Int}) where T\n\nApply the permutation p to the elemental partitionned matrix epm. The permutation is applied to every elemental element-matrix eem via indices. The current epm permutation is stored in epm.permutation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"eem_set = get_ee_struct(epm::Elemental_pm{T}) where T\n\nReturn the vector of every elemental element-matrices epm.eem_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"eem = get_ee_struct(epm::Elemental_pm{T}, i::Int) where T\n\nReturn the i-th elemental element-matrix epm.eem_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.correlated_var-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.correlated_var","text":"correlated_var(epm::Elemental_pm{T}, i::Int) where T\n\nGather all the variables appearing in the elements also paramtrized by the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_set","text":"eem_set = get_eem_set(epm::Elemental_pm{T}) where T\n\nReturn the vector of every elemental element-matrices epm.eem_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_set","text":"eem = get_eem_set(epm::Elemental_pm{T}, i::Int) where T\n\nReturn the i-th elemental element-matrix epm.eem_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_set_Bie-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_set_Bie","text":"Bie = get_eem_set_Bie(get_eem_set_Bie(epm::Elemental_pm{T}, i::Int) where T\n\nGet the matrix of the i-th elemental element-matrix of epm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_sub_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_sub_set","text":"eem_subset = get_eem_sub_set(epm::Elemental_pm{T}, indices::Vector{Int}) where T\n\nReturn a subset of elemental element-matrices composing epm. indices selects the different elemental element-matrices needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.identity_epm","text":"epm = identity_epm(N::Int, n::Int; T=Float64, nie::Int=5)\n\nReturn a partitionned matrix of type T of N identity elemental element-matrices. Each elemental element-matrix is of size nie with randoms positions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Vector{Vector{Int64}}}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.identity_epm","text":"epm = identity_epm(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64)\nepm = identity_epm(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64)\n\nReturn a partitionned matrix of type T of N identity elemental element-matrices. N and n may be extrapolate from element_variables. The elemental variables are based from the indices informed in element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.n_i_SPS-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.n_i_SPS","text":"epm = n_i_SPS(n::Int; T=Float64, nie::Int=5, overlapping::Int=1, mul=5.)\n\nDefine an elemental partitioned-matrix epm of size n. The partitioned-matrix is composed by N ≈ (n/nie)*2 elemental element-matrices, of size nie, they overlap onto the next element by overlapping. The diagonal terms of each elemental element-matrix are of value mul, whereas the other terms are set to 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.n_i_sep-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.n_i_sep","text":"epm = n_i_sep(n::Int; T=Float64, nie::Int=5, mul=5.)\n\nDefine an elemental partitioned-matrix epm composed of nie separable blocs. Each elemental element-matrix is composed of 1 except the diagonal terms which are of value mul.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.ones_epm-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.ones_epm","text":"epm = ones_epm(N::Int, n::Int; T=Float64, nie::Int=5)\n\nCreate a partitionned matrix of type T of N elemental element-matrices ones(nie, nie) whose positions are random. The partitionned matrix created may be singular.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.ones_epm_and_id-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.ones_epm_and_id","text":"epm = ones_epm_and_id(N::Int, n::Int; T=Float64, nie::Int=5)\n\nCreate a partitionned matrix of type T with N+n elemental element-matrices. The first N elemental element-matrices are ones(nie, nie) with randoms positions in the range 1:n. The remaining n elemental element-matrices are of size 1, with value [1], they are placed in the diagonal terms This way, the partitionned matrix is generally not singular.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.part_mat-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.part_mat","text":"epm = part_mat(;n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1, mul=5.)\n\nDefine an elemental partitioned-matrix epm composed of N (deduced from n and nie) elemental element-matrices of size nie. Each elemental element-matrix overlaps the previous and the next element by overlapping.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.Elemental_em","page":"Reference","title":"PartitionedStructures.ModElemental_em.Elemental_em","text":"Elemental_em{T} <: DenseEltMat{T}\n\nRepresent an elemental element-matrix. It has fields:\n\nindices: indices of elemental variables;\nnie: elemental size (=length(indices));\nBie::Symmetric{T, Matrix{T}}: the elemental matrix;\ncounter: counts how many update the elemental matrix goes through from its allocation;\nconvex: if Elemental_em is by default update with BFGS or SR1;\n_Bsr: a vector used during quasi-Newton update of the elemental matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.permute!-Union{Tuple{T}, Tuple{Elemental_em{T}, Vector{Int64}}} where T","page":"Reference","title":"Base.permute!","text":"permute!(eem::Elemental_em{T}, p::Vector{Int}) where T\n\nSet the indices of the element variables of eem to p. Must be use with caution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.create_id_eem-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_em.create_id_eem","text":"eem = create_id_eem(elt_var::Vector{Int}; T=Float64)\n\nCreate a nie identity elemental element-matrix of type T based on the vector of the elemental variables elt_var.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.fixed_ones_eem-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.fixed_ones_eem","text":"eem = fixed_ones_eem(i::Int, nie::Int; T=Float64, mul=5.)\n\nCreate a nie elemental element-matrix of type T at indices index:index+nie-1. All the components of the element-matrix are set to 1 except the diagonal terms that are set to mul. This method is used to define diagonal dominant element-matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.identity_eem-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.identity_eem","text":"eem = identity_eem(nie::Int; T=Float64, n=nie^2)\n\nReturn a nie identity elemental element-matrix of type T from nie random indices in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.one_size_bloc-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.one_size_bloc","text":"eem = one_size_bloc(index::Int; T=Float64)\n\nReturn an elemental element-matrix of type T of size one at index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.ones_eem-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.ones_eem","text":"eem = ones_eem(nie::Int; T=Float64, n=nie^2)\n\nReturn a nie ones elemental element-matrix of type T from nie random indices in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.BFGS!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.BFGS!","text":"BFGS!(x0::Vector{Y}, x1::Vector{Y}, g0::Vector{Y}, g1::Vector{Y}, B0::Array{Y,2}; kwargs...) where Y <: Number\nBFGS!(s::Vector{Y}, y::Vector{Y}, B::Symmetric{Y,Matrix{Y}}; kwargs...) where Y <: Number\nBFGS!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; index=0, reset=4, kwargs...)\n\nPerform the BFGS update in place of the matrix B1 by using the vectors s = x1 - x0 and y = g1 - g0 and the current matrix B0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.BFGS-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.BFGS","text":"BFGS(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nBFGS(x0::Vector{Y}, x1::Vector{Y}, g0::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\n\nPerform the BFGS update over the matrix B by using the vectors s = x1 - x0 and y = g1 - g0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SE!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SE!","text":"SE!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSE!(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSE!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}, B1::Array{Y,2}; index=0, reset=4, ω = 1e-6, kwargs...)\n\nPerform a BFGS update in place of B1 by using the matrix B, the vectors s = x1 - x0 and y = g1 - g0 if the curvature condition dot(s,y) > eps(eltype(s)) holds. Otherwise, it performs a SR1 update onto B1 with B, s, y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SE-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SE","text":"SE(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSE(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\n\nPerform a BFGS update over the matrix B by using the vectors s = x1 - x0 and y = g1 - g0 if the curvature condition dot(s,y) > eps(eltype(s)) holds. Otherwise, it performs a SR1 update with B, s, y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SR1!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SR1!","text":"SR1!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSR1!(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSR1!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}, B1::Array{Y,2}; index=0, reset=4, ω = 1e-6, kwargs...)\n\nPerform the SR1 update in place of the matrix B1 by using the vectors s = x1 - x0 and y = g1 - g0 and the current matrix B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SR1-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SR1","text":"SR1(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSR1(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\n\nPerform the SR1 update over the matrix B by using the vectors s = x1 - x0 and y = g1 - g0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.max_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.Utils.max_indices","text":"indice_max = max_indices(list_of_element_variables::Vector{Vector{T}}) where T\nindice_max = max_indices(elt_set::Vector{T}) where T <: Element_struct\n\nReturn the maximum index of the element variables in list_of_element_variables or in elt_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.min_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.Utils.min_indices","text":"indice_min = min_indices(list_of_element_variables::Vector{Vector{T}}) where T\nindice_min = min_indices(elt_set::Vector{T}) where T <: Element_struct\n\nReturn the minimum index of the element variables in list_of_element_variables or in elt_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.my_and","page":"Reference","title":"PartitionedStructures.Utils.my_and","text":"my_and(a::Bool, b::Bool)\n\nReturn a && b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PartitionedStructures.Link.eplo_lbfgs_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Elemental_pv{Y}}","page":"Reference","title":"PartitionedStructures.Link.eplo_lbfgs_from_epv","text":"eplo = eplo_lbfgs_from_epv(epv::T) where {Y <: Number, T <: Elemental_pv{Y}}\n\nCreate an elemental limited-memory partitioned quasi-Newton operator PLBFGS eplo with the same partitioned structure than epv. Each element linear-operator of eplo is set to a LBFGSOperator of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.eplo_lose_from_epv-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.Link.eplo_lose_from_epv","text":"eplo = eplo_lose_from_epv(epv::Elemental_pv{T}) where {T <: Number}\n\nCreate an elemental limited-memory partitioned quasi-Newton operator PLSE eplo with the same partitioned structure than epv. Each element linear-operator of eplo is set to a LBFGSOperator of suitable size, but it may change to a LSR1Operator later on.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.eplo_lsr1_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Elemental_pv{Y}}","page":"Reference","title":"PartitionedStructures.Link.eplo_lsr1_from_epv","text":"eplo = eplo_lsr1_from_epv(epv::T) where {Y <: Number, T <: Elemental_pv{Y}}\n\nCreate an elemental limited-memory partitioned quasi-Newton operator PLSR1 eplo with the same partitioned structure than epv. Each element linear-operator of eplo is set to a LSR1Operator of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.epm_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Elemental_pv{Y}}","page":"Reference","title":"PartitionedStructures.Link.epm_from_epv","text":"epm = epm_from_epv(epv::T) where {Y <: Number, T <: Elemental_pv{Y}}\n\nCreate an elemental partitioned quasi-Newton operator epm with the same partitioned structure than epv. Each element-matrix of epm is set with an identity matrix of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.epv_from_eplo-Tuple{Any}","page":"Reference","title":"PartitionedStructures.Link.epv_from_eplo","text":"epv = epv_from_eplo(eplo::T) where T <: Part_mat{Y}\n\nCreate an elemental partitioned-vector epv with the same partitioned structure than eplo. Each element-vector of epv is set to a random vector of suitable size. Make a name difference with the method epv_from_epm().\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.epv_from_epm-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.epv_from_epm","text":"epv = epv_from_epm(epm::T) where T <: Part_mat{Y}\n\nCreate an elemental partitioned-vector epv with the same partitioned structure than epm. Each element-vector of epv is set to a random vector of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_epv!-Union{Tuple{T}, Tuple{Y}, Tuple{Elemental_pv{Y}, T, Elemental_pv{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_epv!","text":"mul_epm_epv!(epv_res::Elemental_pv{Y}, epm::T, epv::Elemental_pv{Y}) where {Y <: Number, T <: Part_mat{Y}}\n\nCompute the elementwise product between the elemental partitioned-matrix epm and the elemental partitioned-vector epv. The result of each element-matrix element-vector product is stored in the elemental partitioned-vector epv_res.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_epv-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_epv","text":"epv_res = mul_epm_epv(epm::T, epv::Elemental_pv{Y}) where {Y <: Number, T <: Part_mat{Y}}\n\nCompute the elementwise product between the elemental partitioned-matrix epm and the elemental partitioned-vector epv. The result is an elemental partitioned-vector epv_res storing the elementwise products between epm and epv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_vector!-Union{Tuple{T}, Tuple{Y}, Tuple{Vector{Y}, T, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_vector!","text":"mul_epm_vector!(res::Vector{Y}, epm::T, x::Vector{Y}) where {Y <: Number, T <: Part_mat{Y}}\nmul_epm_vector!(res::Vector{Y}, epm::T, epv::Elemental_pv{Y}, x::Vector{Y}) where {Y <: Number, T <: Part_mat{Y}}\n\nCompute the product between the elemental partitioned-matrix epm and the vector x. The method uses temporary the elemental partitioned-vector epv. The result is stored in res, a vector similar to x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_vector-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_vector","text":"result = mul_epm_vector(epm::T, x::Vector{Y}) where {Y <: Number, T <: Part_mat{Y}}\nresult = mul_epm_vector(epm::T, epv::Elemental_pv{Y}, x::Vector{Y}) where {Y <: Number, T <: Part_mat{Y}}\n\nCompute the product between the elemental partitioned-matrix epm <: Part_mat and the vector x. The method uses temporary the elemental partitioned-vector epv. The method returns result, a vector similar to x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.string_counters_iter-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.Link.string_counters_iter","text":"s = string_counters_iter(pm::T; name = :PQN) where {T <: Part_mat}\n\nProduce s::String that summarizes the partitioned update applied onto pm at the last iterate. The method accumulates the informations gathered by each element-counter during the last iterate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.string_counters_total-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.Link.string_counters_total","text":"s = string_counters_total(pm::T; name = :PQN) where {T <: Part_mat}\n\nProduce s::String that summarizes the partitioned update applied onto pm since its allocations. The method accumulates the informations gathered by each element-counter since their allocations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!","text":"PBFGS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPBFGS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T\n\nPerform the PBFGS update onto the elemental partitioned-matrix epm_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PBFGS_update","text":"copy_epm_B = PBFGS_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PBFGS update onto a copy of the elemental partitioned-matrix epm_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of epm_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PCS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PCS_update!","text":"PCS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPCS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T\n\nPerform the PCS update onto the elemental partitioned-matrix epm_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PCS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PCS_update","text":"B = PCS_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PCS update onto a copy of the elemental partitioned-matrix epm_B, given the step s and the difference of elemental partitioned-gradients epv_y. Each elemental element-matrix eem is update given its convex field, if convex==true the elemental element-matrix eem is update with BFGS otherwise it is SR1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSE_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSE_update!","text":"PSE_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPSE_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T\n\nPerform the PSE update onto the elemental partitioned-matrix epm_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSE_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSE_update","text":"copy_epm_B = PSE_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PSE update onto a copy of the elemental partitioned-matrix epm_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of epm_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSR1_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSR1_update!","text":"PSR1_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPSR1_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T\n\nPerforms the PSR1 update onto the elemental partitioned-matrix epm_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSR1_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSR1_update","text":"copy_epm_B = PSR1_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PSR1 update onto a copy of the elemental partitioned-matrix epm_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of epm_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!","text":"PLBFGS_update!(eplo_B::Elemental_plo_bfgs{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPLBFGS_update!(eplo_B::Elemental_plo_bfgs{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, reset=true, kwargs...) where T\n\nPerform the PLBFGS update onto the partitioned limited-memory operator eplo_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update","text":"copy_eplo_B = PLBFGS_update(eplo_B::Elemental_plo_bfgs{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PLBFGS update onto a copy of the partitioned limited-memory operator eplo_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of eplo_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!","text":"PLSE_update!(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where {T, Y <: Part_LO_mat{T}}\nPLSE_update!(eplo_B::Y, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; ω = 1e-6, verbose=true, reset=4, kwargs...) where {T, Y <: Part_LO_mat{T}}\n\nPerform the partitionned update PLSE onto the partitioned limited-memory operator eplo_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y. Each element linear-operator from eplo_B is either a LBFGSOperator or LSR1Operator. The update tries to apply a LBFGS update to every Bᵢ, but if the curvature condition yᵢᵀUᵢs > 0 is not satisfied it replaces the LBFGSOperator by a LSR1Operator and applies a LSR1 update. If Bᵢ is initally a LSR1Opeartor, we replace it by a LBFGSOperator if the curvature condition yᵢᵀUᵢs > 0 holds and we update it, otherwise the LSR1Operator Bᵢ is update.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update","text":"copy_eplo_B = PLSE_update(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where {T, Y <: Part_LO_mat{T}}\n\nPerform the partitionned update PLSE onto a copy of the partitioned limited-memory operator eplo_B, given the step s and the difference of elemental partitioned-gradients epv_y. Each element linear-operator from eplo_B is either a LBFGSOperator or LSR1Operator. The update tries to apply a LBFGS update to every Bᵢ, but if the curvature condition yᵢᵀUᵢs > 0 is not satisfied it replaces the LBFGSOperator by a LSR1Operator and applies a LSR1 update. If Bᵢ is initally a LSR1Opeartor, we replace it by a LBFGSOperator if the curvature condition yᵢᵀUᵢs > 0 holds and we update it, otherwise the LSR1Operator Bᵢ is update. Return the updated copy of eplo_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!","text":"PLSR1_update!(eplo_B::Elemental_plo_sr1{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPLSR1_update!(eplo_B::Elemental_plo_sr1{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PLSR1 update onto the partitioned limited-memory operator eplo_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update","text":"copy_eplo_B = PLSR1_update(eplo_B::Elemental_plo_sr1{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PSR1 update onto a copy of the partitioned limited-memory operator eplo_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of eplo_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.Part_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.Part_update!","text":"Part_update!(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}) where {T, Y <: Part_LO_mat{T}}\nPart_update!(eplo_B::Y, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; kwargs...) where {T, Y <: Part_LO_mat{T}}\n\nPerform a partitioned quasi-Newton update onto the partitioned limited-memory operator eplo_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y. Each elemental element linear-operator from eplo_B is either a LBFGSOperator or LSR1Operator. The update performs on each element the quasi-Newton update associated to the linear-operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.Part_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.Part_update","text":"copy_eplo_B = Part_update(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}) where {T, Y <: Part_LO_mat{T}}\n\nPerform a quasi-Newton partitionned update onto a copy of the partitioned limited-memory operator eplo_B, given the step s and the difference of elemental partitioned-gradients epv_y. Each elemental element linear-operator from eplo_B is either a LBFGSOperator or LSR1Operator. The update performs on each element the quasi-Newton update associated to the linear-operator. Return the updated copy of eplo_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.Elemental_elo_bfgs","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.Elemental_elo_bfgs","text":"Elemental_elo_bfgs{T} <: LOEltMat{T}\n\nRepresent an elemental element LBFGSOperator. indices retains the indices of the elemental variables. nie is the elemental size (=length(indices)). Bie a LBFGSOperator. counter counts how many update the elemental limited-memory operator goes through from its allocation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo","text":"eelo = LBFGS_eelo(nie::Int; T=Float64, index=1)\n\nReturn an Elemental_elo_bfgs of type T of size nie, the indices are all the values in the range index:index+nie-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo_rand-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo_rand","text":"eelo = LBFGS_eelo_rand(nie::Int; T=Float64, n=nie^2)\n\nReturn an Elemental_elo_bfgs of type T with nie random indices within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.init_eelo_LBFGS-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.init_eelo_LBFGS","text":"eelo = init_eelo_LBFGS(elt_var::Vector{Int}; T=Float64)\n\nReturn an Elemental_elo_bfgs of type T based on the vector of the elemental variableselt_var.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.reset_eelo_bfgs!-Union{Tuple{Elemental_elo_bfgs{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.reset_eelo_bfgs!","text":"reset_eelo_bfgs!(eelo::Elemental_elo_bfgs{T}) where T <: Number\n\nReset the LBFGS linear-operator of the elemental element linear-operator eelo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_bfgs.Elemental_plo_bfgs","page":"Reference","title":"PartitionedStructures.ModElemental_plo_bfgs.Elemental_plo_bfgs","text":"Elemental_plo_bfgs{T} <: Part_LO_mat{T}\n\nRepresent an elemental partitioned quasi-Newton limited-memory operator PLBFGS. Each element is an elemental element LBFGSOperator. N is the number of elements. n is the size of the elemental partitioned limited-memory operator. eelo_set is the set of elemental element linear-operators. spm and L are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of spm. component_list summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i. permutation is the current permutation of the elemental partitioned limited-memory operator ([1:n;] initially).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo","text":"eplo = PLBFGS_eplo(; n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1)\n\nReturn an elemental partitioned limited-memory operator PLBFGS of N (deduced from n and nie) elemental element linear-operators. Each element overlaps the coordinates of the next element by overlapping components.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo_rand-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo_rand","text":"eplo = PLBFGS_eplo_rand(N::Int, n::Int; T=Float64, nie::Int=5)\n\nReturn an elemental partitioned limited-memory operator PLBFGS of N elemental element linear-operators. The size of each element is nie, whose positions are random in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_bfgs.identity_eplo_LBFGS-Tuple{Vector{Vector{Int64}}}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_bfgs.identity_eplo_LBFGS","text":"eplo = identity_eplo_LBFGS(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64)\neplo = identity_eplo_LBFGS(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64)\n\nReturn an elemental partitioned limited-memory operator PLBFGS of N elemental element linear-operators. The positions are given by the vector of the element variables element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.Elemental_elo_sr1","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.Elemental_elo_sr1","text":"Elemental_elo_sr1{T} <: LOEltMat{T}\n\nRepresent an elemental element LSR1Operator. indices retains the indices of the elemental variables. nie is the elemental size (=length(indices)). Bie a LSR1Operator. counter counts how many update the elemental limited-memory operator goes through from its allocation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo","text":"eelo = LSR1_eelo(nie::Int; T=Float64, index=1)\n\nReturn an Elemental_elo_sr1 of type T of size nie, the indices are all the values in the range index:index+nie-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo_rand-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo_rand","text":"eelo = LSR1_eelo_rand(nie::Int; T=Float64, n=nie^2)\n\nReturn an Elemental_elo_sr1 of type T with nie random indices within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.init_eelo_LSR1-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.init_eelo_LSR1","text":"eelo = init_eelo_LSR1(elt_var::Vector{Int}; T=Float64)\n\nReturn an Elemental_elo_sr1 of type T based on the vector of the elemental variables elt_var.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.reset_eelo_sr1!-Union{Tuple{Elemental_elo_sr1{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.reset_eelo_sr1!","text":"reset_eelo_sr1!(eelo::Elemental_elo_sr1{T}) where T <: Number\n\nReset the LSR1 linear-operator of the elemental element linear-operator matrix eelo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_sr1.Elemental_plo_sr1","page":"Reference","title":"PartitionedStructures.ModElemental_plo_sr1.Elemental_plo_sr1","text":"Elemental_plo_sr1{T} <: Part_LO_mat{T}\n\nRepresent an elemental partitioned quasi-Newton limited-memory operator PLSR1. Each element is an elemental element LSR1Operator. N is the number of elements. n is the size of the elemental partitioned limited-memory operator. eelo_set is the set of elemental element linear-operators. spm and L are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of spm. component_list summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i. permutation is the current permutation of the elemental partitioned limited-memory operator ([1:n;] initially).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo","text":"eplo = PLSR1_eplo(; n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1)\n\nReturn an elemental partitionned limited-memory operator PLSR1 of N (deduced from n and nie) elemental element linear-operators. Each element overlaps the coordinates of the next element by overlapping components.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo_rand-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo_rand","text":"eplo = PLSR1_eplo_rand(N::Int, n::Int; T=Float64, nie::Int=5)\n\nReturn an elemental partitionned limited-memory operator PLSR1 of N elemental element linear-operators. The size of each element is nie, whose positions are random in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_sr1.identity_eplo_LSR1-Tuple{Vector{Vector{Int64}}}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_sr1.identity_eplo_LSR1","text":"eplo = identity_eplo_LSR1(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64)\neplo = identity_eplo_LSR1(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64)\n\nReturn an elemental partitionned limited-memory operator PLSR1 of N elemental element linear-operators. The positions are given by the vector of the element variables element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo.Elemental_plo","page":"Reference","title":"PartitionedStructures.ModElemental_plo.Elemental_plo","text":"Elemental_plo{T} <: Part_LO_mat{T}\n\nRepresent an elemental partitioned quasi-Newton limited-memory operator PLSE. Each element may either be a LBFGSOperator or a LSR1Operator. N is the number of elements. n is the size of the elemental partitioned limited-memory operator. eelo_set is the set of elemental element linear-operators. spm and L are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of spm. component_list summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i. permutation is the current permutation of the elemental partitioned limited-memory operator ([1:n;] initially).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo","text":"eplo = PLBFGSR1_eplo(;n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1, prob=0.5)\n\nCreate an elemental partitionned limited-memory operator PLSE of N (deduced from n and nie) elemental element linear-operators. Each element overlaps the coordinates of the next element by overlapping components. Each element is randomly (rand() > p) choose between an elemental element LBFGS operator or an elemental element LSR1 operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo_rand-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo_rand","text":"eplo = PLBFGSR1_eplo_rand(N::Int, n ::Int; T=Float64, nie::Int=5, prob=0.5)\n\nCreate an elemental partitionned limited-memory operator PLSE of N elemental element linear-operators. The size of each element is nie, whose positions are random in the range 1:n. Each element is randomly (rand() > p) choose between an elemental element LBFGS operator or an elemental element LSR1 operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo.identity_eplo_LOSE-Tuple{Vector{Vector{Int64}}}","page":"Reference","title":"PartitionedStructures.ModElemental_plo.identity_eplo_LOSE","text":"eplo = identity_eplo_LOSE(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64)\neplo = identity_eplo_LOSE(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64)\n\nCreate an elemental partitionned limited-memory operator of N elemental element linear-operators initialized with LBFGS operators. The positions are given by the vector of the element variables element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_eplo-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_eplo","text":"(eplo,epv) = create_epv_eplo_sr1(;n=9,nie=5,overlapping=1, mul_v=100.)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator eplo and elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is instantiated as a LBFGSOperator, but it may change to a LSR1Operator later on. The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_eplo_bfgs-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_eplo_bfgs","text":"(eplo,epv) = create_epv_eplo_bfgs(;n=9,nie=5,overlapping=1, mul_v=100.)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator PLBFGS eplo and an elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is a LBFGSOperator. The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_eplo_sr1-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_eplo_sr1","text":"(eplo,epv) = create_epv_eplo_sr1(;n=9,nie=5,overlapping=1, mul_v=100.)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator PLSR1 eplo and an elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is a LSR1Operator. The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_epm-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_epm","text":"(epm,epv) = create_epv_epm(;n=9,nie=5,overlapping=1,mul_m=5., mul_v=100.)\n\nCreate an elemental partitioned-matrix epm and an elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is fill with ones, except the terms of the diagonal of value mul_v::Real. The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_epm_rand-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_epm_rand","text":"(epm,epv) = create_epv_epm_rand(;n=9,nie=5,overlapping=1,range_mul_m=nie:2*nie, mul_v=100.)\n\nCreate an elemeental partitioned quasi-Newton operator epm and an elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is fill with ones, except the terms of the diagonal of value rand(1:range_mul_v). The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"update!(epm::T, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; name=:pse, kwargs...) where {Y <: Number, T <: Part_mat{Y}}\nupdate!(epm::T, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where {Y <: Number, T <: Part_mat{Y}}\n\nUpdate the elemental partitioned-matrix epm with a partitioned quasi-Newton update considering the difference of elemental partitioned-gradients epv_y and the step s (or elemental steps epv_s). The PSE update is run by default, you can apply a PBFGS or a PSR1 update with the optionnal argument name, respectively name=:pbfgs or name=:psr1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_bfgs{Y}, Elemental_pv{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"update!(eplo::Elemental_plo_bfgs{Y}, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where Y <: Number\nupdate!(eplo::Elemental_plo_bfgs{Y}, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; kwargs...) where Y <: Number\n\nUpdates the elemental partitioned limited-memory operator eplo with the partitioned quasi-Newton update PLBFGS considering the difference of elemental partitioned-gradients epv_y and the step s (or elemental steps epv_s).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_sr1{Y}, Elemental_pv{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"update!(eplo::Elemental_plo_sr1{Y}, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where Y <: Number\nupdate!(eplo::Elemental_plo_sr1{Y}, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; kwargs...) where Y <: Number\n\nUpdates the elemental partitioned limited-memory operator eplo with the partitioned quasi-Newton update PLSR1 considering the difference of elemental partitioned-gradients epv_y and the step s (or elemental steps epv_s).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo{Y}, Elemental_pv{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"update!(eplo::Elemental_plo{Y}, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where Y <: Number\nupdate!(eplo::Elemental_plo{Y}, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; kwargs...) where Y <: Number\n\nUpdates the elemental partitioned limited-memory operator eplo with the partitioned quasi-Newton update PLSE considering the difference of elemental partitioned-gradients epv_y and the step s (or elemental steps epv_s).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.PartMatInterface.update","text":"B = update(epm::T, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where {Y <: Number, T <: Part_mat{Y}}\n\nUpdate the elemental partitioned operator epm <: Part_mat with a partitioned quasi-Newton update considering the difference of elemental partitioned-gradients epv_y and the step s. If epm is an elemental partitioned-matrix, the PSE update is run by default. You can apply a PBFGS or a PSR1 update with the optionnal argument name, respectively name=:pbfgs or name=:psr1. It returns a matrix accumulating every element-contribtion of the updated epm. Warning: this method should be use to test your algorithm, if you don't intend to form the matrix use update!(epm, epv_y, s).\n\n\n\n\n\n","category":"method"},{"location":"#PartitionedStructures.jl:-Partitioned-derivatives-storage-and-partitioned-quasi-Newton-updates","page":"Home","title":"PartitionedStructures.jl: Partitioned derivatives storage and partitioned quasi-Newton updates","text":"","category":"section"},{"location":"#Compatibility","page":"Home","title":"Compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia ≥ 1.6.","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add PartitionedStructures\npkg> test PartitionedStructures","category":"page"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Methods exploiting the derivatives of partially-separable functions require specific data structures to store partitioned derivatives. There are several types of partial separability. We write a partially-separable function f R^n to R in the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"  f(x) = sum_i=1^N f_i (U_i(x)) f_i  R^n_i to R  U_i in R^n_i times n n_i ll n","category":"page"},{"location":"","page":"Home","title":"Home","text":"where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f_i\nis the i-th element function whose dimension is smaller than f;\nU_i\nthe linear operator selecting the linear combinations of variables that parametrize f_i.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the case of partitioned quasi-Newton methods, they require storing partitioned gradients and the partitioned Hessian approximation. PartitionedStructures.jl facilitates the definition of those partitioned structures and defines methods to manipulate them.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"U_i","category":"page"},{"location":"","page":"Home","title":"Home","text":"may be based on the elemental variables or the internal variables of f_i:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the elemental variables represent the subset of variables that parametrizes f_i, i.e. the rows of U_i are vectors from the Euclidean basis;","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ui = [1,3,5] # i.e. [1 0 0 0 0; 0 0 1 0 0; 0 0 0 0 1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"the internal variables are linear combinations of the variables that parametrize f_i, i.e. U_i may be a dense matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation of the linear-operator U_i, which describe entirely the partially-separable structure of f, changes depending on wether we use internal or elemental variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the moment, we only developed the elemental partitioned structures, but we left the door open to the development of internal partitioned structures in the future.","category":"page"},{"location":"#How-to-use","page":"Home","title":"How to use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check the tutorial.","category":"page"},{"location":"#Partitioned-structures-available","page":"Home","title":"Partitioned structures available","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Structure Description\nAbstractPartitionedStructure The supertype of every partitioned structures\nElemental_pm An elemental partitioned matrix, each element-matrix is dense\nElemental_plo_bfgs A limited-memory elemental partitioned matrix, each element limited-memory operator is a LBFGSOperator\nElemental_plo_sr1 A limited-memory elemental partitioned matrix, each element limited-memory operator is a LSR1Operator\nElemental_plo A limited-memory elemental partitioned matrix, each element limited-memory operator is a LBFGSOperator or a LSR1Operator\nElemental_pv An elemental partitioned vector","category":"page"},{"location":"#Methods-available","page":"Home","title":"Methods available","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Method Description\nidentity_epm Create a partitioned matrix with identity element-matrices\nidentity_eplo_LBFGS Create a PLBFGS limited-memory partitioned matrix\nidentity_eplo_LSR1 Create a PLSR1 limited-memory partitioned matrix\nidentity_eplo_LOSE Create a PLSE limited-memory partitioned matrix\nupdate Performs a partitioned quasi-Newton update on a partitioned matrix\neplo_lbfgs_from_epv Create an Elemental_plo_bfgs from the partitioned structure of an Elemental_pv\neplo_lsr1_from_epv Create an Elemental_plo_sr1 from the partitioned structure of an Elemental_pv\neplo_lose_from_epv Create an Elemental_plo from the partitioned structure of an Elemental_pv\nepm_from_epv Create an Elemental_pm from the partitioned structure of an Elemental_pv\nepv_from_epm Create an Elemental_pv from the partitioned structure of an Elemental_pm\nepv_from_eplo Create an Elemental_pv from the partitioned structure of an Elemental_plo, an Elemental_plo_bfgs or an Elemental_plo_sr1\nmul_epm_epv Return a partitioned vector from an elementwise product between a partitioned matrix and a partitioned vector\nmul_epm_vector Return the vector resulting from a partitioned matrix-vector product\nbuild_v! Build a vector accumulating the element contributions of a partitioned vector\nset_epv! Set the value of every element-vector\nminus_epv! Apply a unary minus on every element-vector of a partitioned vector\nadd_epv! Perform elementwise addition between two partitioned vectors","category":"page"},{"location":"#Modules-using-[PartitionedStructures.jl](https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl)","page":"Home","title":"Modules using PartitionedStructures.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The structures defined here are used in the module PartiallySeparableSolvers.jl inside a trust-region method using partitioned quasi-Newton operators, and in PartitionedKnetNLPModels.jl to train a classification neural network with a limited-memory partitioned quasi-Newton stochastic method.","category":"page"},{"location":"tutorial/#PartitionedStructures.jl:-Tutorial","page":"Tutorial","title":"PartitionedStructures.jl: Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial shows how PartitionedStructures.jl can define partitioned quasi-Newton approximations, by using partitioned vectors and partitioned matrices. Those partitioned structures are strongly related to partially-separable functions.","category":"page"},{"location":"tutorial/#What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations","page":"Tutorial","title":"What are the partially-separable structure and the partitioned quasi-Newton approximations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The partitioned quasi-Newton methods exploit the partially-separable structure of fR^n to R","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":" f(x) = sum_i=1^N f_i (U_i x)   f_i  R^n_i to R  U_i in R^n_i times n n_i ll n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"as the sum of element function f_i. The gradient nabla f and the Hessian nabla^2 f","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nabla f(x) = sum_i=1^N U_i^top f_i (U_i x) quad nabla^2 f(x) = sum_i=1^N U_i^top f_i (U_i x) U_i","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"accumulate the element derivatives nabla f_i and nabla^2 f_i.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The partitioned structure of the Hessian let us the definition of partitioned quasi-Newton approximations B approx nabla^2 f, such that B accumulates every element Hessian approximation B_i approx nabla^2 f_i","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B = sum_i=1^N U_i^top B_i U_i","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The partitioned quasi-Newton approximations respect sparsity structure of nabla^2 f, which is not the case of classical quasi-Newton approximation (e.g. BFGS, SR1). Moreover, the rank of the partitioned updates may be proportional to the number of elements N, whereas classical quasi-Newton approximations are low-rank updates. A partitioned quasi-Newton update may update every element-Hessian B_i at each step s. It requires B_i, U_i s and nabla f_i (U_i (x+s)) - nabla f_i (U_i x), and therefore we have to store such an approximation and vectors for every element.","category":"page"},{"location":"tutorial/#Reference","page":"Tutorial","title":"Reference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A. Griewank and Ph. L. Toint. Partitioned variable metric updates for large structured optimization problems. Numer. Math., 39:119–137, 1982, 10.1007/BF01399316","category":"page"},{"location":"tutorial/#Example:-the-partitioned-structure-of-a-quadratic","page":"Tutorial","title":"Example: the partitioned structure of a quadratic","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's take the quadratic f as an example","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x) = x[1]^2 + x[1]*x[2] + x[2]^2 + x[3]^2 + 3x[2]*x[3]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f can be considered as the sum of two element functions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f1(y) = y[1]^2 + y[1]*y[2]\nf2(y) = y[1]^2 + y[2]^2 + 3y[1]*y[2]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Define U_1 and U_2 indicating which variables are required by each element function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U1 = [1 0 0; 0 1 0]\nU2 = [0 1 0; 0 0 1]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"However, dense matrices produce a memory issue for large problems. Instead, we use a linear operator only informing the indices of the variables","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U1 = [1, 2]\nU2 = [2, 3]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By gathering the different U_i together","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U = [U1, U2]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we define the function exploiting the partially-separable structure f_pss as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f_pss(x, U) = f1(x[U[1]]) + f2(x[U[2]])\nx0 = [2., 3., 4.]\n\nf(x0) == f_pss(x0, U)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, we can compute: the gradient, the element gradients and explicit how the gradient is partitioned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"∇f(x) = [2x[1] + x[2], x[1] + 2x[2] + 3x[3], 2x[3] + 3x[2]]\n∇f1(y) = [2y[1] + y[2], y[1]]\n∇f2(y) = [2y[1] + 3y[2], 2y[2] + 3y[1]]\nfunction ∇f_pss(x, U)\n  gradient = zeros(length(x))\n  gradient[U1] .+= ∇f1(x[U[1]])\n  gradient[U2] .+= ∇f2(x[U[2]])\n  return gradient\nend\n∇f(x0) == ∇f_pss(x0, U)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"However, ∇f_pss accumulates directly the element gradients and does not store the value of each element gradients ∇f1, ∇f2. We would like to store every element gradient, so we can later update partitioned quasi-Newton approximations. Thus, we define a partitioned vector from U to store each element gradient and form nabla f when required:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PartitionedStructures\nU = [U1, U2]\nn = length(x0)\n# create the partitioned vector\npartitioned_gradient_x0 = create_epv(U)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We set the value of each element vector to the corresponding element gradient","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# return every element gradient\nvector_gradient_element(x, U) = [∇f1(x[U[1]]), ∇f2(x[U[2]])] :: Vector{Vector{Float64}}\n# set each element vector to its corresponding element gradient\nset_epv!(partitioned_gradient_x0, vector_gradient_element(x0, U)) \n\n# Build the gradient vector\nbuild_v!(partitioned_gradient_x0)\n\n# with the same value as the gradient\nget_v(partitioned_gradient_x0) == ∇f(x0)","category":"page"},{"location":"tutorial/#Approximate-the-Hessian-\\nabla2-f","page":"Tutorial","title":"Approximate the Hessian nabla^2 f","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are at least two ways to approximate nabla^2 f: a classical quasi-Newton approximation (ex: BFGS) and a partitioned quasi-Newton approximation (ex: PBFGS). Both methods are presented, and we expose the sparse structure of the partitioned approximation.","category":"page"},{"location":"tutorial/#Quasi-Newton-approximation-of-the-quadratic-(BFGS)","page":"Tutorial","title":"Quasi-Newton approximation of the quadratic (BFGS)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the case of the BFGS method, you want to approximate the Hessian from s = x1 - x0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x1 = [1., 2., 2.]\ns = x1 .- x0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the gradient difference y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"y = ∇f(x1) .- ∇f(x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the approximation B, initially set to the identity","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B = [ i==j ? 1. : 0. for i in 1:n, j in 1:n]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By applying the BFGS update, you satisfy the secant equation Bs = y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# PartitionedStructures.jl exports a BFGS implementation\nB_BFGS = BFGS(s,y,B) \n\nusing LinearAlgebra\n# numerical verification of the secant equation\natol = sqrt(eps(eltype(s)))\nnorm(B_BFGS * s - y) < atol ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"but the approximation B_BFGS is dense:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_BFGS","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which makes it impractical for large-scale problems.","category":"page"},{"location":"tutorial/#Partitioned-quasi-Newton-approximation-of-the-quadratic-(PBFGS)","page":"Tutorial","title":"Partitioned quasi-Newton approximation of the quadratic (PBFGS)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to make a sparse quasi-Newton approximation of nabla^2 f, you may define a partitioned matrix with the same partially-separable structure as partitioned_gradient_x0 where each element matrix is set to the identity","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_matrix = epm_from_epv(partitioned_gradient_x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It can be visualized with the Matrix constructor","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Matrix(partitioned_matrix)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The second term on the diagonal accumulates two components of value 1.0 from the two initial element approximations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then you compute the partitioned gradient at x1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_gradient_x1 = similar(partitioned_gradient_x0)\nset_epv!(partitioned_gradient_x1, vector_gradient_element(x1, U))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and compute the elementwise difference of the partitioned gradients partitioned_gradient_x1 - partitioned_gradient_x0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# copy to avoid side effects on partitioned_gradient_x0\npartitioned_gradient_difference = copy(partitioned_gradient_x0)\n\n# apply in place an unary minus to every element gradient\nminus_epv!(partitioned_gradient_difference)\n\n# add in place the element vector of partitioned_gradient_x1 \n# to the corresponding element vector of partitioned_gradient_difference\nadd_epv!(partitioned_gradient_x1, partitioned_gradient_difference)\n\n# compute the vector y\nbuild_v!(partitioned_gradient_difference) \nget_v(partitioned_gradient_difference) == y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then you can define the partitioned quasi-Newton PBFGS update","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# apply the partitioned PBFGS update to partitioned_matrix \n# and return Matrix(partitioned_matrix)\nB_PBFGS = update(partitioned_matrix, partitioned_gradient_difference, s; name=:pbfgs, verbose=true)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which respects the sparsity structure of ∇²f.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition, update() indicates the number of elements: updated, not updated or untouched, as long as the user doesn't set verbose=false. The partitioned update verifies the secant equation","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"norm(B_PBFGS*s - y) < atol","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which may also be calculated with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# compute the product partitioned matrix vector\nBs = mul_epm_vector(partitioned_matrix, s)\nnorm(Bs - y) < atol","category":"page"},{"location":"tutorial/#Other-partitioned-quasi-Newton-approximations","page":"Tutorial","title":"Other partitioned quasi-Newton approximations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There exist two categories of partitioned quasi-Newton updates. In the first category, each element Hessian nabla^2 f_i is approximated with a dense matrix, for example: PBFGS. In the second category, each element Hessian nabla^2 f_i is approximated with a quasi-Newton linear-operator.","category":"page"},{"location":"tutorial/#Partitioned-quasi-Newton-operators","page":"Tutorial","title":"Partitioned quasi-Newton operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the partitioned matrix is allocated,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_matrix_PBFGS = epm_from_epv(partitioned_gradient_x0)\npartitioned_matrix_PSR1 = epm_from_epv(partitioned_gradient_x0)\npartitioned_matrix_PSE = epm_from_epv(partitioned_gradient_x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"you can apply on it any of the three partitioned updates : PBFGS, PSR1, PSE (by default) :","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PBFGS updates each element approximation with BFGS;\nPSR1 updates each element approximation with SR1;\nIn PSE, each element approximation is updated with BFGS if it is possible or with SR1 otherwise.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_PBFGS = update(partitioned_matrix_PBFGS, partitioned_gradient_difference, s; name=:pbfgs)\nB_PSR1 = update(partitioned_matrix_PSR1, partitioned_gradient_difference, s; name=:psr1)\n # name=:pse by default\nB_PSE = update(partitioned_matrix_PSE, partitioned_gradient_difference, s)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All these approximations satisfy the secant equation as long as every element approximation is updated","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"norm(mul_epm_vector(partitioned_matrix_PBFGS, s) - y) < atol","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"norm(mul_epm_vector(partitioned_matrix_PSR1, s) - y) < atol","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"norm(mul_epm_vector(partitioned_matrix_PSE, s) - y) < atol","category":"page"},{"location":"tutorial/#Limited-memory-partitioned-quasi-Newton-operators","page":"Tutorial","title":"Limited-memory partitioned quasi-Newton operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These operators exist to apply the partitioned quasi-Newton methods to a partially-separable function with large n_i, whose element Hessian approximations can't be store as dense matrices. The limited-memory partitioned quasi-Newton operators allocate a quasi-Newton operator LBFGS or LSR1 defined in LinearOperators.jl for each element Hessian approximation. It defines three approximations:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PLBFGS, each element approximation is a LBFGSOperator;\nPLSR1, each element approximation is a LSR1Operator;\nPLSE, each element approximation may be a LBFGSOperator or LSR1Operator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Contrary to the partitioned quasi-Newton operators, each partitioned limited-memory quasi-Newton operators has a different type","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_linear_operator_PLBFGS = eplo_lbfgs_from_epv(partitioned_gradient_x0)\npartitioned_linear_operator_PLSR1 = eplo_lsr1_from_epv(partitioned_gradient_x0)\npartitioned_linear_operator_PLSE = eplo_lose_from_epv(partitioned_gradient_x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The different types simplify the update method, since no argument name is required to determine which update is applied","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_PLBFGS = update(partitioned_linear_operator_PLBFGS, partitioned_gradient_difference, s)\nnorm(B_PLBFGS * s - y) < atol","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_PLSE = update(partitioned_linear_operator_PLSE, partitioned_gradient_difference, s)\nnorm(B_PLSE * s - y) < atol","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_PLSR1 = update(partitioned_linear_operator_PLSR1, partitioned_gradient_difference, s)\nnorm(B_PLSR1 * s - y) < atol","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it, you have all the tools to implement a partitioned quasi-Newton method. Enjoy!","category":"page"},{"location":"tutorial/#Tips","page":"Tutorial","title":"Tips","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main issue about the definition of partitioned structures is informing the f_i and U_i. To address this issue you may want to take a look at ExpressionTreeForge.jl which detect automatically the partially separable structure from an ADNLPModels or a JuMP model.","category":"page"}]
}
