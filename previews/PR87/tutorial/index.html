<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · PartitionedStructures.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PartitionedStructures.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PartitionedStructures.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations"><span>What are the partially-separable structure and the partitioned quasi-Newton approximations</span></a></li><li><a class="tocitem" href="#Example:-the-partitioned-structure-of-a-quadratic"><span>Example: the partitioned structure of a quadratic</span></a></li><li><a class="tocitem" href="#Approximate-the-Hessian-\\nabla2-f"><span>Approximate the Hessian <span>$\nabla^2 f$</span></span></a></li><li><a class="tocitem" href="#Other-partitioned-quasi-Newton-approximations"><span>Other partitioned quasi-Newton approximations</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../developer_note/">Developer note</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PartitionedStructures.jl:-Tutorial"><a class="docs-heading-anchor" href="#PartitionedStructures.jl:-Tutorial">PartitionedStructures.jl: Tutorial</a><a id="PartitionedStructures.jl:-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#PartitionedStructures.jl:-Tutorial" title="Permalink"></a></h1><p>This tutorial shows how <a href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl">PartitionedStructures.jl</a> can define partitioned quasi-Newton approximations, by using partitioned vectors and partitioned matrices. Those partitioned structures are strongly related to partially-separable functions.</p><h2 id="What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations"><a class="docs-heading-anchor" href="#What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations">What are the partially-separable structure and the partitioned quasi-Newton approximations</a><a id="What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations-1"></a><a class="docs-heading-anchor-permalink" href="#What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations" title="Permalink"></a></h2><p>The partitioned quasi-Newton methods exploit the partially-separable structure of <span>$f:\R^n \to \R$</span></p><p class="math-container">\[ f(x) = \sum_{i=1}^N f_i (U_i x) , \; f_i : \R^{n_i} \to \R, \; U_i \in \R^{n_i \times n},\; n_i \ll n,\]</p><p>as the sum of element function <span>$f_i$</span>. The gradient <span>$\nabla f$</span> and the Hessian <span>$\nabla^2 f$</span></p><p class="math-container">\[\nabla f(x) = \sum_{i=1}^N U_i^\top f_i (U_i x), \quad \nabla^2 f(x) = \sum_{i=1}^N U_i^\top f_i (U_i x) U_i,\]</p><p>accumulate the element derivatives <span>$\nabla f_i$</span> and <span>$\nabla^2 f_i$</span>.</p><p>The partitioned structure of the Hessian let us the definition of partitioned quasi-Newton approximations <span>$B \approx \nabla^2 f$</span>, such that <span>$B$</span> accumulates every element Hessian approximation <span>$B_i \approx \nabla^2 f_i$</span></p><p class="math-container">\[B = \sum_{i=1}^N U_i^\top B_i U_i\]</p><p>The partitioned quasi-Newton approximations respect sparsity structure of <span>$\nabla^2 f$</span>, which is not the case of classical quasi-Newton approximation (e.g. BFGS, SR1). Moreover, the rank of the partitioned updates may be proportional to the number of elements <span>$N$</span>, whereas classical quasi-Newton approximations are low-rank updates. A partitioned quasi-Newton update may update every element-Hessian <span>$B_i$</span> at each step <span>$s$</span>. It requires <span>$B_i$</span>, <span>$U_i s$</span> and <span>$\nabla f_i (U_i (x+s)) - \nabla f_i (U_i x)$</span>, and therefore we have to store such an approximation and vectors for every element.</p><h4 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h4><ul><li>A. Griewank and Ph. L. Toint. Partitioned variable metric updates for large structured optimization problems. Numer. Math., 39:119–137, 1982, <a href="https://link.springer.com/article/10.1007/BF01399316">10.1007/BF01399316</a></li></ul><h2 id="Example:-the-partitioned-structure-of-a-quadratic"><a class="docs-heading-anchor" href="#Example:-the-partitioned-structure-of-a-quadratic">Example: the partitioned structure of a quadratic</a><a id="Example:-the-partitioned-structure-of-a-quadratic-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-the-partitioned-structure-of-a-quadratic" title="Permalink"></a></h2><p>Let&#39;s take the quadratic <code>f</code> as an example</p><pre><code class="language-julia">f(x) = x[1]^2 + x[1]*x[2] + x[2]^2 + x[3]^2 + 3x[2]*x[3]</code></pre><pre class="documenter-example-output">f (generic function with 1 method)</pre><p><code>f</code> can be considered as the sum of two element functions</p><pre><code class="language-julia">f1(y) = y[1]^2 + y[1]*y[2]
f2(y) = y[1]^2 + y[2]^2 + 3y[1]*y[2]</code></pre><pre class="documenter-example-output">f2 (generic function with 1 method)</pre><p>Define <span>$U_1$</span> and <span>$U_2$</span> indicating which variables are required by each element function:</p><pre><code class="language-julia">U1 = [1 0 0; 0 1 0]
U2 = [0 1 0; 0 0 1]</code></pre><pre class="documenter-example-output">2×3 Matrix{Int64}:
 0  1  0
 0  0  1</pre><p>However, dense matrices produce a memory issue for large problems. Instead, we use a linear operator only informing the indices of the variables</p><pre><code class="language-julia">U1 = [1, 2]
U2 = [2, 3]</code></pre><pre class="documenter-example-output">2-element Vector{Int64}:
 2
 3</pre><p>By gathering the different <span>$U_i$</span> together</p><pre><code class="language-julia">U = [U1, U2]</code></pre><pre class="documenter-example-output">2-element Vector{Vector{Int64}}:
 [1, 2]
 [2, 3]</pre><p>we define the function exploiting the partially-separable structure <code>f_pss</code> as</p><pre><code class="language-julia">f_pss(x, U) = f1(x[U[1]]) + f2(x[U[2]])
x0 = [2., 3., 4.]

f(x0) == f_pss(x0, U)</code></pre><pre class="documenter-example-output">true</pre><p>Similarly, we can compute: the gradient, the element gradients and explicit how the gradient is partitioned</p><pre><code class="language-julia">∇f(x) = [2x[1] + x[2], x[1] + 2x[2] + 3x[3], 2x[3] + 3x[2]]
∇f1(y) = [2y[1] + y[2], y[1]]
∇f2(y) = [2y[1] + 3y[2], 2y[2] + 3y[1]]
function ∇f_pss(x, U)
  gradient = zeros(length(x))
  gradient[U1] .+= ∇f1(x[U[1]])
  gradient[U2] .+= ∇f2(x[U[2]])
  return gradient
end
∇f(x0) == ∇f_pss(x0, U)</code></pre><pre class="documenter-example-output">true</pre><p>However, <code>∇f_pss</code> accumulates directly the element gradients and does not store the value of each element gradients <code>∇f1, ∇f2</code>. We would like to store every element gradient, so we can later update partitioned quasi-Newton approximations. Thus, we define a partitioned vector from <code>U</code> to store each element gradient and form <span>$\nabla f$</span> when required:</p><pre><code class="language-julia">using PartitionedStructures
U = [U1, U2]
n = length(x0)
# create the partitioned vector
partitioned_gradient_x0 = create_epv(U)</code></pre><pre class="documenter-example-output">Elemental_pv{Float64}(2, 3, Elemental_elt_vec{Float64}[Elemental_elt_vec{Float64}([0.596180073118232, 0.037706738811509655], [1, 2], 2), Elemental_elt_vec{Float64}([0.6813164461571587, 0.7550501576080129], [2, 3], 2)], [0.0, 0.0, 0.0], [[1], [1, 2], [2]], [1, 2, 3])</pre><p>We set the value of each element vector to the corresponding element gradient</p><pre><code class="language-julia"># return every element gradient
vector_gradient_element(x, U) = [∇f1(x[U[1]]), ∇f2(x[U[2]])] :: Vector{Vector{Float64}}
# set each element vector to its corresponding element gradient
set_epv!(partitioned_gradient_x0, vector_gradient_element(x0, U))

# Build the gradient vector
build_v!(partitioned_gradient_x0)

# with the same value as the gradient
get_v(partitioned_gradient_x0) == ∇f(x0)</code></pre><pre class="documenter-example-output">true</pre><h2 id="Approximate-the-Hessian-\\nabla2-f"><a class="docs-heading-anchor" href="#Approximate-the-Hessian-\\nabla2-f">Approximate the Hessian <span>$\nabla^2 f$</span></a><a id="Approximate-the-Hessian-\\nabla2-f-1"></a><a class="docs-heading-anchor-permalink" href="#Approximate-the-Hessian-\\nabla2-f" title="Permalink"></a></h2><p>There are at least two ways to approximate <span>$\nabla^2 f$</span>: a classical quasi-Newton approximation (ex: BFGS) and a partitioned quasi-Newton approximation (ex: PBFGS). Both methods are presented, and we expose the sparse structure of the partitioned approximation.</p><h3 id="Quasi-Newton-approximation-of-the-quadratic-(BFGS)"><a class="docs-heading-anchor" href="#Quasi-Newton-approximation-of-the-quadratic-(BFGS)">Quasi-Newton approximation of the quadratic (BFGS)</a><a id="Quasi-Newton-approximation-of-the-quadratic-(BFGS)-1"></a><a class="docs-heading-anchor-permalink" href="#Quasi-Newton-approximation-of-the-quadratic-(BFGS)" title="Permalink"></a></h3><p>In the case of the BFGS method, you want to approximate the Hessian from <code>s = x1 - x0</code></p><pre><code class="language-julia">x1 = [1., 2., 2.]
s = x1 .- x0</code></pre><pre class="documenter-example-output">3-element Vector{Float64}:
 -1.0
 -1.0
 -2.0</pre><p>the gradient difference <code>y</code></p><pre><code class="language-julia">y = ∇f(x1) .- ∇f(x0)</code></pre><pre class="documenter-example-output">3-element Vector{Float64}:
 -3.0
 -9.0
 -7.0</pre><p>and the approximation <code>B</code>, initially set to the identity</p><pre><code class="language-julia">B = [ i==j ? 1. : 0. for i in 1:n, j in 1:n]</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</pre><p>By applying the BFGS update, you satisfy the secant equation <code>Bs = y</code></p><pre><code class="language-julia"># PartitionedStructures.jl exports a BFGS implementation
B_BFGS = BFGS(s,y,B)

using LinearAlgebra
# numerical verification of the secant equation
atol = sqrt(eps(eltype(s)))
norm(B_BFGS * s - y) &lt; atol</code></pre><pre class="documenter-example-output">true</pre><p>but the approximation <code>B_BFGS</code> is dense:</p><pre><code class="language-julia">B_BFGS</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 1.17949   0.871795  0.474359
 0.871795  3.94872   2.08974
 0.474359  2.08974   2.21795</pre><p>which makes it impractical for large-scale problems.</p><h3 id="Partitioned-quasi-Newton-approximation-of-the-quadratic-(PBFGS)"><a class="docs-heading-anchor" href="#Partitioned-quasi-Newton-approximation-of-the-quadratic-(PBFGS)">Partitioned quasi-Newton approximation of the quadratic (PBFGS)</a><a id="Partitioned-quasi-Newton-approximation-of-the-quadratic-(PBFGS)-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-quasi-Newton-approximation-of-the-quadratic-(PBFGS)" title="Permalink"></a></h3><p>In order to make a sparse quasi-Newton approximation of <span>$\nabla^2 f$</span>, you may define a partitioned matrix with the same partially-separable structure as <code>partitioned_gradient_x0</code> where each element matrix is set to the identity</p><pre><code class="language-julia">partitioned_matrix = epm_from_epv(partitioned_gradient_x0)</code></pre><pre class="documenter-example-output">Elemental_pm{Float64}(2, 3, Elemental_em{Float64}[Elemental_em{Float64}(2, [1, 2], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0), false, false, [NaN, 6.9452354434591e-310]), Elemental_em{Float64}(2, [2, 3], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0), false, false, [6.9452354775532e-310, 4.45619117975e-313])], sparse(Int64[], Int64[], Float64[], 3, 3), sparse(Int64[], Int64[], Float64[], 3, 3), [[1], [1, 2], [2]], [1, 2, 3])</pre><p>It can be visualized with the <code>Matrix</code> constructor</p><pre><code class="language-julia">Matrix(partitioned_matrix)</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  2.0  0.0
 0.0  0.0  1.0</pre><p>The second term on the diagonal accumulates two components of value 1.0 from the two initial element approximations.</p><p>Then you compute the partitioned gradient at <code>x1</code></p><pre><code class="language-julia">partitioned_gradient_x1 = similar(partitioned_gradient_x0)
set_epv!(partitioned_gradient_x1, vector_gradient_element(x1, U))</code></pre><pre class="documenter-example-output">Elemental_pv{Float64}(2, 3, Elemental_elt_vec{Float64}[Elemental_elt_vec{Float64}([4.0, 1.0], [1, 2], 2), Elemental_elt_vec{Float64}([10.0, 10.0], [2, 3], 2)], [6.94523547142637e-310, 1.718816590835e-312, 6.94522547698665e-310], [[1], [1, 2], [2]], [1, 2, 3])</pre><p>and compute the elementwise difference of the partitioned gradients <code>partitioned_gradient_x1 - partitioned_gradient_x0</code></p><pre><code class="language-julia"># copy to avoid side effects on partitioned_gradient_x0
partitioned_gradient_difference = copy(partitioned_gradient_x0)

# apply in place an unary minus to every element gradient
minus_epv!(partitioned_gradient_difference)

# add in place the element vector of partitioned_gradient_x1
# to the corresponding element vector of partitioned_gradient_difference
add_epv!(partitioned_gradient_x1, partitioned_gradient_difference)

# compute the vector y
build_v!(partitioned_gradient_difference)
get_v(partitioned_gradient_difference) == y</code></pre><pre class="documenter-example-output">true</pre><p>Then you can define the partitioned quasi-Newton PBFGS update</p><pre><code class="language-julia"># apply the partitioned PBFGS update to partitioned_matrix
# and return Matrix(partitioned_matrix)
B_PBFGS = update(partitioned_matrix, partitioned_gradient_difference, s; name=:pbfgs, verbose=true)</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 2.75  0.25     0.0
 0.25  4.45909  2.14545
 0.0   2.14545  2.42727</pre><p>which respects the sparsity structure of ∇²f.</p><p>In addition, <code>update()</code> indicates the number of elements: updated, not updated or untouched, as long as the user doesn&#39;t set <code>verbose=false</code>. The partitioned update verifies the secant equation</p><pre><code class="language-julia">norm(B_PBFGS*s - y) &lt; atol</code></pre><pre class="documenter-example-output">true</pre><p>which may also be calculated with</p><pre><code class="language-julia"># compute the product partitioned matrix vector
Bs = mul_epm_vector(partitioned_matrix, s)
norm(Bs - y) &lt; atol</code></pre><pre class="documenter-example-output">true</pre><h2 id="Other-partitioned-quasi-Newton-approximations"><a class="docs-heading-anchor" href="#Other-partitioned-quasi-Newton-approximations">Other partitioned quasi-Newton approximations</a><a id="Other-partitioned-quasi-Newton-approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Other-partitioned-quasi-Newton-approximations" title="Permalink"></a></h2><p>There exist two categories of partitioned quasi-Newton updates. In the first category, each element Hessian <span>$\nabla^2 f_i$</span> is approximated with a dense matrix, for example: PBFGS. In the second category, each element Hessian <span>$\nabla^2 f_i$</span> is approximated with a quasi-Newton linear-operator.</p><h3 id="Partitioned-quasi-Newton-operators"><a class="docs-heading-anchor" href="#Partitioned-quasi-Newton-operators">Partitioned quasi-Newton operators</a><a id="Partitioned-quasi-Newton-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-quasi-Newton-operators" title="Permalink"></a></h3><p>Once the partitioned matrix is allocated,</p><pre><code class="language-julia">partitioned_matrix_PBFGS = epm_from_epv(partitioned_gradient_x0)
partitioned_matrix_PSR1 = epm_from_epv(partitioned_gradient_x0)
partitioned_matrix_PSE = epm_from_epv(partitioned_gradient_x0)</code></pre><pre class="documenter-example-output">Elemental_pm{Float64}(2, 3, Elemental_em{Float64}[Elemental_em{Float64}(2, [1, 2], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0), false, false, [6.94523546905644e-310, 4.031792003076e-312]), Elemental_em{Float64}(2, [2, 3], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0), false, false, [6.9452354710493e-310, 4.116671836923e-312])], sparse(Int64[], Int64[], Float64[], 3, 3), sparse(Int64[], Int64[], Float64[], 3, 3), [[1], [1, 2], [2]], [1, 2, 3])</pre><p>you can apply on it any of the three partitioned updates : PBFGS, PSR1, PSE (by default) :</p><ul><li>PBFGS updates each element approximation with BFGS;</li><li>PSR1 updates each element approximation with SR1;</li><li>In PSE, each element approximation is updated with BFGS if it is possible or with SR1 otherwise.</li></ul><pre><code class="language-julia">B_PBFGS = update(partitioned_matrix_PBFGS, partitioned_gradient_difference, s; name=:pbfgs)
B_PSR1 = update(partitioned_matrix_PSR1, partitioned_gradient_difference, s; name=:psr1)
 # name=:pse by default
B_PSE = update(partitioned_matrix_PSE, partitioned_gradient_difference, s)</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 2.75  0.25     0.0
 0.25  4.45909  2.14545
 0.0   2.14545  2.42727</pre><p>All these approximations satisfy the secant equation as long as every element approximation is updated</p><pre><code class="language-julia">norm(mul_epm_vector(partitioned_matrix_PBFGS, s) - y) &lt; atol</code></pre><pre class="documenter-example-output">true</pre><pre><code class="language-julia">norm(mul_epm_vector(partitioned_matrix_PSR1, s) - y) &lt; atol</code></pre><pre class="documenter-example-output">true</pre><pre><code class="language-julia">norm(mul_epm_vector(partitioned_matrix_PSE, s) - y) &lt; atol</code></pre><pre class="documenter-example-output">true</pre><h3 id="Limited-memory-partitioned-quasi-Newton-operators"><a class="docs-heading-anchor" href="#Limited-memory-partitioned-quasi-Newton-operators">Limited-memory partitioned quasi-Newton operators</a><a id="Limited-memory-partitioned-quasi-Newton-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Limited-memory-partitioned-quasi-Newton-operators" title="Permalink"></a></h3><p>These operators exist to apply the partitioned quasi-Newton methods to a partially-separable function with large <span>$n_i$</span>, whose element Hessian approximations can&#39;t be store as dense matrices. The limited-memory partitioned quasi-Newton operators allocate a quasi-Newton operator LBFGS or LSR1 defined in <a href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl">LinearOperators.jl</a> for each element Hessian approximation. It defines three approximations:</p><ul><li>PLBFGS, each element approximation is a <code>LBFGSOperator</code>;</li><li>PLSR1, each element approximation is a <code>LSR1Operator</code>;</li><li>PLSE, each element approximation may be a <code>LBFGSOperator</code> or <code>LSR1Operator</code>.</li></ul><p>Contrary to the partitioned quasi-Newton operators, each partitioned limited-memory quasi-Newton operators has a different type</p><pre><code class="language-julia">partitioned_linear_operator_PLBFGS = eplo_lbfgs_from_epv(partitioned_gradient_x0)
partitioned_linear_operator_PLSR1 = eplo_lsr1_from_epv(partitioned_gradient_x0)
partitioned_linear_operator_PLSE = eplo_lose_from_epv(partitioned_gradient_x0)</code></pre><pre class="documenter-example-output">Elemental_plo{Float64}(2, 3, Union{Elemental_elo_bfgs{Float64}, Elemental_elo_sr1{Float64}}[Elemental_elo_bfgs{Float64}(2, [1, 2], Linear operator
  nrow: 2
  ncol: 2
  eltype: Float64
  symmetric: true
  hermitian: true
  nprod:   0
  ntprod:  0
  nctprod: 0

, Counter_elt_mat(0, 0, 0, 0, 0, 0), false), Elemental_elo_bfgs{Float64}(2, [2, 3], Linear operator
  nrow: 2
  ncol: 2
  eltype: Float64
  symmetric: true
  hermitian: true
  nprod:   0
  ntprod:  0
  nctprod: 0

, Counter_elt_mat(0, 0, 0, 0, 0, 0), false)], sparse(Int64[], Int64[], Float64[], 3, 3), sparse(Int64[], Int64[], Float64[], 3, 3), [[1], [1, 2], [2]], [1, 2, 3])</pre><p>The different types simplify the <code>update</code> method, since no argument <code>name</code> is required to determine which update is applied</p><pre><code class="language-julia">B_PLBFGS = update(partitioned_linear_operator_PLBFGS, partitioned_gradient_difference, s)
norm(B_PLBFGS * s - y) &lt; atol</code></pre><pre class="documenter-example-output">true</pre><pre><code class="language-julia">B_PLSE = update(partitioned_linear_operator_PLSE, partitioned_gradient_difference, s)
norm(B_PLSE * s - y) &lt; atol</code></pre><pre class="documenter-example-output">true</pre><pre><code class="language-julia">B_PLSR1 = update(partitioned_linear_operator_PLSR1, partitioned_gradient_difference, s)
norm(B_PLSR1 * s - y) &lt; atol</code></pre><pre class="documenter-example-output">true</pre><p>That&#39;s it, you have all the tools to implement a partitioned quasi-Newton method. Enjoy!</p><h3 id="Tips"><a class="docs-heading-anchor" href="#Tips">Tips</a><a id="Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Tips" title="Permalink"></a></h3><p>The main issue about the definition of partitioned structures is informing the <span>$f_i$</span> and <span>$U_i$</span>. To address this issue you may want to take a look at <a href="https://github.com/JuliaSmoothOptimizers/ExpressionTreeForge.jl">ExpressionTreeForge.jl</a> which detect automatically the partially separable structure from an <a href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl">ADNLPModels</a> or a <a href="https://github.com/jump-dev/JuMP.jl">JuMP model</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 1 November 2024 23:45">Friday 1 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
