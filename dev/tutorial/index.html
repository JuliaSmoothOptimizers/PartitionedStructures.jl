<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · PartitionedStructures.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PartitionedStructures.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PartitionedStructures.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Reminder-about-the-partially-separable-structure-and-partitioned-quasi-Newton-updates"><span>Reminder about the partially separable structure and partitioned quasi-Newton updates</span></a></li><li><a class="tocitem" href="#The-partitioned-structure-of-a-quadratic"><span>The partitioned structure of a quadratic</span></a></li><li><a class="tocitem" href="#Quasi-Newton-approximation-of-the-quadratic"><span>Quasi-Newton approximation of the quadratic</span></a></li><li><a class="tocitem" href="#Partitioned-quasi-Newton-approximation-of-the-quadratic"><span>Partitioned quasi-Newton approximation of the quadratic</span></a></li><li><a class="tocitem" href="#Other-partitioned-quasi-Newton-approximation"><span>Other partitioned quasi-Newton approximation</span></a></li><li><a class="tocitem" href="#Features"><span>Features</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../developper_note/">Developper note</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/paraynaud/PartitionedStructures.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PartitionedStructures.jl:-Tutorial"><a class="docs-heading-anchor" href="#PartitionedStructures.jl:-Tutorial">PartitionedStructures.jl: Tutorial</a><a id="PartitionedStructures.jl:-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#PartitionedStructures.jl:-Tutorial" title="Permalink"></a></h1><h2 id="Reminder-about-the-partially-separable-structure-and-partitioned-quasi-Newton-updates"><a class="docs-heading-anchor" href="#Reminder-about-the-partially-separable-structure-and-partitioned-quasi-Newton-updates">Reminder about the partially separable structure and partitioned quasi-Newton updates</a><a id="Reminder-about-the-partially-separable-structure-and-partitioned-quasi-Newton-updates-1"></a><a class="docs-heading-anchor-permalink" href="#Reminder-about-the-partially-separable-structure-and-partitioned-quasi-Newton-updates" title="Permalink"></a></h2><p>The quasi-Newton methods exploiting the partially separable function  $  f(x) = \sum<em>{i=1}^N \hat{f}</em>i (U<em>i) : \R^n \to \R, $ where \hat{f}</em>i : \R^{n<em>i} \to \R, \; U</em>i \in \R^{n<em>i \times n},\; n</em>i &lt; n<span>$, manipulate the partitioned derivatives $$  \nabla f(x) = \sum_{i=1}^N U_i^\top \hat{f}_i (U_i x), \quad \nabla^2 f(x) = \sum_{i=1}^N U_i^\top \hat{f}_i (U_i x) U_i, $$ which accumulate the element derivatives $\hat{f}_i$</span> and <span>$\nabla^2 \hat{f}_i$</span> to form <span>$\nabla f$</span> and <span>$\nabla^2 f$</span>.</p><p>These partitioned quasi-Newton methods define partitioned quasi-Newton approximations of the Hessian <span>$B \approx \nabla^2 f$</span>, such that <span>$B$</span> accumulate the element Hessian approximation <span>$\hat{B}_i \approx \nabla^2 \hat{f}_i$</span> with respect to <span>$U_i$</span>. $ B = \sum<em>{i=1}^N U</em>i^\top \hat{B}<em>i U</em>i $ The partitioned quasi-Newton approximations structurally keep the sparsity structure of <span>$\nabla^2 f$</span>, which is not the case of classical quasi-Newton approximation. Moreover, the rank of the partitioned updates may be proportional to the number of elements <code>N</code>, whereas classical quasi-Newton approximation are low rank updates. To perform a partitioned quasi-Newton update after a step <span>$s$</span>, you must update every element Hessian approximation <span>$\hat{B}_i$</span>. Then, the update of each element requires <span>$\hat{B}_i$</span>, <span>$U_i s$</span> and <span>$\nabla \hat{f}_i (U_i (x+s)) - \nabla \hat{f}_i (U_i x)$</span></p><h4 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h4><ul><li>A. Griewank and P. Toint, <em>On the unconstrained optimization of partially separable functions</em>, Numerische Nonlinear Optimization 1981, 39, pp. 301–312, 1982.</li></ul><h2 id="The-partitioned-structure-of-a-quadratic"><a class="docs-heading-anchor" href="#The-partitioned-structure-of-a-quadratic">The partitioned structure of a quadratic</a><a id="The-partitioned-structure-of-a-quadratic-1"></a><a class="docs-heading-anchor-permalink" href="#The-partitioned-structure-of-a-quadratic" title="Permalink"></a></h2><p>Let&#39;s take the quadratic function <code>f</code> as an example </p><pre><code class="language-julia">f(x) = x[1]^2 + x[2]^2 + x[3]^2 + x[1]*x[2] + 3x[2]*x[3]</code></pre><pre class="documenter-example-output">f (generic function with 1 method)</pre><p><code>f</code> can be considered as the sum of two element functions</p><pre><code class="language-julia">f1(x) = x[1]^2 + x[1]*x[2]
f2(x) = x[1]^2 + x[2]^2 + 3x[1]*x[2]</code></pre><pre class="documenter-example-output">f2 (generic function with 1 method)</pre><p>considering</p><pre><code class="language-julia">U1 = [1, 2] # [1 0 0; 0 1 0] as a matrix
U2 = [2, 3] # [0 1 0; 0 0 1] as a matrix</code></pre><pre class="documenter-example-output">2-element Vector{Int64}:
 2
 3</pre><p>inform the variables required by each element function.</p><p>By gathering the different <span>$U_i$</span> together</p><pre><code class="language-julia">U = [U1, U2]</code></pre><pre class="documenter-example-output">2-element Vector{Vector{Int64}}:
 [1, 2]
 [2, 3]</pre><p>we define the function <code>f_pss = f</code> exploiting the partially separable structure as</p><pre><code class="language-julia">f_pss(x, U) = f1(x[U[1]]) + f2(x[U[2]])

using Test
x0 = [2., 3., 4.]
@test f(x0) == f_pss(x0, U)</code></pre><pre class="documenter-example-output">Test Passed
  Expression: f(x0) == f_pss(x0, U)
   Evaluated: 71.0 == 71.0</pre><p>Similarly, you can compute: the gradient, the element gradients and explicit how the gradient is partitioned</p><pre><code class="language-julia">∇f(x) = [2x[1] + x[2], x[1] + 2x[2] + 3x[3], 2x[3] + 3x[2]]
∇f1(x) = [2x[1] + x[2], x[1]]
∇f2(x) = [2x[1] + 3x[2], 2x[2] + 3x[1]]
function ∇f_pss(x, U)
  gradient = zeros(length(x))
  gradient[U1] = ∇f1(x[U[1]])
  gradient[U2] .+= ∇f2(x[U[2]])
  return gradient
end
@test ∇f(x0) == ∇f_pss(x0, U)</code></pre><pre class="documenter-example-output">Test Passed
  Expression: ∇f(x0) == ∇f_pss(x0, U)
   Evaluated: [7.0, 20.0, 17.0] == [7.0, 20.0, 17.0]</pre><p>However, <code>∇f_pss</code> accumulates directly the element gradient and does not store the value of each element gradients <code>∇f1, ∇f2</code>. We would like to store every element gradient, such that afterward it is possible to build the difference element gradients required for the partitioned quasi-Newton update. We define the partitioned vector, from <code>U</code> and <code>n</code>, to store each element gradient and form the <span>$\nabla f$</span> when required</p><pre><code class="language-julia">using PartitionedStructures
U = [U1, U2]
n = length(x0)
partitioned_gradient_x0 = create_epv(U, n) # creates the partitioned vector</code></pre><pre class="documenter-example-output">Elemental_pv{Float64}(2, 3, Elemental_elt_vec{Float64}[Elemental_elt_vec{Float64}([0.3289188822036373, 0.1963920033058656], [1, 2], 2), Elemental_elt_vec{Float64}([0.8796520428828754, 0.3671639263564731], [2, 3], 2)], [0.0, 0.0, 0.0], [[1], [1, 2], [2]], [1, 2, 3])</pre><pre><code class="language-julia">Elemental_pv{Float64}(2, 3, Elemental_elt_vec{Float64}[Elemental_elt_vec{Float64}([0.5582481752025726, 0.5536916309593504], [1, 2], 2), Elemental_elt_vec{Float64}([0.974556124813947, 0.8994868430015379], [2, 3], 2)], [0.0, 0.0, 0.0], [[1], [1, 2], [2]], [1, 2, 3])</code></pre><pre class="documenter-example-output">Elemental_pv{Float64}(2, 3, Elemental_elt_vec{Float64}[Elemental_elt_vec{Float64}([0.5582481752025726, 0.5536916309593504], [1, 2], 2), Elemental_elt_vec{Float64}([0.974556124813947, 0.8994868430015379], [2, 3], 2)], [0.0, 0.0, 0.0], [[1], [1, 2], [2]], [1, 2, 3])</pre><p>We set the value of each element vector to the corresponding element gradient</p><pre><code class="language-julia">vector_gradient_element(x, U) = [∇f1(x[U[1]]), ∇f2(x[U[2]])] :: Vector{Vector{Float64}} # returns every element gradient
set_epv!(partitioned_gradient_x0, vector_gradient_element(x0, U)) # sets each element vector to its corresponding element gradient

build_v!(partitioned_gradient_x0) # builds the gradient vector
@test get_v(partitioned_gradient_x0) == ∇f(x0) # with the same value as the gradient</code></pre><pre class="documenter-example-output">Test Passed
  Expression: get_v(partitioned_gradient_x0) == ∇f(x0)
   Evaluated: [7.0, 20.0, 17.0] == [7.0, 20.0, 17.0]</pre><h2 id="Quasi-Newton-approximation-of-the-quadratic"><a class="docs-heading-anchor" href="#Quasi-Newton-approximation-of-the-quadratic">Quasi-Newton approximation of the quadratic</a><a id="Quasi-Newton-approximation-of-the-quadratic-1"></a><a class="docs-heading-anchor-permalink" href="#Quasi-Newton-approximation-of-the-quadratic" title="Permalink"></a></h2><p>In the case of the BFGS method, you want to approximate the Hessian matrix from <code>s = x1 - x0</code></p><pre><code class="language-julia">x1 = [1., 2., 3.]
s = x1 .- x0</code></pre><pre class="documenter-example-output">3-element Vector{Float64}:
 -1.0
 -1.0
 -1.0</pre><p>the gradient difference <code>y</code></p><pre><code class="language-julia">y = (∇f(x1) .- ∇f(x0))</code></pre><pre class="documenter-example-output">3-element Vector{Float64}:
 -3.0
 -6.0
 -5.0</pre><p>and the approximation <code>B</code>, initially set to the identity</p><pre><code class="language-julia">B = [ i==j ? 1. : 0. for i in 1:n, j in 1:n]</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</pre><p>By applying the BFGS update, you satisfy the secant equation <code>Bs = y</code></p><pre><code class="language-julia">B_BFGS = BFGS(s,y,B) # PartitionedStructures.jl implements BFGS

using LinearAlgebra
@test norm(B_BFGS * s - y) == 0. # numerical verification of the secant equation</code></pre><pre class="documenter-example-output">Test Passed
  Expression: norm(B_BFGS * s - y) == 0.0
   Evaluated: 0.0 == 0.0</pre><p>but the approximation <code>B_BFGS</code> is dense.</p><pre><code class="language-julia">B_BFGS</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 1.30952   0.952381  0.738095
 0.952381  3.2381    1.80952
 0.738095  1.80952   2.45238</pre><h2 id="Partitioned-quasi-Newton-approximation-of-the-quadratic"><a class="docs-heading-anchor" href="#Partitioned-quasi-Newton-approximation-of-the-quadratic">Partitioned quasi-Newton approximation of the quadratic</a><a id="Partitioned-quasi-Newton-approximation-of-the-quadratic-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-quasi-Newton-approximation-of-the-quadratic" title="Permalink"></a></h2><p>In order to make a sparse quasi-Newton approximation of <span>$\nabla^2 f$</span>, you may define a partitioned matrix with the same partially separable structure than <code>partitioned_gradient_x0</code> where each element matrix is set to the identity</p><pre><code class="language-julia">partitioned_matrix = epm_from_epv(partitioned_gradient_x0)</code></pre><pre class="documenter-example-output">Elemental_pm{Float64}(2, 3, Elemental_em{Float64}[Elemental_em{Float64}(2, [1, 2], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0)), Elemental_em{Float64}(2, [2, 3], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0))], sparse(Int64[], Int64[], Float64[], 3, 3), sparse(Int64[], Int64[], Float64[], 3, 3), [[1], [1, 2], [2]], [1, 2, 3])</pre><pre><code class="language-julia">Matrix(partitioned_matrix)</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  2.0  0.0
 0.0  0.0  1.0</pre><p>The second term of the diagonal accumulates two 1.0 from the two initial element approximations.</p><p>Then you compute the partitioned gradient at <code>x1</code></p><pre><code class="language-julia">partitioned_gradient_x1 = create_epv(U, n)
set_epv!(partitioned_gradient_x1, vector_gradient_element(x1, U))</code></pre><pre class="documenter-example-output">Elemental_pv{Float64}(2, 3, Elemental_elt_vec{Float64}[Elemental_elt_vec{Float64}([4.0, 1.0], [1, 2], 2), Elemental_elt_vec{Float64}([13.0, 12.0], [2, 3], 2)], [0.0, 0.0, 0.0], [[1], [1, 2], [2]], [1, 2, 3])</pre><p>and compute the difference of the partitioned gradients <code>partitioned_gradient_difference = partitioned_gradient_x1 - partitioned_gradient_x0</code></p><pre><code class="language-julia">partitioned_gradient_difference = copy(partitioned_gradient_x0) # copy to avoid side effects on partitioned_gradient_x0
minus_epv!(partitioned_gradient_difference) # applies a unary minus to every element gradient
add_epv!(partitioned_gradient_x1, partitioned_gradient_difference) # add the element vector of partitioned_gradient_x1 to the correspond element vector of partitioned_gradient_difference, add partitioned_gradient_x1 to partitioned_gradient_difference

build_v!(partitioned_gradient_difference) # computes the vector y
@test get_v(partitioned_gradient_difference) == y</code></pre><pre class="documenter-example-output">Test Passed
  Expression: get_v(partitioned_gradient_difference) == y
   Evaluated: [-3.0, -6.0, -5.0] == [-3.0, -6.0, -5.0]</pre><p>Then you can define the partitioned quasi-Newton update PBFGS</p><pre><code class="language-julia">B_PBFGS = update(partitioned_matrix, partitioned_gradient_difference, s; name=:pbfgs) # applies the partitioned update PBFGS to partitioned_matrix and returns Matrix(partitioned_matrix)</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 2.75  0.25  0.0
 0.25  3.75  2.0
 0.0   2.0   3.0</pre><pre><code class="language-julia"> B_PBFGS</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 2.75  0.25  0.0
 0.25  3.75  2.0
 0.0   2.0   3.0</pre><p>which keeps the sparsity structure of <span>$\nabla^2 f$</span>.</p><p>In addition, <code>update()</code> informs the number of element: updated, not updated or untouched, as long as the user don&#39;t set <code>verbose=false</code>. The partitioned update verifies the secant equation</p><pre><code class="language-julia">@test norm(B_PBFGS*s - y) == 0.</code></pre><pre class="documenter-example-output">Test Passed
  Expression: norm(B_PBFGS * s - y) == 0.0
   Evaluated: 0.0 == 0.0</pre><p>which may also be calculated with </p><pre><code class="language-julia">Bs = mul_epm_vector(partitioned_matrix, s) # compute the product partitioned-matrix vector
@test norm(Bs - y) == 0.</code></pre><pre class="documenter-example-output">Test Passed
  Expression: norm(Bs - y) == 0.0
   Evaluated: 0.0 == 0.0</pre><h2 id="Other-partitioned-quasi-Newton-approximation"><a class="docs-heading-anchor" href="#Other-partitioned-quasi-Newton-approximation">Other partitioned quasi-Newton approximation</a><a id="Other-partitioned-quasi-Newton-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Other-partitioned-quasi-Newton-approximation" title="Permalink"></a></h2><p>There exist two categories of partitioned quasi-Newton updates. In the first category, each element Hessian is approximate with a dense matrix, for example: PBFGS. In the second category, each element Hessian is approximate with a quasi-Newton linear operator.</p><h3 id="Partitioned-quasi-Newton-operators"><a class="docs-heading-anchor" href="#Partitioned-quasi-Newton-operators">Partitioned quasi-Newton operators</a><a id="Partitioned-quasi-Newton-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-quasi-Newton-operators" title="Permalink"></a></h3><p>Once the partitioned matrix is allocated, </p><pre><code class="language-julia">partitioned_matrix_PBFGS = epm_from_epv(partitioned_gradient_x0)
partitioned_matrix_PSR1 = epm_from_epv(partitioned_gradient_x0)
partitioned_matrix_PSE = epm_from_epv(partitioned_gradient_x0)</code></pre><pre class="documenter-example-output">Elemental_pm{Float64}(2, 3, Elemental_em{Float64}[Elemental_em{Float64}(2, [1, 2], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0)), Elemental_em{Float64}(2, [2, 3], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0))], sparse(Int64[], Int64[], Float64[], 3, 3), sparse(Int64[], Int64[], Float64[], 3, 3), [[1], [1, 2], [2]], [1, 2, 3])</pre><p>you can apply on it any of the three partitioned updates : PBFGS, PSR1, PSE (by default) : </p><ul><li>PBFGS update each element approximation with BFGS;</li><li>PSR1 update each element approximation with SR1;</li><li>PSE update each element approximate with BFGS if it is possible or with SR1 otherwise.</li></ul><pre><code class="language-julia">B_PBFGS = update(partitioned_matrix_PBFGS, partitioned_gradient_difference, s; name=:pbfgs)
B_PSR1 = update(partitioned_matrix_PSR1, partitioned_gradient_difference, s; name=:psr1)
B_PSE = update(partitioned_matrix_PSE, partitioned_gradient_difference, s) # ; name=:pse by default</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 2.75  0.25  0.0
 0.25  3.75  2.0
 0.0   2.0   3.0</pre><p>All these methods satisfy the secant equation as long as every element approximation is update</p><pre><code class="language-julia">@test norm(mul_epm_vector(partitioned_matrix_PBFGS, s) - y) == 0.
@test norm(mul_epm_vector(partitioned_matrix_PSR1, s) - y) == 0.
@test norm(mul_epm_vector(partitioned_matrix_PSE, s) - y) == 0.</code></pre><pre class="documenter-example-output">Test Passed
  Expression: norm(mul_epm_vector(partitioned_matrix_PSE, s) - y) == 0.0
   Evaluated: 0.0 == 0.0</pre><h3 id="Limited-memory-partitioned-quasi-Newton-operators"><a class="docs-heading-anchor" href="#Limited-memory-partitioned-quasi-Newton-operators">Limited-memory partitioned quasi-Newton operators</a><a id="Limited-memory-partitioned-quasi-Newton-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Limited-memory-partitioned-quasi-Newton-operators" title="Permalink"></a></h3><p>These operators are made to apply the partitioned quasi-Newton methods to the partially separable function with large elements, whose element approximations can&#39;t be store by dense matrices. The limited-memory partitioned quasi-Newton operators allocate for each element approximation a quasi-Newton operator LBFGS or LSR1 defined in <a href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl">LinearOperators.jl</a>. It defines three approximations:</p><ul><li>PLBFGS, each element approximation is a <code>LBFGSOperator</code>;</li><li>PLSR1, each element approximation is a <code>LSR1Operator</code> (issue in LinearOperator.jl);</li><li>PLSE, each element approximation may be a <code>LBFGSOperator</code> or <code>LSR1Operator</code>.</li></ul><p>Contrary to the partitioned quasi-Newton operators, each limited-memory version is typed differently</p><pre><code class="language-julia">partitioned_linear_operator_PLBFGS = eplom_lbfgs_from_epv(partitioned_gradient_x0)
partitioned_linear_operator_PLSR1 = eplom_lsr1_from_epv(partitioned_gradient_x0)
partitioned_linear_operator_PLSE = eplom_lose_from_epv(partitioned_gradient_x0)</code></pre><pre class="documenter-example-output">Elemental_plom{Float64}(2, 3, Union{Elemental_elom_bfgs{Float64}, Elemental_elom_sr1{Float64}}[Elemental_elom_bfgs{Float64}(2, [1, 2], Linear operator
  nrow: 2
  ncol: 2
  eltype: Float64
  symmetric: true
  hermitian: true
  nprod:   0
  ntprod:  0
  nctprod: 0

, Counter_elt_mat(0, 0, 0, 0, 0, 0)), Elemental_elom_bfgs{Float64}(2, [2, 3], Linear operator
  nrow: 2
  ncol: 2
  eltype: Float64
  symmetric: true
  hermitian: true
  nprod:   0
  ntprod:  0
  nctprod: 0

, Counter_elt_mat(0, 0, 0, 0, 0, 0))], sparse(Int64[], Int64[], Float64[], 3, 3), sparse(Int64[], Int64[], Float64[], 3, 3), [[1], [1, 2], [2]], [1, 2, 3])</pre><p>The different types simplify the <code>update</code> method, since no argument <code>name</code> is required to determine the update that will be applied</p><pre><code class="language-julia">B_PLBFGS = update(partitioned_linear_operator_PLBFGS, partitioned_gradient_difference, s)
B_PLSE = update(partitioned_linear_operator_PLSE, partitioned_gradient_difference, s)
B_PLSR1 = update(partitioned_linear_operator_PLSR1, partitioned_gradient_difference, s)

@test norm(B_PLBFGS * s - y) == 0.
@test norm(B_PLSE * s - y) == 0.
# @test norm(B_PLSR1 * s - y) == 0. # the second element hessian approximation is not update, since the element step and the gradient element difference are collinear.</code></pre><pre class="documenter-example-output">
 PLBFGS	 structure: Elemental_plom_bfgs{Float64} based from 2 elements; update: 2, untouch: 0, reset: 0
PLSE : LBFGS updates 2/2, LSR1 0/2, untouched 0/2, reset 0/2

 PLSR1	 structure: Elemental_plom_sr1{Float64} based from 2 elements; update: 2, untouch: 0, reset: 0</pre><p>That&#39;s it, you have all the tools to implement a partitioned quasi-Newton method, enjoy!</p><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><p>For now, PartitionedStructures.jl supports only the elemental <span>$U_i$</span>, i.e. the lines of <span>$U_i$</span> are vectors from the euclidean basis. Concretely, each <span>$U_i$</span> is a vector of size <span>$n_i$</span> whose the components indicate the indices of the variables used by the i-th element function.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 23 June 2022 16:18">Thursday 23 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
