<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · PartitionedStructures.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PartitionedStructures.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PartitionedStructures.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations"><span>What are the partially separable structure and the partitioned quasi-Newton approximations</span></a></li><li><a class="tocitem" href="#Example:-the-partitioned-structure-of-a-quadratic-function"><span>Example: the partitioned structure of a quadratic function</span></a></li><li><a class="tocitem" href="#Approximate-the-Hessian-f"><span>Approximate the Hessian ∇f²</span></a></li><li><a class="tocitem" href="#Others-partitioned-quasi-Newton-approximations"><span>Others partitioned quasi-Newton approximations</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../developer_note/">Developer note</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/paraynaud/PartitionedStructures.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PartitionedStructures.jl:-Tutorial"><a class="docs-heading-anchor" href="#PartitionedStructures.jl:-Tutorial">PartitionedStructures.jl: Tutorial</a><a id="PartitionedStructures.jl:-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#PartitionedStructures.jl:-Tutorial" title="Permalink"></a></h1><p>This tutorial shows how <a href="https://github.com/paraynaud/PartitionedStructures.jl">PartitionedStructures.jl</a> can define partitioned quasi-Newton approximations, by using the partitioned-vectors and the partitioned matrices. Those partitioned structures are strongly related to partially-separable functions.</p><h2 id="What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations"><a class="docs-heading-anchor" href="#What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations">What are the partially separable structure and the partitioned quasi-Newton approximations</a><a id="What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations-1"></a><a class="docs-heading-anchor-permalink" href="#What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations" title="Permalink"></a></h2><p>The partitioned quasi-Newton methods exploit the partially separable function</p><p class="math-container">\[ f(x) = \sum_{i=1}^N f_i (U_i) : \R^n \to \R,\; f_i : \R^{n_i} \to \R, \; U_i \in \R^{n_i \times n},\; n_i &lt; n,\]</p><p>the sum of element function fᵢ. The gradient ∇f and the Hessian ∇²f</p><p class="math-container">\[\nabla f(x) = \sum_{i=1}^N U_i^\top f_i (U_i x), \quad \nabla^2 f(x) = \sum_{i=1}^N U_i^\top f_i (U_i x) U_i,\]</p><p>accumulate the element derivatives ∇fᵢ and ∇²fᵢ with respect to the Uᵢ.</p><p>These partitioned structure of the Hessian permit to define partitioned quasi-Newton approximations B ≈ ∇²f, such that B accumulates every element-Hessian approximation Bᵢ ≈ ∇²fᵢ</p><p class="math-container">\[B = \sum_{i=1}^N U_i^\top B_i U_i\]</p><p>The partitioned quasi-Newton approximations structurally keep the sparsity structure of ∇²f, which is not the case of classical quasi-Newton approximation (BFGS, SR1). Moreover, the rank of the partitioned updates may be proportional to the number of elements <code>N</code>, whereas classical quasi-Newton approximations are low rank updates. A partitioned quasi-Newton update must update every approximation of element-Hessian Bᵢ at each step s. It requires Bᵢ, Uᵢs and ∇fᵢ(Uᵢ(x+s)) - ∇fᵢ(Uᵢx), and therefore we have to store such a matrix and vectors for every element.</p><h4 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h4><ul><li>A. Griewank and P. Toint, <em>On the unconstrained optimization of partially separable functions</em>, Numerische Nonlinear Optimization 1981, 39, pp. 301–312, 1982.</li></ul><h2 id="Example:-the-partitioned-structure-of-a-quadratic-function"><a class="docs-heading-anchor" href="#Example:-the-partitioned-structure-of-a-quadratic-function">Example: the partitioned structure of a quadratic function</a><a id="Example:-the-partitioned-structure-of-a-quadratic-function-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-the-partitioned-structure-of-a-quadratic-function" title="Permalink"></a></h2><p>Let&#39;s take the quadratic function <code>f</code> as an example</p><pre><code class="language-julia">f(x) = x[1]^2 + x[2]^2 + x[3]^2 + x[1]*x[2] + 3x[2]*x[3]</code></pre><pre class="documenter-example-output">f (generic function with 1 method)</pre><p><code>f</code> can be considered as the sum of two element functions</p><pre><code class="language-julia">f1(x) = x[1]^2 + x[1]*x[2]
f2(x) = x[1]^2 + x[2]^2 + 3x[1]*x[2]</code></pre><pre class="documenter-example-output">f2 (generic function with 1 method)</pre><p>considering U₁ and U₂ informing the variables required by each element function.</p><pre><code class="language-julia">U1 = [1, 2] # [1 0 0; 0 1 0] as a matrix
U2 = [2, 3] # [0 1 0; 0 0 1] as a matrix</code></pre><pre class="documenter-example-output">2-element Vector{Int64}:
 2
 3</pre><p>By gathering the different Uᵢ together</p><pre><code class="language-julia">U = [U1, U2]</code></pre><pre class="documenter-example-output">2-element Vector{Vector{Int64}}:
 [1, 2]
 [2, 3]</pre><p>we define the function exploiting the partially-separable structure <code>f_pss</code> as</p><pre><code class="language-julia">f_pss(x, U) = f1(x[U[1]]) + f2(x[U[2]])

using Test
x0 = [2., 3., 4.]
@test f(x0) == f_pss(x0, U)</code></pre><pre class="documenter-example-output">Test Passed
  Expression: f(x0) == f_pss(x0, U)
   Evaluated: 71.0 == 71.0</pre><p>Similarly, you can compute: the gradient, the element-gradients and explicit how the gradient is partitioned</p><pre><code class="language-julia">∇f(x) = [2x[1] + x[2], x[1] + 2x[2] + 3x[3], 2x[3] + 3x[2]]
∇f1(x) = [2x[1] + x[2], x[1]]
∇f2(x) = [2x[1] + 3x[2], 2x[2] + 3x[1]]
function ∇f_pss(x, U)
  gradient = zeros(length(x))
  gradient[U1] = ∇f1(x[U[1]])
  gradient[U2] .+= ∇f2(x[U[2]])
  return gradient
end
@test ∇f(x0) == ∇f_pss(x0, U)</code></pre><pre class="documenter-example-output">Test Passed
  Expression: ∇f(x0) == ∇f_pss(x0, U)
   Evaluated: [7.0, 20.0, 17.0] == [7.0, 20.0, 17.0]</pre><p>However, <code>∇f_pss</code> accumulates directly the element-gradient and does not store the value of each element-gradients <code>∇f1, ∇f2</code>. We would like to store every element-gradient to build afterward the element-gradients difference   required for the partitioned quasi-Newton update. Thus, we define the partitioned-vector from <code>U</code>, to store each element-gradient and form the ∇f when required</p><pre><code class="language-julia">using PartitionedStructures
U = [U1, U2]
n = length(x0)
partitioned_gradient_x0 = create_epv(U) # creates the partitioned-vector</code></pre><pre class="documenter-example-output">Elemental_pv{Float64}(2, 3, Elemental_elt_vec{Float64}[Elemental_elt_vec{Float64}([0.21075291716591293, 0.809441883957472], [1, 2], 2), Elemental_elt_vec{Float64}([0.22637080273790933, 0.13968144960713624], [2, 3], 2)], [0.0, 0.0, 0.0], [[1], [1, 2], [2]], [1, 2, 3])</pre><p>We set the value of each element-vector to the corresponding element-gradient</p><pre><code class="language-julia">vector_gradient_element(x, U) = [∇f1(x[U[1]]), ∇f2(x[U[2]])] :: Vector{Vector{Float64}} # returns every element-gradient

set_epv!(partitioned_gradient_x0, vector_gradient_element(x0, U)) # sets each element-vector to its corresponding element-gradient

build_v!(partitioned_gradient_x0) # Build the gradient vector
@test get_v(partitioned_gradient_x0) == ∇f(x0) # with the same value as the gradient</code></pre><pre class="documenter-example-output">Test Passed
  Expression: get_v(partitioned_gradient_x0) == ∇f(x0)
   Evaluated: [7.0, 20.0, 17.0] == [7.0, 20.0, 17.0]</pre><h2 id="Approximate-the-Hessian-f"><a class="docs-heading-anchor" href="#Approximate-the-Hessian-f">Approximate the Hessian ∇f²</a><a id="Approximate-the-Hessian-f-1"></a><a class="docs-heading-anchor-permalink" href="#Approximate-the-Hessian-f" title="Permalink"></a></h2><p>There is at least two ways to approximate ∇f²: a classical quasi-Newton approximation (ex: BFGS) and a partitioned quasi-Newton approximation (ex: PBFGS). Both methods are presented, and we expose the sparse structure of partitioned approximation.</p><h3 id="Quasi-Newton-approximation-of-the-quadratic-(BFGS)"><a class="docs-heading-anchor" href="#Quasi-Newton-approximation-of-the-quadratic-(BFGS)">Quasi-Newton approximation of the quadratic (BFGS)</a><a id="Quasi-Newton-approximation-of-the-quadratic-(BFGS)-1"></a><a class="docs-heading-anchor-permalink" href="#Quasi-Newton-approximation-of-the-quadratic-(BFGS)" title="Permalink"></a></h3><p>In the case of the BFGS method, you want to approximate the Hessian matrix from <code>s = x1 - x0</code></p><pre><code class="language-julia">x1 = [1., 2., 2.]
s = x1 .- x0</code></pre><pre class="documenter-example-output">3-element Vector{Float64}:
 -1.0
 -1.0
 -2.0</pre><p>the gradient difference <code>y</code></p><pre><code class="language-julia">y = (∇f(x1) .- ∇f(x0))</code></pre><pre class="documenter-example-output">3-element Vector{Float64}:
 -3.0
 -9.0
 -7.0</pre><p>and the approximation <code>B</code>, initially set to the identity</p><pre><code class="language-julia">B = [ i==j ? 1. : 0. for i in 1:n, j in 1:n]</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</pre><p>By applying the BFGS update, you satisfy the secant equation <code>Bs = y</code></p><pre><code class="language-"># PartitionedStructures.jl export a BFGS implementation
B_BFGS = BFGS(s,y,B) 

using LinearAlgebra
# numerical verification of the secant equation
@test norm(B_BFGS * s - y) &lt; atol </code></pre><p>but the approximation <code>B_BFGS</code> is dense.</p><pre><code class="language-julia">B_BFGS</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 1.17949   0.871795  0.474359
 0.871795  3.94872   2.08974
 0.474359  2.08974   2.21795</pre><h3 id="Partitioned-quasi-Newton-approximation-of-the-quadratic-function-(PBFGS)"><a class="docs-heading-anchor" href="#Partitioned-quasi-Newton-approximation-of-the-quadratic-function-(PBFGS)">Partitioned quasi-Newton approximation of the quadratic function (PBFGS)</a><a id="Partitioned-quasi-Newton-approximation-of-the-quadratic-function-(PBFGS)-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-quasi-Newton-approximation-of-the-quadratic-function-(PBFGS)" title="Permalink"></a></h3><p>In order to make a sparse quasi-Newton approximation of ∇²f, you may define a partitioned-matrix with the same partially separable structure than <code>partitioned_gradient_x0</code> where each element-matrix is set to the identity</p><pre><code class="language-julia">partitioned_matrix = epm_from_epv(partitioned_gradient_x0)</code></pre><pre class="documenter-example-output">Elemental_pm{Float64}(2, 3, Elemental_em{Float64}[Elemental_em{Float64}(2, [1, 2], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0)), Elemental_em{Float64}(2, [2, 3], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0))], sparse(Int64[], Int64[], Float64[], 3, 3), sparse(Int64[], Int64[], Float64[], 3, 3), [[1], [1, 2], [2]], [1, 2, 3])</pre><p>It can be visualized with the <code>Matrix</code> constructor</p><pre><code class="language-julia">Matrix(partitioned_matrix)</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  2.0  0.0
 0.0  0.0  1.0</pre><p>The second term of the diagonal accumulates two 1.0 from the two initial element approximations.</p><p>Then you compute the partitioned-gradient at <code>x1</code></p><pre><code class="language-julia">partitioned_gradient_x1 = create_epv(U)
set_epv!(partitioned_gradient_x1, vector_gradient_element(x1, U))</code></pre><pre class="documenter-example-output">Elemental_pv{Float64}(2, 3, Elemental_elt_vec{Float64}[Elemental_elt_vec{Float64}([4.0, 1.0], [1, 2], 2), Elemental_elt_vec{Float64}([10.0, 10.0], [2, 3], 2)], [0.0, 0.0, 0.0], [[1], [1, 2], [2]], [1, 2, 3])</pre><p>and compute the elementwise difference of the partitioned-gradients <code>partitioned_gradient_x1 - partitioned_gradient_x0</code></p><pre><code class="language-julia"># copy to avoid side effects on partitioned_gradient_x0
partitioned_gradient_difference = copy(partitioned_gradient_x0)
# applies in place an unary minus to every element-gradient
minus_epv!(partitioned_gradient_difference)
# add in place the element-vector of partitioned_gradient_x1 to the corresponding element-vector of partitioned_gradient_difference
add_epv!(partitioned_gradient_x1, partitioned_gradient_difference)

build_v!(partitioned_gradient_difference) # computes the vector y
@test get_v(partitioned_gradient_difference) == y</code></pre><pre class="documenter-example-output">Test Passed
  Expression: get_v(partitioned_gradient_difference) == y
   Evaluated: [-3.0, -9.0, -7.0] == [-3.0, -9.0, -7.0]</pre><p>Then you can define the partitioned quasi-Newton update PBFGS</p><pre><code class="language-julia"># applies the partitioned update PBFGS to partitioned_matrix and returns Matrix(partitioned_matrix)
B_PBFGS = update(partitioned_matrix, partitioned_gradient_difference, s; name=:pbfgs, verbose=true)</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 2.75  0.25     0.0
 0.25  4.45909  2.14545
 0.0   2.14545  2.42727</pre><p>which keeps the sparsity structure of ∇²f.</p><p>In addition, <code>update()</code> informs the number of element: updated, not updated or untouched, as long as the user don&#39;t set <code>verbose=false</code>. The partitioned update verifies the secant equation</p><pre><code class="language-">atol = sqrt(eps(eltype(s1)))
@test norm(B_PBFGS*s - y) &lt; atol</code></pre><p>which may also be calculated with</p><pre><code class="language-"># compute the product partitioned-matrix vector
Bs = mul_epm_vector(partitioned_matrix, s)
@test norm(Bs - y) &lt; atol</code></pre><h2 id="Others-partitioned-quasi-Newton-approximations"><a class="docs-heading-anchor" href="#Others-partitioned-quasi-Newton-approximations">Others partitioned quasi-Newton approximations</a><a id="Others-partitioned-quasi-Newton-approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Others-partitioned-quasi-Newton-approximations" title="Permalink"></a></h2><p>There exist two categories of partitioned quasi-Newton updates. In the first category, each element-Hessian ∇²fᵢ is approximate with a dense matrix, for example: PBFGS. In the second category, each element-Hessian ∇²fᵢ is approximate with a quasi-Newton linear-operator.</p><h3 id="Partitioned-quasi-Newton-operators"><a class="docs-heading-anchor" href="#Partitioned-quasi-Newton-operators">Partitioned quasi-Newton operators</a><a id="Partitioned-quasi-Newton-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-quasi-Newton-operators" title="Permalink"></a></h3><p>Once the partitioned-matrix is allocated,</p><pre><code class="language-julia">partitioned_matrix_PBFGS = epm_from_epv(partitioned_gradient_x0)
partitioned_matrix_PSR1 = epm_from_epv(partitioned_gradient_x0)
partitioned_matrix_PSE = epm_from_epv(partitioned_gradient_x0)</code></pre><pre class="documenter-example-output">Elemental_pm{Float64}(2, 3, Elemental_em{Float64}[Elemental_em{Float64}(2, [1, 2], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0)), Elemental_em{Float64}(2, [2, 3], [1.0 0.0; 0.0 1.0], Counter_elt_mat(0, 0, 0, 0, 0, 0))], sparse(Int64[], Int64[], Float64[], 3, 3), sparse(Int64[], Int64[], Float64[], 3, 3), [[1], [1, 2], [2]], [1, 2, 3])</pre><p>you can apply on it any of the three partitioned updates : PBFGS, PSR1, PSE (by default) :</p><ul><li>PBFGS update each element approximation with BFGS;</li><li>PSR1 update each element approximation with SR1;</li><li>PSE each element approximation is update with BFGS if it is possible or with SR1 otherwise.</li></ul><pre><code class="language-julia">B_PBFGS = update(partitioned_matrix_PBFGS, partitioned_gradient_difference, s; name=:pbfgs)
B_PSR1 = update(partitioned_matrix_PSR1, partitioned_gradient_difference, s; name=:psr1)
B_PSE = update(partitioned_matrix_PSE, partitioned_gradient_difference, s) # ; name=:pse by default</code></pre><pre class="documenter-example-output">3×3 Matrix{Float64}:
 2.75  0.25     0.0
 0.25  4.45909  2.14545
 0.0   2.14545  2.42727</pre><p>All these methods satisfy the secant equation as long as every element approximation is updated</p><pre><code class="language-">@test norm(mul_epm_vector(partitioned_matrix_PBFGS, s) - y) &lt; atol
@test norm(mul_epm_vector(partitioned_matrix_PSR1, s) - y) &lt; atol
@test norm(mul_epm_vector(partitioned_matrix_PSE, s) - y) &lt; atol</code></pre><h3 id="Limited-memory-partitioned-quasi-Newton-operators"><a class="docs-heading-anchor" href="#Limited-memory-partitioned-quasi-Newton-operators">Limited-memory partitioned quasi-Newton operators</a><a id="Limited-memory-partitioned-quasi-Newton-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Limited-memory-partitioned-quasi-Newton-operators" title="Permalink"></a></h3><p>These operators are made to apply the partitioned quasi-Newton methods to the partially separable function with large elements, whose element-Hessian approximations can&#39;t be store by dense matrices. The limited-memory partitioned quasi-Newton operators allocate for each element-Hessian approximation a quasi-Newton operator LBFGS or LSR1 defined in <a href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl">LinearOperators.jl</a>. It defines three approximations:</p><ul><li>PLBFGS, each element approximation is a <code>LBFGSOperator</code>;</li><li>PLSR1, each element approximation is a <code>LSR1Operator</code> (issue in LinearOperator.jl);</li><li>PLSE, each element approximation may be a <code>LBFGSOperator</code> or <code>LSR1Operator</code>.</li></ul><p>Contrary to the partitioned quasi-Newton operators, each partitioned limited-memory quasi-Newton operators has a different type</p><pre><code class="language-julia">partitioned_linear_operator_PLBFGS = eplo_lbfgs_from_epv(partitioned_gradient_x0)
partitioned_linear_operator_PLSR1 = eplo_lsr1_from_epv(partitioned_gradient_x0)
partitioned_linear_operator_PLSE = eplo_lose_from_epv(partitioned_gradient_x0)</code></pre><pre class="documenter-example-output">Elemental_plo{Float64}(2, 3, Union{Elemental_elo_bfgs{Float64}, Elemental_elo_sr1{Float64}}[Elemental_elo_bfgs{Float64}(2, [1, 2], Linear operator
  nrow: 2
  ncol: 2
  eltype: Float64
  symmetric: true
  hermitian: true
  nprod:   0
  ntprod:  0
  nctprod: 0

, Counter_elt_mat(0, 0, 0, 0, 0, 0)), Elemental_elo_bfgs{Float64}(2, [2, 3], Linear operator
  nrow: 2
  ncol: 2
  eltype: Float64
  symmetric: true
  hermitian: true
  nprod:   0
  ntprod:  0
  nctprod: 0

, Counter_elt_mat(0, 0, 0, 0, 0, 0))], sparse(Int64[], Int64[], Float64[], 3, 3), sparse(Int64[], Int64[], Float64[], 3, 3), [[1], [1, 2], [2]], [1, 2, 3])</pre><p>The different types simplify the <code>update</code> method, since no argument <code>name</code> is required to determine which update is applied</p><pre><code class="language-">B_PLBFGS = update(partitioned_linear_operator_PLBFGS, partitioned_gradient_difference, s)
B_PLSE = update(partitioned_linear_operator_PLSE, partitioned_gradient_difference, s)
B_PLSR1 = update(partitioned_linear_operator_PLSR1, partitioned_gradient_difference, s)

@test norm(B_PLBFGS * s - y) &lt; atol
@test norm(B_PLSE * s - y) &lt; atol
@test norm(B_PLSR1 * s - y) &lt; atol</code></pre><p>That&#39;s it, you have all the tools to implement a partitioned quasi-Newton method, enjoy!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 30 June 2022 15:40">Thursday 30 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
