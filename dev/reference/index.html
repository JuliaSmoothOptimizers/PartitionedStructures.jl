<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PartitionedStructures.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PartitionedStructures.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PartitionedStructures.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../developer_note/">Developer note</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>​</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><p>​</p><ul><li><a href="#Reference">Reference</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></ul><p>​</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>​</p><ul><li><a href="#PartitionedStructures.M_abstract_element_struct.Element_struct"><code>PartitionedStructures.M_abstract_element_struct.Element_struct</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.AbstractPartitionedStructure</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.Counter_elt_mat"><code>PartitionedStructures.M_elt_mat.Counter_elt_mat</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.DenseEltMat"><code>PartitionedStructures.M_elt_mat.DenseEltMat</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.Elt_mat"><code>PartitionedStructures.M_elt_mat.Elt_mat</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.LOEltMat"><code>PartitionedStructures.M_elt_mat.LOEltMat</code></a></li><li><a href="#PartitionedStructures.M_elt_vec.Elt_vec"><code>PartitionedStructures.M_elt_vec.Elt_vec</code></a></li><li><a href="#PartitionedStructures.M_part_mat.Part_LO_mat"><code>PartitionedStructures.M_part_mat.Part_LO_mat</code></a></li><li><a href="#PartitionedStructures.M_part_mat.Part_mat"><code>PartitionedStructures.M_part_mat.Part_mat</code></a></li><li><a href="#PartitionedStructures.M_part_v.Part_v"><code>PartitionedStructures.M_part_v.Part_v</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_bfgs.Elemental_elo_bfgs"><code>PartitionedStructures.ModElemental_elo_bfgs.Elemental_elo_bfgs</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_sr1.Elemental_elo_sr1"><code>PartitionedStructures.ModElemental_elo_sr1.Elemental_elo_sr1</code></a></li><li><a href="#PartitionedStructures.ModElemental_em.Elemental_em"><code>PartitionedStructures.ModElemental_em.Elemental_em</code></a></li><li><a href="#PartitionedStructures.ModElemental_ev.Elemental_elt_vec"><code>PartitionedStructures.ModElemental_ev.Elemental_elt_vec</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo.Elemental_plo"><code>PartitionedStructures.ModElemental_plo.Elemental_plo</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo_bfgs.Elemental_plo_bfgs"><code>PartitionedStructures.ModElemental_plo_bfgs.Elemental_plo_bfgs</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo_sr1.Elemental_plo_sr1"><code>PartitionedStructures.ModElemental_plo_sr1.Elemental_plo_sr1</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.Elemental_pm"><code>PartitionedStructures.ModElemental_pm.Elemental_pm</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.Elemental_pv"><code>PartitionedStructures.ModElemental_pv.Elemental_pv</code></a></li><li><a href="#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractPartitionedStructure"><code>Base.:==</code></a></li><li><a href="#Base.permute!-Union{Tuple{T}, Tuple{Elemental_em{T}, Vector{Int64}}} where T"><code>Base.permute!</code></a></li><li><a href="#Base.permute!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T"><code>Base.permute!</code></a></li><li><a href="#PartitionedStructures.Instances.create_epv_eplo-Tuple{}"><code>PartitionedStructures.Instances.create_epv_eplo</code></a></li><li><a href="#PartitionedStructures.Instances.create_epv_eplo_bfgs-Tuple{}"><code>PartitionedStructures.Instances.create_epv_eplo_bfgs</code></a></li><li><a href="#PartitionedStructures.Instances.create_epv_eplo_sr1-Tuple{}"><code>PartitionedStructures.Instances.create_epv_eplo_sr1</code></a></li><li><a href="#PartitionedStructures.Instances.create_epv_epm-Tuple{}"><code>PartitionedStructures.Instances.create_epv_epm</code></a></li><li><a href="#PartitionedStructures.Instances.create_epv_epm_rand-Tuple{}"><code>PartitionedStructures.Instances.create_epv_epm_rand</code></a></li><li><a href="#PartitionedStructures.Link.eplo_lbfgs_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Elemental_pv{Y}}"><code>PartitionedStructures.Link.eplo_lbfgs_from_epv</code></a></li><li><a href="#PartitionedStructures.Link.eplo_lose_from_epv-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.Link.eplo_lose_from_epv</code></a></li><li><a href="#PartitionedStructures.Link.eplo_lsr1_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Elemental_pv{Y}}"><code>PartitionedStructures.Link.eplo_lsr1_from_epv</code></a></li><li><a href="#PartitionedStructures.Link.epm_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Elemental_pv{Y}}"><code>PartitionedStructures.Link.epm_from_epv</code></a></li><li><a href="#PartitionedStructures.Link.epv_from_eplo-Tuple{Any}"><code>PartitionedStructures.Link.epv_from_eplo</code></a></li><li><a href="#PartitionedStructures.Link.epv_from_epm-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.epv_from_epm</code></a></li><li><a href="#PartitionedStructures.Link.mul_epm_epv-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.mul_epm_epv</code></a></li><li><a href="#PartitionedStructures.Link.mul_epm_epv!-Union{Tuple{T}, Tuple{Y}, Tuple{Elemental_pv{Y}, T, Elemental_pv{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.mul_epm_epv!</code></a></li><li><a href="#PartitionedStructures.Link.mul_epm_vector-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.mul_epm_vector</code></a></li><li><a href="#PartitionedStructures.Link.mul_epm_vector!-Union{Tuple{T}, Tuple{Y}, Tuple{Vector{Y}, T, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.mul_epm_vector!</code></a></li><li><a href="#PartitionedStructures.Link.string_counters_iter-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.Link.string_counters_iter</code></a></li><li><a href="#PartitionedStructures.Link.string_counters_total-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.Link.string_counters_total</code></a></li><li><a href="#PartitionedStructures.M_abstract_element_struct.get_indices-Tuple{T} where T&lt;:Element_struct"><code>PartitionedStructures.M_abstract_element_struct.get_indices</code></a></li><li><a href="#PartitionedStructures.M_abstract_element_struct.get_nie-Tuple{T} where T&lt;:Element_struct"><code>PartitionedStructures.M_abstract_element_struct.get_nie</code></a></li><li><a href="#PartitionedStructures.M_abstract_element_struct.set_indices!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T&lt;:Element_struct"><code>PartitionedStructures.M_abstract_element_struct.set_indices!</code></a></li><li><a href="#PartitionedStructures.M_abstract_element_struct.set_nie!-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Element_struct"><code>PartitionedStructures.M_abstract_element_struct.set_nie!</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y&lt;:AbstractPartitionedStructure, Z&lt;:AbstractPartitionedStructure}"><code>PartitionedStructures.M_abstract_part_struct.check_epv_epm</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.full_check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y&lt;:AbstractPartitionedStructure, Z&lt;:AbstractPartitionedStructure}"><code>PartitionedStructures.M_abstract_part_struct.full_check_epv_epm</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.get_N-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.get_N</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.get_component_list-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.get_component_list</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T"><code>PartitionedStructures.M_abstract_part_struct.get_ee_struct</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.get_ee_struct</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T"><code>PartitionedStructures.M_abstract_part_struct.get_ee_struct</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.get_n-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.get_n</code></a></li><li><a href="#PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.initialize_component_list!</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.get_Bie-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_Bie</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.get_Bsr-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_Bsr</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.get_cem-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_cem</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.get_counter_elt_mat-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_counter_elt_mat</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.get_current_untouched-Tuple{Counter_elt_mat}"><code>PartitionedStructures.M_elt_mat.get_current_untouched</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.get_index-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_index</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.iter_info-Tuple{Counter_elt_mat}"><code>PartitionedStructures.M_elt_mat.iter_info</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.total_info-Tuple{Counter_elt_mat}"><code>PartitionedStructures.M_elt_mat.total_info</code></a></li><li><a href="#PartitionedStructures.M_elt_mat.update_counter_elt_mat!-Tuple{Counter_elt_mat, Int64}"><code>PartitionedStructures.M_elt_mat.update_counter_elt_mat!</code></a></li><li><a href="#PartitionedStructures.M_elt_vec.get_vec-Tuple{T} where T&lt;:Elt_vec"><code>PartitionedStructures.M_elt_vec.get_vec</code></a></li><li><a href="#PartitionedStructures.M_elt_vec.set_add_vec!-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T&lt;:Elt_vec, Y&lt;:Number}"><code>PartitionedStructures.M_elt_vec.set_add_vec!</code></a></li><li><a href="#PartitionedStructures.M_elt_vec.set_minus_vec!-Tuple{T} where T&lt;:Elt_vec"><code>PartitionedStructures.M_elt_vec.set_minus_vec!</code></a></li><li><a href="#PartitionedStructures.M_elt_vec.set_vec!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y&lt;:Number, T&lt;:Elt_vec{Y}}"><code>PartitionedStructures.M_elt_vec.set_vec!</code></a></li><li><a href="#PartitionedStructures.M_part_mat.get_L-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_L</code></a></li><li><a href="#PartitionedStructures.M_part_mat.get_L-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_L</code></a></li><li><a href="#PartitionedStructures.M_part_mat.get_ee_struct_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_ee_struct_Bie</code></a></li><li><a href="#PartitionedStructures.M_part_mat.get_eelo_set-Tuple{T} where T&lt;:Part_LO_mat"><code>PartitionedStructures.M_part_mat.get_eelo_set</code></a></li><li><a href="#PartitionedStructures.M_part_mat.get_eelo_set_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Part_LO_mat"><code>PartitionedStructures.M_part_mat.get_eelo_set_Bie</code></a></li><li><a href="#PartitionedStructures.M_part_mat.get_eelo_sub_set-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T&lt;:Part_LO_mat"><code>PartitionedStructures.M_part_mat.get_eelo_sub_set</code></a></li><li><a href="#PartitionedStructures.M_part_mat.get_permutation-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_permutation</code></a></li><li><a href="#PartitionedStructures.M_part_mat.get_spm-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_spm</code></a></li><li><a href="#PartitionedStructures.M_part_mat.hard_reset_L!-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.hard_reset_L!</code></a></li><li><a href="#PartitionedStructures.M_part_mat.hard_reset_spm!-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.hard_reset_spm!</code></a></li><li><a href="#PartitionedStructures.M_part_mat.reset_L!-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.M_part_mat.reset_L!</code></a></li><li><a href="#PartitionedStructures.M_part_mat.reset_spm!-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.M_part_mat.reset_spm!</code></a></li><li><a href="#PartitionedStructures.M_part_mat.set_L!-Union{Tuple{P}, Tuple{T}, Tuple{P, Int64, Int64, T}} where {T&lt;:Number, P&lt;:Part_mat{T}}"><code>PartitionedStructures.M_part_mat.set_L!</code></a></li><li><a href="#PartitionedStructures.M_part_mat.set_L_to_spm!-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.set_L_to_spm!</code></a></li><li><a href="#PartitionedStructures.M_part_mat.set_eelo_set!-Tuple{T} where T&lt;:Part_LO_mat"><code>PartitionedStructures.M_part_mat.set_eelo_set!</code></a></li><li><a href="#PartitionedStructures.M_part_mat.set_permutation!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.set_permutation!</code></a></li><li><a href="#PartitionedStructures.M_part_mat.set_spm!-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.set_spm!</code></a></li><li><a href="#PartitionedStructures.M_part_v.add_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Int64, Y}} where {Y, T&lt;:Part_v{Y}}"><code>PartitionedStructures.M_part_v.add_v!</code></a></li><li><a href="#PartitionedStructures.M_part_v.build_v-Tuple{T} where T&lt;:Part_v"><code>PartitionedStructures.M_part_v.build_v</code></a></li><li><a href="#PartitionedStructures.M_part_v.build_v!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T"><code>PartitionedStructures.M_part_v.build_v!</code></a></li><li><a href="#PartitionedStructures.M_part_v.build_v!-Tuple{T} where T&lt;:Part_v"><code>PartitionedStructures.M_part_v.build_v!</code></a></li><li><a href="#PartitionedStructures.M_part_v.get_v-Tuple{T} where T&lt;:Part_v"><code>PartitionedStructures.M_part_v.get_v</code></a></li><li><a href="#PartitionedStructures.M_part_v.reset_v!-Union{Tuple{T}, Tuple{Y}} where {Y, T&lt;:Part_v{Y}}"><code>PartitionedStructures.M_part_v.reset_v!</code></a></li><li><a href="#PartitionedStructures.M_part_v.set_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y, T&lt;:Part_v{Y}}"><code>PartitionedStructures.M_part_v.set_v!</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo-Tuple{Int64}"><code>PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo_rand-Tuple{Int64}"><code>PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo_rand</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_bfgs.init_eelo_LBFGS-Tuple{Vector{Int64}}"><code>PartitionedStructures.ModElemental_elo_bfgs.init_eelo_LBFGS</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_bfgs.reset_eelo_bfgs!-Union{Tuple{Elemental_elo_bfgs{T}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_elo_bfgs.reset_eelo_bfgs!</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo-Tuple{Int64}"><code>PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo_rand-Tuple{Int64}"><code>PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo_rand</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_sr1.init_eelo_LSR1-Tuple{Vector{Int64}}"><code>PartitionedStructures.ModElemental_elo_sr1.init_eelo_LSR1</code></a></li><li><a href="#PartitionedStructures.ModElemental_elo_sr1.reset_eelo_sr1!-Union{Tuple{Elemental_elo_sr1{T}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_elo_sr1.reset_eelo_sr1!</code></a></li><li><a href="#PartitionedStructures.ModElemental_em.create_id_eem-Tuple{Vector{Int64}}"><code>PartitionedStructures.ModElemental_em.create_id_eem</code></a></li><li><a href="#PartitionedStructures.ModElemental_em.fixed_ones_eem-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_em.fixed_ones_eem</code></a></li><li><a href="#PartitionedStructures.ModElemental_em.identity_eem-Tuple{Int64}"><code>PartitionedStructures.ModElemental_em.identity_eem</code></a></li><li><a href="#PartitionedStructures.ModElemental_em.one_size_bloc-Tuple{Int64}"><code>PartitionedStructures.ModElemental_em.one_size_bloc</code></a></li><li><a href="#PartitionedStructures.ModElemental_em.ones_eem-Tuple{Int64}"><code>PartitionedStructures.ModElemental_em.ones_eem</code></a></li><li><a href="#PartitionedStructures.ModElemental_ev.create_eev-Tuple{Vector{Int64}}"><code>PartitionedStructures.ModElemental_ev.create_eev</code></a></li><li><a href="#PartitionedStructures.ModElemental_ev.eev_from_sparse_vec-Union{Tuple{SparseArrays.SparseVector{T, Y}}, Tuple{Y}, Tuple{T}} where {T, Y}"><code>PartitionedStructures.ModElemental_ev.eev_from_sparse_vec</code></a></li><li><a href="#PartitionedStructures.ModElemental_ev.new_eev-Tuple{Int64}"><code>PartitionedStructures.ModElemental_ev.new_eev</code></a></li><li><a href="#PartitionedStructures.ModElemental_ev.ones_eev-Tuple{Int64}"><code>PartitionedStructures.ModElemental_ev.ones_eev</code></a></li><li><a href="#PartitionedStructures.ModElemental_ev.sparse_vec_from_eev-Union{Tuple{Elemental_elt_vec{T}}, Tuple{T}} where T"><code>PartitionedStructures.ModElemental_ev.sparse_vec_from_eev</code></a></li><li><a href="#PartitionedStructures.ModElemental_ev.specific_ones_eev-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_ev.specific_ones_eev</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo-Tuple{}"><code>PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo_rand-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo_rand</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo.identity_eplo_LOSE-Tuple{Vector{Vector{Int64}}}"><code>PartitionedStructures.ModElemental_plo.identity_eplo_LOSE</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo-Tuple{}"><code>PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo_rand-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo_rand</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo_bfgs.identity_eplo_LBFGS-Tuple{Vector{Vector{Int64}}}"><code>PartitionedStructures.ModElemental_plo_bfgs.identity_eplo_LBFGS</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo-Tuple{}"><code>PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo_rand-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo_rand</code></a></li><li><a href="#PartitionedStructures.ModElemental_plo_sr1.identity_eplo_LSR1-Tuple{Vector{Vector{Int64}}}"><code>PartitionedStructures.ModElemental_plo_sr1.identity_eplo_LSR1</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.correlated_var-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T"><code>PartitionedStructures.ModElemental_pm.correlated_var</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T"><code>PartitionedStructures.ModElemental_pm.get_eem_set</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T"><code>PartitionedStructures.ModElemental_pm.get_eem_set</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.get_eem_set_Bie-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T"><code>PartitionedStructures.ModElemental_pm.get_eem_set_Bie</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.get_eem_sub_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T"><code>PartitionedStructures.ModElemental_pm.get_eem_sub_set</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pm.identity_epm</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Vector{Vector{Int64}}}"><code>PartitionedStructures.ModElemental_pm.identity_epm</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.n_i_SPS-Tuple{Int64}"><code>PartitionedStructures.ModElemental_pm.n_i_SPS</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.n_i_sep-Tuple{Int64}"><code>PartitionedStructures.ModElemental_pm.n_i_sep</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.ones_epm-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pm.ones_epm</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.ones_epm_and_id-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pm.ones_epm_and_id</code></a></li><li><a href="#PartitionedStructures.ModElemental_pm.part_mat-Tuple{}"><code>PartitionedStructures.ModElemental_pm.part_mat</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.add_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_pv.add_epv!</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.create_epv-Union{Tuple{Array{SparseArrays.SparseVector{T, Y}, 1}}, Tuple{Y}, Tuple{T}} where {T, Y}"><code>PartitionedStructures.ModElemental_pv.create_epv</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.epv_from_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T"><code>PartitionedStructures.ModElemental_pv.epv_from_epv!</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.epv_from_v-Union{Tuple{T}, Tuple{Vector{T}, Elemental_pv{T}}} where T"><code>PartitionedStructures.ModElemental_pv.epv_from_v</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.epv_from_v!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.ModElemental_pv.epv_from_v!</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.get_eev_set-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T"><code>PartitionedStructures.ModElemental_pv.get_eev_set</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.get_eev_subset-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{Int64}}} where T"><code>PartitionedStructures.ModElemental_pv.get_eev_subset</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.get_eev_value-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64}} where T"><code>PartitionedStructures.ModElemental_pv.get_eev_value</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.minus_epv!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_pv.minus_epv!</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.ones_kchained_epv-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pv.ones_kchained_epv</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.part_vec-Tuple{}"><code>PartitionedStructures.ModElemental_pv.part_vec</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.prod_part_vectors-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T"><code>PartitionedStructures.ModElemental_pv.prod_part_vectors</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.rand_epv-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pv.rand_epv</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.scale_epv-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_pv.scale_epv</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.scale_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.ModElemental_pv.scale_epv!</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.set_eev!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64, Int64, T}} where T"><code>PartitionedStructures.ModElemental_pv.set_eev!</code></a></li><li><a href="#PartitionedStructures.ModElemental_pv.set_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Array{Vector{T}, 1}}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_pv.set_epv!</code></a></li><li><a href="#PartitionedStructures.PartMatInterface.update-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.PartMatInterface.update</code></a></li><li><a href="#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_bfgs{Y}, Elemental_pv{Y}, Vector{Y}}} where Y&lt;:Number"><code>PartitionedStructures.PartMatInterface.update!</code></a></li><li><a href="#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_sr1{Y}, Elemental_pv{Y}, Vector{Y}}} where Y&lt;:Number"><code>PartitionedStructures.PartMatInterface.update!</code></a></li><li><a href="#PartitionedStructures.PartMatInterface.update!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.PartMatInterface.update!</code></a></li><li><a href="#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo{Y}, Elemental_pv{Y}, Vector{Y}}} where Y&lt;:Number"><code>PartitionedStructures.PartMatInterface.update!</code></a></li><li><a href="#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update</code></a></li><li><a href="#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!</code></a></li><li><a href="#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update</code></a></li><li><a href="#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!</code></a></li><li><a href="#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update</code></a></li><li><a href="#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!</code></a></li><li><a href="#PartitionedStructures.PartitionedLOQuasiNewton.Part_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}"><code>PartitionedStructures.PartitionedLOQuasiNewton.Part_update</code></a></li><li><a href="#PartitionedStructures.PartitionedLOQuasiNewton.Part_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}"><code>PartitionedStructures.PartitionedLOQuasiNewton.Part_update!</code></a></li><li><a href="#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PBFGS_update</code></a></li><li><a href="#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!</code></a></li><li><a href="#PartitionedStructures.PartitionedQuasiNewton.PCS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PCS_update</code></a></li><li><a href="#PartitionedStructures.PartitionedQuasiNewton.PCS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PCS_update!</code></a></li><li><a href="#PartitionedStructures.PartitionedQuasiNewton.PSE_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PSE_update</code></a></li><li><a href="#PartitionedStructures.PartitionedQuasiNewton.PSE_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PSE_update!</code></a></li><li><a href="#PartitionedStructures.PartitionedQuasiNewton.PSR1_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PSR1_update</code></a></li><li><a href="#PartitionedStructures.PartitionedQuasiNewton.PSR1_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PSR1_update!</code></a></li><li><a href="#PartitionedStructures.Utils.BFGS-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.BFGS</code></a></li><li><a href="#PartitionedStructures.Utils.BFGS!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.BFGS!</code></a></li><li><a href="#PartitionedStructures.Utils.SE-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.SE</code></a></li><li><a href="#PartitionedStructures.Utils.SE!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.SE!</code></a></li><li><a href="#PartitionedStructures.Utils.SR1-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.SR1</code></a></li><li><a href="#PartitionedStructures.Utils.SR1!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.SR1!</code></a></li><li><a href="#PartitionedStructures.Utils.max_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.Utils.max_indices</code></a></li><li><a href="#PartitionedStructures.Utils.min_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.Utils.min_indices</code></a></li><li><a href="#PartitionedStructures.Utils.my_and"><code>PartitionedStructures.Utils.my_and</code></a></li></ul><p>​</p><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.AbstractPartitionedStructure" href="#PartitionedStructures.M_abstract_part_struct.AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.AbstractPartitionedStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of every partitioned-structure, ex: <code>Elemental_pv</code>, <code>Elemental_pm</code>, <code>Elemental_plo_bfgs</code>, <code>Internal_pv</code>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_ps_struct.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractPartitionedStructure" href="#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractPartitionedStructure"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(==)(ps1::T, ps2::T) where T &lt;: AbstractPartitionedStructure</code></pre><p>Return true if both partitioned-structures are composed of the same amont of element-structures, and have the same size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_ps_struct.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y&lt;:AbstractPartitionedStructure, Z&lt;:AbstractPartitionedStructure}" href="#PartitionedStructures.M_abstract_part_struct.check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y&lt;:AbstractPartitionedStructure, Z&lt;:AbstractPartitionedStructure}"><code>PartitionedStructures.M_abstract_part_struct.check_epv_epm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bool = check_epv_epm(epm::Y, epv::Z) where {Y &lt;: AbstractPartitionedStructure, Z &lt;: AbstractPartitionedStructure}</code></pre><p>Similar to <code>==</code>, but it can compare different partitioned-structures, example: an <code>Elemental_pv</code> and an <code>Elemental_pm</code>. <code>check_epv_epm</code> is a superficial test, see <code>full_check_epv_epm(epm, epv)</code> for a complete check of the partitioned-structure (i.e. if each element depends of the same variable subset).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_ps_struct.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.full_check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y&lt;:AbstractPartitionedStructure, Z&lt;:AbstractPartitionedStructure}" href="#PartitionedStructures.M_abstract_part_struct.full_check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y&lt;:AbstractPartitionedStructure, Z&lt;:AbstractPartitionedStructure}"><code>PartitionedStructures.M_abstract_part_struct.full_check_epv_epm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">full_check_epv_epm(ep1::Y, ep2::Z) where {Y &lt;: AbstractPartitionedStructure, Z &lt;: AbstractPartitionedStructure}</code></pre><p>Check if each element-structure of both partitioned-structures depend of the same subset of variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_ps_struct.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.get_N-Tuple{T} where T&lt;:AbstractPartitionedStructure" href="#PartitionedStructures.M_abstract_part_struct.get_N-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.get_N</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_N(ps::T) where T &lt;: AbstractPartitionedStructure</code></pre><p>Return the number of element composing the partitioned-structure <code>ps</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_ps_struct.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.get_component_list-Tuple{T} where T&lt;:AbstractPartitionedStructure" href="#PartitionedStructures.M_abstract_part_struct.get_component_list-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.get_component_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">list = get_component_list(ps::T) where T &lt;: AbstractPartitionedStructure
ith_component = get_component_list(ps::T, i::Int) where T &lt;: AbstractPartitionedStructure</code></pre><p>Return either the list of every element-structure composing the partitioned-structure <code>ps</code> or the <code>i</code>-th element-structure of <code>ps</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_ps_struct.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.get_ee_struct-Tuple{T} where T&lt;:AbstractPartitionedStructure" href="#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.get_ee_struct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ee_vector = get_ee_struct(eps::AbstractPartitionedStructure{T}) where T
ee = get_ee_struct(eps::AbstractPartitionedStructure{T}, i::Int) where T</code></pre><p>Return a vector of every elemental elements fom elemental partitioned-structure <code>eps</code> or only its <code>i</code>-th elemental element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_ps_struct.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.get_n-Tuple{T} where T&lt;:AbstractPartitionedStructure" href="#PartitionedStructures.M_abstract_part_struct.get_n-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.get_n</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_n(ps::T) where T &lt;: AbstractPartitionedStructure</code></pre><p>Return the total size of the partitioned-structure <code>ps</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_ps_struct.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{T} where T&lt;:AbstractPartitionedStructure" href="#PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{T} where T&lt;:AbstractPartitionedStructure"><code>PartitionedStructures.M_abstract_part_struct.initialize_component_list!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initialize_component_list!(ps::T) where T &lt;: AbstractPartitionedStructure)</code></pre><p>Build for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_ps_struct.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_element_struct.Element_struct" href="#PartitionedStructures.M_abstract_element_struct.Element_struct"><code>PartitionedStructures.M_abstract_element_struct.Element_struct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of every element-structure, ex : <code>Elemental_elt_vec</code>, <code>Elemental_em</code>, <code>Elemental_elo_bfgs</code>, <code>Internal_elt_vec</code>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_elt_struct.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_element_struct.get_indices-Tuple{T} where T&lt;:Element_struct" href="#PartitionedStructures.M_abstract_element_struct.get_indices-Tuple{T} where T&lt;:Element_struct"><code>PartitionedStructures.M_abstract_element_struct.get_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">indices = get_indices(elt::T) where T &lt;: Element_struct
indice = get_indices(elt::T, i::Int) where T &lt;: Element_struct</code></pre><p>Every element-structure is based on a variable subset of a partitioned-structure. <code>get_indices(elt)</code> retrieves the variable set of an element <code>elt</code>. <code>get_indices(elt, i)</code> retrieves the <code>i</code>-th variable associated to <code>elt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_elt_struct.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_element_struct.get_nie-Tuple{T} where T&lt;:Element_struct" href="#PartitionedStructures.M_abstract_element_struct.get_nie-Tuple{T} where T&lt;:Element_struct"><code>PartitionedStructures.M_abstract_element_struct.get_nie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nie = get_nie(elt::T) where T &lt;: Element_struct</code></pre><p>Return the elemental size of the element <code>elt.nie</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_elt_struct.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_element_struct.set_indices!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T&lt;:Element_struct" href="#PartitionedStructures.M_abstract_element_struct.set_indices!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T&lt;:Element_struct"><code>PartitionedStructures.M_abstract_element_struct.set_indices!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_indices!(elt::T, indices::Vector{Int}) where T &lt;: Element_struct</code></pre><p>Set the indices of the element <code>elt.indices</code> to <code>indices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_elt_struct.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_element_struct.set_nie!-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Element_struct" href="#PartitionedStructures.M_abstract_element_struct.set_nie!-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Element_struct"><code>PartitionedStructures.M_abstract_element_struct.set_nie!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_nie!(elt::T, nie::Int) where T &lt;: Element_struct</code></pre><p>Set the element size of <code>elt</code> to <code>nie</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/ab_elt_struct.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_vec.Elt_vec" href="#PartitionedStructures.M_elt_vec.Elt_vec"><code>PartitionedStructures.M_elt_vec.Elt_vec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of element-vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elt_vec.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_vec.get_vec-Tuple{T} where T&lt;:Elt_vec" href="#PartitionedStructures.M_elt_vec.get_vec-Tuple{T} where T&lt;:Elt_vec"><code>PartitionedStructures.M_elt_vec.get_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vec = get_vec(ev::T) where T &lt;: Elt_vec
vec_i = get_vec(ev::T, i::Int) where T &lt;: Elt_vec</code></pre><p>Return the vector <code>ev.vec</code> or <code>ev.vec[i]</code> from an element-vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elt_vec.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_vec.set_add_vec!-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T&lt;:Elt_vec, Y&lt;:Number}" href="#PartitionedStructures.M_elt_vec.set_add_vec!-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T&lt;:Elt_vec, Y&lt;:Number}"><code>PartitionedStructures.M_elt_vec.set_add_vec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_add_vec!(ev::T, vec::Vector{Y}) where {T &lt;: Elt_vec, Y &lt;: Number}</code></pre><p>Add <code>vec</code> to the vector <code>ev.vec</code> of the element-vector <code>ev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elt_vec.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_vec.set_minus_vec!-Tuple{T} where T&lt;:Elt_vec" href="#PartitionedStructures.M_elt_vec.set_minus_vec!-Tuple{T} where T&lt;:Elt_vec"><code>PartitionedStructures.M_elt_vec.set_minus_vec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_minus_vec!(ev::T) where T &lt;: Elt_vec</code></pre><p>Multiply by <code>-1</code> the vector inside the element-vector <code>ev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elt_vec.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_vec.set_vec!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y&lt;:Number, T&lt;:Elt_vec{Y}}" href="#PartitionedStructures.M_elt_vec.set_vec!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y&lt;:Number, T&lt;:Elt_vec{Y}}"><code>PartitionedStructures.M_elt_vec.set_vec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_vec!(ev::T, vec::Vector{Y}) where {Y &lt;: Number, T &lt;: Elt_vec{Y}}
set_vec!(ev::T, i::Int, val::Y) where {Y &lt;: Number, T &lt;: Elt_vec{Y}}</code></pre><p>Set <code>ev.vec</code> to <code>vec</code> or <code>ev.vec[i] = val</code> of the element-vector <code>ev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elt_vec.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_ev.Elemental_elt_vec" href="#PartitionedStructures.ModElemental_ev.Elemental_elt_vec"><code>PartitionedStructures.ModElemental_ev.Elemental_elt_vec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Elemental_elt_vec{T} &lt;: Elt_vec{T}</code></pre><p>Represent an elemental element-vector:</p><ul><li><code>indices</code> retains the indices of the elemental variables;</li><li><code>nie</code> is the elemental size (<code>=length(indices)</code>);</li><li><code>vec</code> is the current value of the elemental element vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_ev.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_ev.create_eev-Tuple{Vector{Int64}}" href="#PartitionedStructures.ModElemental_ev.create_eev-Tuple{Vector{Int64}}"><code>PartitionedStructures.ModElemental_ev.create_eev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eev = create_eev(elt_var::Vector{Int}; type=Float64)</code></pre><p>Create a random elemental element-vector <code>eev</code> from the elemental variables <code>elt_var</code>. <code>eev</code> is set to random values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_ev.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_ev.eev_from_sparse_vec-Union{Tuple{SparseArrays.SparseVector{T, Y}}, Tuple{Y}, Tuple{T}} where {T, Y}" href="#PartitionedStructures.ModElemental_ev.eev_from_sparse_vec-Union{Tuple{SparseArrays.SparseVector{T, Y}}, Tuple{Y}, Tuple{T}} where {T, Y}"><code>PartitionedStructures.ModElemental_ev.eev_from_sparse_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = eev_from_sparse_vec(sparsevec::SparseVector{T,Y})</code></pre><p>Define an elemental element-vector from a <code>sparsevec::SparseVector</code>. The indices and the values are define with <code>findnz(sparse_vec)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_ev.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_ev.new_eev-Tuple{Int64}" href="#PartitionedStructures.ModElemental_ev.new_eev-Tuple{Int64}"><code>PartitionedStructures.ModElemental_ev.new_eev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = new_eev(nᵢ::Int; T=Float64, n=nᵢ^2)</code></pre><p>Create an elemental element-vector of size <code>nie</code>, with random values and whose the indices are within the range <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_ev.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_ev.ones_eev-Tuple{Int64}" href="#PartitionedStructures.ModElemental_ev.ones_eev-Tuple{Int64}"><code>PartitionedStructures.ModElemental_ev.ones_eev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = ones_eev(nᵢ::Int; T=Float64, n=nᵢ^2)</code></pre><p>Create an elemental element-vector of size <code>nie</code> with values set to <code>1</code> and whose the indices are within the range <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_ev.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_ev.sparse_vec_from_eev-Union{Tuple{Elemental_elt_vec{T}}, Tuple{T}} where T" href="#PartitionedStructures.ModElemental_ev.sparse_vec_from_eev-Union{Tuple{Elemental_elt_vec{T}}, Tuple{T}} where T"><code>PartitionedStructures.ModElemental_ev.sparse_vec_from_eev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sp_vec = sparse_vec_from_eev(eev::Elemental_elt_vec{T}; n::Int=maximum(get_indices(eev))) where T</code></pre><p>Create a <code>SparseVector</code> from the element element-vector <code>eev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_ev.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_ev.specific_ones_eev-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_ev.specific_ones_eev-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_ev.specific_ones_eev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = specific_ones_eev(nie::Int, index::Int; T=Float64, mul::Float64=1.)</code></pre><p>Create an elemental element-vector of size <code>nie</code>, of random values multiplied by <code>mul</code> and whose indices are in range <code>index:index+nie</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_ev.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.Elemental_pv" href="#PartitionedStructures.ModElemental_pv.Elemental_pv"><code>PartitionedStructures.ModElemental_pv.Elemental_pv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Elemental_pv{T} &lt;: Part_v{T}</code></pre><p>Represent an elemental partitioned-vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_v.build_v!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T" href="#PartitionedStructures.M_part_v.build_v!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T"><code>PartitionedStructures.M_part_v.build_v!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_v!(epv::Elemental_pv{T}) where T</code></pre><p>Build the vector <code>epv.v</code> by accumulating the contribution of each elemental element-vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.add_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T&lt;:Number" href="#PartitionedStructures.ModElemental_pv.add_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_pv.add_epv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_epv!(epv1::Elemental_pv{T}, epv2::Elemental_pv{T})</code></pre><p>Build in place of <code>epv2</code> the elementwise addition of <code>epv1</code> and <code>epv2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.create_epv-Union{Tuple{Array{SparseArrays.SparseVector{T, Y}, 1}}, Tuple{Y}, Tuple{T}} where {T, Y}" href="#PartitionedStructures.ModElemental_pv.create_epv-Union{Tuple{Array{SparseArrays.SparseVector{T, Y}, 1}}, Tuple{Y}, Tuple{T}} where {T, Y}"><code>PartitionedStructures.ModElemental_pv.create_epv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv = create_epv(sp_set::Vector{SparseVector{T,Y}}; kwargs...) where {T,Y}
epv = create_epv(eev_set::Vector{Elemental_elt_vec{T}}; n=max_indices(eev_set)) where T</code></pre><p>Create an elemental partitioned-vector from a vector <code>eev_set</code> of: <code>SparseVector</code>, elemental element-vector or a vector of indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.epv_from_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T" href="#PartitionedStructures.ModElemental_pv.epv_from_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T"><code>PartitionedStructures.ModElemental_pv.epv_from_epv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv_from_epv!(epv1::Elemental_pv{T}, epv2::Elemental_pv{T}) where T</code></pre><p>Set the elemental partitioned-vector <code>epv1</code> to <code>epv2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L324-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.epv_from_v!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.ModElemental_pv.epv_from_v!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.ModElemental_pv.epv_from_v!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv_from_v!(epv_x::Elemental_pv{T}, x::Vector{T}) where T</code></pre><p>Set the values of the element partitioned-vector <code>epv</code> to <code>x</code>. Usefull to define Uᵢ x, ∀ i ∈ {1,...,N}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.epv_from_v-Union{Tuple{T}, Tuple{Vector{T}, Elemental_pv{T}}} where T" href="#PartitionedStructures.ModElemental_pv.epv_from_v-Union{Tuple{T}, Tuple{Vector{T}, Elemental_pv{T}}} where T"><code>PartitionedStructures.ModElemental_pv.epv_from_v</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv = epv_from_v(x::Vector{T}, shape_epv::Elemental_pv{T}) where T</code></pre><p>Define a new elemental partitioned-vector from <code>x</code> that have the same structure than <code>shape_epv</code>. The value of each elemental element-vector comes from the corresponding indices of <code>x</code>. Usefull to define Uᵢ x, ∀ x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L294-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.get_eev_set-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T" href="#PartitionedStructures.ModElemental_pv.get_eev_set-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T"><code>PartitionedStructures.ModElemental_pv.get_eev_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eev_set = get_eev_set(epv::Elemental_pv{T}) where T</code></pre><p>Return either the vector of every elemental element-vector of the elemental partitioned-vector <code>epv</code> or the <code>i</code>-th elemental element-vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.get_eev_subset-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{Int64}}} where T" href="#PartitionedStructures.ModElemental_pv.get_eev_subset-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{Int64}}} where T"><code>PartitionedStructures.ModElemental_pv.get_eev_subset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eev_subset = get_eev_subset(epv::Elemental_pv{T}, indices::Vector{Int}) where T</code></pre><p>Return a subset of the elemental element vector composing the elemental partitioned-vector <code>epv</code>. <code>indices</code> selects the differents elemental element-vector needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.get_eev_value-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64}} where T" href="#PartitionedStructures.ModElemental_pv.get_eev_value-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64}} where T"><code>PartitionedStructures.ModElemental_pv.get_eev_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eev_i_value = get_eev_value(epv::Elemental_pv{T}, i::Int) where T
eev_ij_value = get_eev_value(epv::Elemental_pv{T}, i::Int, j::Int) where T</code></pre><p>Return either the value of the <code>i</code>-th elemental element-vector of the elemental partitioned-vector <code>epv</code> or only the <code>j</code>-th component of the <code>i</code>-th elemental element-vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.minus_epv!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T&lt;:Number" href="#PartitionedStructures.ModElemental_pv.minus_epv!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_pv.minus_epv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minus_epv!(epv::Elemental_pv{T}) where T &lt;: Number</code></pre><p>Build in place the <code>-epv</code>, by inversing the value of each elemental element-vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.ones_kchained_epv-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_pv.ones_kchained_epv-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pv.ones_kchained_epv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv = ones_kchained_epv(N::Int, k::Int; T=Float64)</code></pre><p>Construct an elemental partitioned-vector of <code>N</code> elemental element-vector of size <code>k</code> which overlaps the next element-vector on <code>k-1</code> variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.part_vec-Tuple{}" href="#PartitionedStructures.ModElemental_pv.part_vec-Tuple{}"><code>PartitionedStructures.ModElemental_pv.part_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv = part_vec(;n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1, mul::Float64=1.)</code></pre><p>Define an elemental partitioned-vector formed by <code>N</code> (deduced from <code>n</code> and <code>nie</code>) elemental element-vectors of size <code>nie</code>. Each elemental element-vector overlaps the previous and the next element by <code>overlapping</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L268-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.prod_part_vectors-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T" href="#PartitionedStructures.ModElemental_pv.prod_part_vectors-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T"><code>PartitionedStructures.ModElemental_pv.prod_part_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(acc, res) = prod_part_vectors(epv1::Elemental_pv{T}, epv2::Elemental_pv{T}) where T</code></pre><p>Perform an elementwise scalar product between the two elemental partitioned-vector <code>epv1</code> and <code>epv2</code>. <code>acc</code> accumulates the sum of the element-vectors scalar product. <code>res</code> contrains the details of every element-vector scalar product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L351-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.rand_epv-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_pv.rand_epv-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pv.rand_epv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv = rand_epv(N::Int,n::Int; nie=3, T=Float64)</code></pre><p>Define an elemental partitioned-vector of <code>N</code> elemental element-vector of size <code>nᵢ</code> whose values are randoms and the indices are in the range <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.scale_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.ModElemental_pv.scale_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.ModElemental_pv.scale_epv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">v = scale_epv!(epv::Elemental_pv{T}, scalars::Vector{T}) where T</code></pre><p>Return a vector <code>v</code> from <code>epv</code> where the contribution of each element-vector is multiply by the corresponding value from <code>scalars</code>. <code>v</code> is extract from <code>epv.v</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L223-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.scale_epv-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T&lt;:Number" href="#PartitionedStructures.ModElemental_pv.scale_epv-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_pv.scale_epv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">v = scale_epv(epv::Elemental_pv{T}, scalars::Vector{T}) where T &lt;: Number</code></pre><p>Return a vector <code>v</code> from <code>epv</code> where the contribution of each element-vector is multiply by the corresponding value from <code>scalars</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.set_eev!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64, Int64, T}} where T" href="#PartitionedStructures.ModElemental_pv.set_eev!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64, Int64, T}} where T"><code>PartitionedStructures.ModElemental_pv.set_eev!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_eev!(epv::Elemental_pv{T}, i::Int, vec::Vector{T}) where T
set_eev!(epv::Elemental_pv{T}, i::Int, j::Int, val:: T) where T</code></pre><p>Set either the <code>i</code>-th elemental element-vector <code>epv</code> to <code>vec</code> or its <code>j</code>-th component to <code>val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pv.set_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Array{Vector{T}, 1}}} where T&lt;:Number" href="#PartitionedStructures.ModElemental_pv.set_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Array{Vector{T}, 1}}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_pv.set_epv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_epv!(epv::Elemental_pv{T}, vec_value_eev::Vector{Vector{T}}) where T &lt;: Number</code></pre><p>Set the values of the elemental element-vectors of <code>epv</code> with the components of <code>vec_value_eev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/elemental_pv.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.Counter_elt_mat" href="#PartitionedStructures.M_elt_mat.Counter_elt_mat"><code>PartitionedStructures.M_elt_mat.Counter_elt_mat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Counter_elt_mat</code></pre><p>Count for an element-matrix the updates performed on it, from its allocation. <code>total_update + total_reset + total_untouched == attempt</code>, .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.DenseEltMat" href="#PartitionedStructures.M_elt_mat.DenseEltMat"><code>PartitionedStructures.M_elt_mat.DenseEltMat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of every dense element-matrix, ex: <code>Elemental_em</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.Elt_mat" href="#PartitionedStructures.M_elt_mat.Elt_mat"><code>PartitionedStructures.M_elt_mat.Elt_mat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of every element-matrix, ex: <code>Elemental_em</code>, <code>Elemental_elo_sr1</code>, <code>Elemental_elo_bfgs</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.LOEltMat" href="#PartitionedStructures.M_elt_mat.LOEltMat"><code>PartitionedStructures.M_elt_mat.LOEltMat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of every element linear-operator, ex: <code>Elemental_elo_sr1</code>, <code>Elemental_elo_bfgs</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.get_Bie-Tuple{T} where T&lt;:Elt_mat" href="#PartitionedStructures.M_elt_mat.get_Bie-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_Bie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Bie(elt_mat::T) where T &lt;: Elt_mat</code></pre><p>Return the element-matrix <code>elt_mat.Bie</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.get_Bsr-Tuple{T} where T&lt;:Elt_mat" href="#PartitionedStructures.M_elt_mat.get_Bsr-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_Bsr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Bsr(elt_mat::T) where T &lt;: Elt_mat</code></pre><p>Return the temporary vector <code>elt_mat._Bsr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.get_cem-Tuple{T} where T&lt;:Elt_mat" href="#PartitionedStructures.M_elt_mat.get_cem-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_cem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cem = get_cem(elt_mat::T) where T &lt;: Elt_mat</code></pre><p>Return the <code>Counter_elt_mat</code> of the elemental element-matrix <code>elt_mat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.get_counter_elt_mat-Tuple{T} where T&lt;:Elt_mat" href="#PartitionedStructures.M_elt_mat.get_counter_elt_mat-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_counter_elt_mat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cem = get_counter_elt_mat(elt_mat::T) where T &lt;: Elt_mat</code></pre><p>Return the <code>Counter_elt_mat</code> of the elemental element-matrix <code>elt_mat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.get_current_untouched-Tuple{Counter_elt_mat}" href="#PartitionedStructures.M_elt_mat.get_current_untouched-Tuple{Counter_elt_mat}"><code>PartitionedStructures.M_elt_mat.get_current_untouched</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index = get_current_untouched(cem::Counter_elt_mat)</code></pre><p>Return index: the number of the last partitioned-updates that did not update the element-matrix <code>elt_mat</code>. If the last partitioned-update updates <code>elt_mat</code> then <code>index</code> will be equal to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.get_index-Tuple{T} where T&lt;:Elt_mat" href="#PartitionedStructures.M_elt_mat.get_index-Tuple{T} where T&lt;:Elt_mat"><code>PartitionedStructures.M_elt_mat.get_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index = get_index(elt_mat::T) where T &lt;: Elt_mat</code></pre><p>Return index: the number of the last partitioned-updates that did not update the element-matrix <code>elt_mat</code>. If the last partitioned-update updates <code>elt_mat</code> then <code>index</code> will be equal to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.iter_info-Tuple{Counter_elt_mat}" href="#PartitionedStructures.M_elt_mat.iter_info-Tuple{Counter_elt_mat}"><code>PartitionedStructures.M_elt_mat.iter_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(current_update, current_untouched, current_reset) = iter_info(cem::Counter_elt_mat)</code></pre><p>Return the information about the last partitioned quasi-Newton update applied onto the element counter <code>cem</code> (associated to an element-matrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.total_info-Tuple{Counter_elt_mat}" href="#PartitionedStructures.M_elt_mat.total_info-Tuple{Counter_elt_mat}"><code>PartitionedStructures.M_elt_mat.total_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(total_update, total_untouched, current_reset) = iter_info(cem::Counter_elt_mat)</code></pre><p>Return the informations about all the quasi-Newton updates applied onto the element associated to the counter <code>cem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_elt_mat.update_counter_elt_mat!-Tuple{Counter_elt_mat, Int64}" href="#PartitionedStructures.M_elt_mat.update_counter_elt_mat!-Tuple{Counter_elt_mat, Int64}"><code>PartitionedStructures.M_elt_mat.update_counter_elt_mat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_counter_elt_mat!(cem::Counter_elt_mat, qn::Int)</code></pre><p>Update the <code>cem</code> counter given the index <code>qn</code> from the quasi-Newton update BFGS!, SR1!, SE!.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elt_mat.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.Part_LO_mat" href="#PartitionedStructures.M_part_mat.Part_LO_mat"><code>PartitionedStructures.M_part_mat.Part_LO_mat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of every partitioned limited-memory operator, ex: <code>Elemental_plo_bfgs</code>, <code>Elemental_plo_sr1</code>, <code>Elemental_plo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.Part_mat" href="#PartitionedStructures.M_part_mat.Part_mat"><code>PartitionedStructures.M_part_mat.Part_mat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of every partitioned-matrix, ex: <code>Elemental_pm</code>, <code>Elemental_plo_bfgs</code>, <code>Elemental_plo_sr1</code>, <code>Elemental_plo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.get_L-Tuple{T} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.get_L-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_L</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">L = get_L(pm::T) where T &lt;: Part_mat</code></pre><p>Return the sparse matrix <code>pm.L</code>, who aims to store a Cholesky factor. By default <code>pm.L</code> is not instantiate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.get_L-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.get_L-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_L</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">L_ij = get_L(pm::T, i::Int, j::Int) where T &lt;: Part_mat</code></pre><p>Return the value <code>pm.L[i,j]</code>, from the sparse matrix <code>pm.L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.get_ee_struct_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.get_ee_struct_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_ee_struct_Bie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_ee_struct_Bie(pm::T, i::Int) where T &lt;: Part_mat</code></pre><p>Return the <code>i</code>-th elemental element-matrix of the partitioned-matrix <code>pm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.get_eelo_set-Tuple{T} where T&lt;:Part_LO_mat" href="#PartitionedStructures.M_part_mat.get_eelo_set-Tuple{T} where T&lt;:Part_LO_mat"><code>PartitionedStructures.M_part_mat.get_eelo_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eelo_set = get_eelo_set(plm::T) where T &lt;: Part_LO_mat
eelo = get_eelo_set(plm::T, i::Int) where T &lt;: Part_LO_mat</code></pre><p>Return either the vector of every elemental element linear-operator <code>plm.eelo_set</code> or the <code>i</code>-th elemental element linear-operator <code>plm.eelo_set[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L136-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.get_eelo_set_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Part_LO_mat" href="#PartitionedStructures.M_part_mat.get_eelo_set_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Part_LO_mat"><code>PartitionedStructures.M_part_mat.get_eelo_set_Bie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Bie = get_eelo_set_Bie(plm::T, i::Int) where T &lt;: Part_LO_mat</code></pre><p>Return the linear-operator of the <code>i</code>-th elemental element linear-operator of <code>plm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.get_eelo_sub_set-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T&lt;:Part_LO_mat" href="#PartitionedStructures.M_part_mat.get_eelo_sub_set-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T&lt;:Part_LO_mat"><code>PartitionedStructures.M_part_mat.get_eelo_sub_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eelo_subset = get_eelo_sub_set(plm::T, indices::Vector{Int}) where T &lt;: Part_LO_mat</code></pre><p>Return a subset of the elemental element linear-operators composing the elemental partitioned limited-memory operator <code>plm</code>. <code>indices</code> selects the differents elemental element linear-operators needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.get_permutation-Tuple{T} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.get_permutation-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_permutation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perm = get_permutation(pm::T) where T &lt;: Part_mat</code></pre><p>Get the current permutation of the partitioned-matrix <code>pm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.get_spm-Tuple{T} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.get_spm-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.get_spm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spm = get_spm(pm::T) where T &lt;: Part_mat
spm_ij = get_spm(pm::T, i::Int, j::Int) where T &lt;: Part_mat</code></pre><p>Get either the sparse matrix associated to the partitioned-matrix <code>pm</code> or <code>pm[i,j]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.hard_reset_L!-Tuple{T} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.hard_reset_L!-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.hard_reset_L!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hard_reset_L!(pm::T) where T &lt;: Part_mat</code></pre><p>Reset the sparse matrix <code>pm.L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.hard_reset_spm!-Tuple{T} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.hard_reset_spm!-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.hard_reset_spm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hard_reset_spm!(pm::T) where T &lt;: Part_mat</code></pre><p>Reset the sparse matrix <code>pm.spm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.reset_L!-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}" href="#PartitionedStructures.M_part_mat.reset_L!-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.M_part_mat.reset_L!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_L!(pm)</code></pre><p>Set the elements of sparse matrix <code>pm.L</code> to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.reset_spm!-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}" href="#PartitionedStructures.M_part_mat.reset_spm!-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.M_part_mat.reset_spm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_spm!(pm::T) where {Y &lt;: Number, T &lt;: Part_mat{Y}}</code></pre><p>Set the elements of sparse matrix <code>pm.spm</code> to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.set_L!-Union{Tuple{P}, Tuple{T}, Tuple{P, Int64, Int64, T}} where {T&lt;:Number, P&lt;:Part_mat{T}}" href="#PartitionedStructures.M_part_mat.set_L!-Union{Tuple{P}, Tuple{T}, Tuple{P, Int64, Int64, T}} where {T&lt;:Number, P&lt;:Part_mat{T}}"><code>PartitionedStructures.M_part_mat.set_L!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_L!(pm::P, i::Int, j::Int, value::T) where {T &lt;: Number, P &lt;: Part_mat{T}}</code></pre><p>Set the value of <code>pm.L[i,j] = value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.set_L_to_spm!-Tuple{T} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.set_L_to_spm!-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.set_L_to_spm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_L_to_spm!(pm::T) where T &lt;: Part_mat</code></pre><p>Set the sparse matrix <code>plm.L</code> to the sparse matrix <code>plm.spm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.set_eelo_set!-Tuple{T} where T&lt;:Part_LO_mat" href="#PartitionedStructures.M_part_mat.set_eelo_set!-Tuple{T} where T&lt;:Part_LO_mat"><code>PartitionedStructures.M_part_mat.set_eelo_set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_eelo_set!(eplo::P, i::Int, eelo::Y) where {T, P &lt;: Part_LO_mat{T}, Y &lt;: LOEltMat{T}}</code></pre><p>Set the <code>i</code>-th elemental element linear-operator <code>eplo.eelo</code> to <code>eelo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.set_permutation!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.set_permutation!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.set_permutation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_permutation!(pm::T, perm::Vector{Int}) where T &lt;: Part_mat</code></pre><p>Set the permutation of the partitioned-matrix <code>pm</code> to <code>perm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_mat.set_spm!-Tuple{T} where T&lt;:Part_mat" href="#PartitionedStructures.M_part_mat.set_spm!-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.M_part_mat.set_spm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_spm!(pm::P) where {T &lt;: Number, P &lt;: Part_mat{T}}</code></pre><p>Build the sparse matrix of the partitioned-matrix <code>pm</code> in <code>pm.spm</code> by gathering the contribution of every element-matrix. The sparse matrix is built with respect to the indices of each elemental element linear-operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/part_mat.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_v.Part_v" href="#PartitionedStructures.M_part_v.Part_v"><code>PartitionedStructures.M_part_v.Part_v</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of every partitioned-vectors, ex : Elemental<em>elt</em>vec, Internal<em>elt</em>vec.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/part_v.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_v.add_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Int64, Y}} where {Y, T&lt;:Part_v{Y}}" href="#PartitionedStructures.M_part_v.add_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Int64, Y}} where {Y, T&lt;:Part_v{Y}}"><code>PartitionedStructures.M_part_v.add_v!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_v!(pv::T, i::Int, value::Y) where {Y, T &lt;: Part_v{Y}}
add_v!(pv::T, indices::Vector{Int}, values::Vector{Y}) where {Y, T &lt;: Part_v{Y}}</code></pre><p>Add <code>value</code> (resp <code>values</code>) to the vector of the partitioned-vector <code>pv.v</code> at the indice <code>i</code> (resp <code>indices</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/part_v.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_v.build_v!-Tuple{T} where T&lt;:Part_v" href="#PartitionedStructures.M_part_v.build_v!-Tuple{T} where T&lt;:Part_v"><code>PartitionedStructures.M_part_v.build_v!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_v!(pv::T) where T &lt;: Part_v</code></pre><p>Accumulate in <code>pv.v</code> the contributions of every element-vector of the partitioned-vector <code>pv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/part_v.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_v.build_v-Tuple{T} where T&lt;:Part_v" href="#PartitionedStructures.M_part_v.build_v-Tuple{T} where T&lt;:Part_v"><code>PartitionedStructures.M_part_v.build_v</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vec = build_v(pv::T) where T &lt;: Part_v</code></pre><p>Build the vector <code>v = pv.v</code> by accumulating inside <code>pv.v</code> the contributions of every element-vector of the partitioned-vector <code>pv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/part_v.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_v.get_v-Tuple{T} where T&lt;:Part_v" href="#PartitionedStructures.M_part_v.get_v-Tuple{T} where T&lt;:Part_v"><code>PartitionedStructures.M_part_v.get_v</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">v = get_v(pv::T) where T &lt;: Part_v</code></pre><p>Return the vector <code>pv.v</code> of the partitioned-vector <code>pv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/part_v.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_v.reset_v!-Union{Tuple{T}, Tuple{Y}} where {Y, T&lt;:Part_v{Y}}" href="#PartitionedStructures.M_part_v.reset_v!-Union{Tuple{T}, Tuple{Y}} where {Y, T&lt;:Part_v{Y}}"><code>PartitionedStructures.M_part_v.reset_v!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_v!(pv::T) where {Y, T &lt;: Part_v{Y}}</code></pre><p>Reset the vector embedded in the partitioned-vector <code>pv</code>, i.e. <code>pv.v .= (Y)(0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/part_v.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_part_v.set_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y, T&lt;:Part_v{Y}}" href="#PartitionedStructures.M_part_v.set_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y, T&lt;:Part_v{Y}}"><code>PartitionedStructures.M_part_v.set_v!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_v!(pv::T, v::Vector{Y}) where {Y, T &lt;: Part_v{Y}}
set_v!(pv::T, i::Int, value::Y) where {Y, T &lt;: Part_v{Y}}</code></pre><p>Set the components of the vector <code>pv.v</code> (resp. <code>pv.v[i]</code>) from the partitioned-vector <code>pv</code> to the vector <code>v</code> (resp. <code>value</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_vec/part_v.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.Elemental_pm" href="#PartitionedStructures.ModElemental_pm.Elemental_pm"><code>PartitionedStructures.ModElemental_pm.Elemental_pm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Elemental_pm{T} &lt;: Part_mat{T}</code></pre><p>Represent an elemental partitioned quasi-Newton linear-operator. Each element is an elemental element-matrix which may apply a BFGS or a SR1 update. <code>N</code> is the number of elements. <code>n</code> is the size of the elemental partitioned limited-memory operator. <code>eelo_set</code> is the set of elemental element linear-operators. <code>spm</code> and <code>L</code> are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of <code>spm</code>. <code>component_list</code> summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by <code>i</code>. <code>permutation</code> is the current permutation of the elemental partitioned limited-memory operator (<code>[1:n;]</code> initially).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L19-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.permute!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T" href="#Base.permute!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T"><code>Base.permute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permute!(epm::Elemental_pm{T}, p::Vector{Int}) where T</code></pre><p>Apply the permutation <code>p</code> to the elemental partitionned matrix <code>epm</code>. The permutation is applied to every elemental element-matrix <code>eem</code> via <code>indices</code>. The current <code>epm</code> permutation is stored in <code>epm.permutation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L328-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T" href="#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T"><code>PartitionedStructures.M_abstract_part_struct.get_ee_struct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem_set = get_ee_struct(epm::Elemental_pm{T}) where T</code></pre><p>Return the vector of every elemental element-matrices <code>epm.eem_set</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T" href="#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T"><code>PartitionedStructures.M_abstract_part_struct.get_ee_struct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = get_ee_struct(epm::Elemental_pm{T}, i::Int) where T</code></pre><p>Return the <code>i</code>-th elemental element-matrix <code>epm.eem_set[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.correlated_var-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T" href="#PartitionedStructures.ModElemental_pm.correlated_var-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T"><code>PartitionedStructures.ModElemental_pm.correlated_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">correlated_var(epm::Elemental_pm{T}, i::Int) where T</code></pre><p>Gather all the variables appearing in the elements also paramtrized by the <code>i</code>-th variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L357-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T" href="#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T"><code>PartitionedStructures.ModElemental_pm.get_eem_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem_set = get_eem_set(epm::Elemental_pm{T}) where T</code></pre><p>Return the vector of every elemental element-matrices <code>epm.eem_set</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T" href="#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T"><code>PartitionedStructures.ModElemental_pm.get_eem_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = get_eem_set(epm::Elemental_pm{T}, i::Int) where T</code></pre><p>Return the <code>i</code>-th elemental element-matrix <code>epm.eem_set[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.get_eem_set_Bie-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T" href="#PartitionedStructures.ModElemental_pm.get_eem_set_Bie-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T"><code>PartitionedStructures.ModElemental_pm.get_eem_set_Bie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Bie = get_eem_set_Bie(get_eem_set_Bie(epm::Elemental_pm{T}, i::Int) where T</code></pre><p>Get the matrix of the <code>i</code>-th elemental element-matrix of <code>epm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.get_eem_sub_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T" href="#PartitionedStructures.ModElemental_pm.get_eem_sub_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T"><code>PartitionedStructures.ModElemental_pm.get_eem_sub_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem_subset = get_eem_sub_set(epm::Elemental_pm{T}, indices::Vector{Int}) where T</code></pre><p>Return a subset of elemental element-matrices composing <code>epm</code>. <code>indices</code> selects the different elemental element-matrices needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pm.identity_epm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epm = identity_epm(N::Int, n::Int; T=Float64, nie::Int=5, linear_vector::Vector{Bool} = zeros(Bool, N))</code></pre><p>Return a partitionned matrix of type <code>T</code> of <code>N</code> identity elemental element-matrices. Each elemental element-matrix is of size <code>nie</code> with randoms positions. <code>linear_vector</code> indicates which element linear-opeartor should not contribute to the partitioned linear-operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L155-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Vector{Vector{Int64}}}" href="#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Vector{Vector{Int64}}}"><code>PartitionedStructures.ModElemental_pm.identity_epm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epm = identity_epm(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64, linear_vector::Vector{Bool} = zeros(Bool, N))
epm = identity_epm(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64, linear_vector::Vector{Bool} = zeros(Bool, N))</code></pre><p>Return a partitionned matrix of type <code>T</code> of <code>N</code> identity elemental element-matrices. <code>N</code> and <code>n</code> may be extrapolate from <code>element_variables</code>. The elemental variables are based from the indices informed in <code>element_variables</code>. <code>linear_vector</code> indicates which element linear-opeartor should not contribute to the partitioned linear-operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L109-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.n_i_SPS-Tuple{Int64}" href="#PartitionedStructures.ModElemental_pm.n_i_SPS-Tuple{Int64}"><code>PartitionedStructures.ModElemental_pm.n_i_SPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epm = n_i_SPS(n::Int; T=Float64, nie::Int=5, overlapping::Int=1, mul=5.)</code></pre><p>Define an elemental partitioned-matrix <code>epm</code> of size <code>n</code>. The partitioned-matrix is composed by <code>N ≈ (n/nie)*2</code> elemental element-matrices, of size <code>nie</code>, they overlap onto the next element by <code>overlapping</code>. The diagonal terms of each elemental element-matrix are of value <code>mul</code>, whereas the other terms are set to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L240-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.n_i_sep-Tuple{Int64}" href="#PartitionedStructures.ModElemental_pm.n_i_sep-Tuple{Int64}"><code>PartitionedStructures.ModElemental_pm.n_i_sep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epm = n_i_sep(n::Int; T=Float64, nie::Int=5, mul=5.)</code></pre><p>Define an elemental partitioned-matrix <code>epm</code> composed of <code>nie</code> separable blocs. Each elemental element-matrix is composed of <code>1</code> except the diagonal terms which are of value <code>mul</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.ones_epm-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_pm.ones_epm-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pm.ones_epm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epm = ones_epm(N::Int, n::Int; T=Float64, nie::Int=5)</code></pre><p>Create a partitionned matrix of type <code>T</code> of <code>N</code> elemental element-matrices <code>ones(nie, nie)</code> whose positions are random. The partitionned matrix created may be singular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.ones_epm_and_id-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_pm.ones_epm_and_id-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_pm.ones_epm_and_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epm = ones_epm_and_id(N::Int, n::Int; T=Float64, nie::Int=5)</code></pre><p>Create a partitionned matrix of type <code>T</code> with <code>N+n</code> elemental element-matrices. The first <code>N</code> elemental element-matrices are <code>ones(nie, nie)</code> with randoms positions in the range <code>1:n</code>. The remaining <code>n</code> elemental element-matrices are of size 1, with value [1], they are placed in the diagonal terms This way, the partitionned matrix is generally not singular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L200-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_pm.part_mat-Tuple{}" href="#PartitionedStructures.ModElemental_pm.part_mat-Tuple{}"><code>PartitionedStructures.ModElemental_pm.part_mat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epm = part_mat(;n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1, mul=5.)</code></pre><p>Define an elemental partitioned-matrix <code>epm</code> composed of <code>N</code> (deduced from <code>n</code> and <code>nie</code>) elemental element-matrices of size <code>nie</code>. Each elemental element-matrix overlaps the previous and the next element by <code>overlapping</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_pm.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_em.Elemental_em" href="#PartitionedStructures.ModElemental_em.Elemental_em"><code>PartitionedStructures.ModElemental_em.Elemental_em</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Elemental_em{T} &lt;: DenseEltMat{T}</code></pre><p>Represent an elemental element-matrix. It has fields:</p><ul><li><code>indices</code>: indices of elemental variables;</li><li><code>nie</code>: elemental size (<code>=length(indices)</code>);</li><li><code>Bie::Symmetric{T, Matrix{T}}</code>: the elemental matrix;</li><li><code>counter</code>: counts how many update the elemental matrix goes through from its allocation;</li><li><code>convex</code>: if <code>convex==true</code>, then <code>Elemental_em</code> default update is BFGS otherwise it is SR1;</li><li><code>linear</code>: if <code>linear==true</code>, then the element matrix contribution is null;</li><li><code>_Bsr</code>: a vector used during quasi-Newton update of the elemental matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_em.jl#L12-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.permute!-Union{Tuple{T}, Tuple{Elemental_em{T}, Vector{Int64}}} where T" href="#Base.permute!-Union{Tuple{T}, Tuple{Elemental_em{T}, Vector{Int64}}} where T"><code>Base.permute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permute!(eem::Elemental_em{T}, p::Vector{Int}) where T</code></pre><p>Set the indices of the element variables of <code>eem</code> to <code>p</code>. Must be use with caution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_em.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_em.create_id_eem-Tuple{Vector{Int64}}" href="#PartitionedStructures.ModElemental_em.create_id_eem-Tuple{Vector{Int64}}"><code>PartitionedStructures.ModElemental_em.create_id_eem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = create_id_eem(elt_var::Vector{Int}; T=Float64)</code></pre><p>Create a <code>nie</code> identity elemental element-matrix of type <code>T</code> based on the vector of the elemental variables <code>elt_var</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_em.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_em.fixed_ones_eem-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_em.fixed_ones_eem-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_em.fixed_ones_eem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = fixed_ones_eem(i::Int, nie::Int; T=Float64, mul=5.)</code></pre><p>Create a <code>nie</code> elemental element-matrix of type <code>T</code> at indices <code>index:index+nie-1</code>. All the components of the element-matrix are set to <code>1</code> except the diagonal terms that are set to <code>mul</code>. This method is used to define diagonal dominant element-matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_em.jl#L108-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_em.identity_eem-Tuple{Int64}" href="#PartitionedStructures.ModElemental_em.identity_eem-Tuple{Int64}"><code>PartitionedStructures.ModElemental_em.identity_eem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = identity_eem(nie::Int; T=Float64, n=nie^2)</code></pre><p>Return a <code>nie</code> identity elemental element-matrix of type <code>T</code> from <code>nie</code> random indices in the range <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_em.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_em.one_size_bloc-Tuple{Int64}" href="#PartitionedStructures.ModElemental_em.one_size_bloc-Tuple{Int64}"><code>PartitionedStructures.ModElemental_em.one_size_bloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = one_size_bloc(index::Int; T=Float64)</code></pre><p>Return an elemental element-matrix of type <code>T</code> of size one at <code>index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_em.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_em.ones_eem-Tuple{Int64}" href="#PartitionedStructures.ModElemental_em.ones_eem-Tuple{Int64}"><code>PartitionedStructures.ModElemental_em.ones_eem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eem = ones_eem(nie::Int; T=Float64, n=nie^2)</code></pre><p>Return a <code>nie</code> ones elemental element-matrix of type <code>T</code> from <code>nie</code> random indices in the range <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_em.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Utils.BFGS!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number" href="#PartitionedStructures.Utils.BFGS!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.BFGS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BFGS!(x0::Vector{Y}, x1::Vector{Y}, g0::Vector{Y}, g1::Vector{Y}, B0::Array{Y,2}; kwargs...) where Y &lt;: Number
BFGS!(s::Vector{Y}, y::Vector{Y}, B::Symmetric{Y,Matrix{Y}}; kwargs...) where Y &lt;: Number
BFGS!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; index=0, reset=4, kwargs...)</code></pre><p>Perform the BFGS update in place of the matrix <code>B1</code> by using the vectors <code>s = x1 - x0</code> and <code>y = g1 - g0</code> and the current matrix <code>B0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/utils.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Utils.BFGS-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number" href="#PartitionedStructures.Utils.BFGS-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.BFGS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BFGS(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number
BFGS(x0::Vector{Y}, x1::Vector{Y}, g0::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number</code></pre><p>Perform the BFGS update over the matrix <code>B</code> by using the vectors <code>s = x1 - x0</code> and <code>y = g1 - g0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/utils.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Utils.SE!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number" href="#PartitionedStructures.Utils.SE!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.SE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SE!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number
SE!(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number
SE!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}, B1::Array{Y,2}; index=0, reset=4, ω = 1e-6, kwargs...)</code></pre><p>Perform a BFGS update in place of <code>B1</code> by using the matrix <code>B</code>, the vectors <code>s = x1 - x0</code> and <code>y = g1 - g0</code> if the curvature condition <code>dot(s,y) &gt; eps(eltype(s))</code> holds. Otherwise, it performs a SR1 update onto <code>B1</code> with <code>B, s, y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/utils.jl#L193-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Utils.SE-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number" href="#PartitionedStructures.Utils.SE-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.SE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SE(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number
SE(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number</code></pre><p>Perform a BFGS update over the matrix <code>B</code> by using the vectors <code>s = x1 - x0</code> and <code>y = g1 - g0</code> if the curvature condition <code>dot(s,y) &gt; eps(eltype(s))</code> holds. Otherwise, it performs a SR1 update with <code>B, s, y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/utils.jl#L167-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Utils.SR1!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number" href="#PartitionedStructures.Utils.SR1!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.SR1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SR1!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number
SR1!(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number
SR1!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}, B1::Array{Y,2}; index=0, reset=4, ω = 1e-6, kwargs...)</code></pre><p>Perform the SR1 update in place of the matrix <code>B1</code> by using the vectors <code>s = x1 - x0</code> and <code>y = g1 - g0</code> and the current matrix <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/utils.jl#L125-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Utils.SR1-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number" href="#PartitionedStructures.Utils.SR1-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y&lt;:Number"><code>PartitionedStructures.Utils.SR1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SR1(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number
SR1(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y &lt;: Number</code></pre><p>Perform the SR1 update over the matrix <code>B</code> by using the vectors <code>s = x1 - x0</code> and <code>y = g1 - g0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/utils.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Utils.max_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Number" href="#PartitionedStructures.Utils.max_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.Utils.max_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">indice_max = max_indices(list_of_element_variables::Vector{Vector{T}}) where T
indice_max = max_indices(elt_set::Vector{T}) where T &lt;: Element_struct</code></pre><p>Return the maximum index of the element variables in <code>list_of_element_variables</code> or in <code>elt_set</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/utils.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Utils.min_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Number" href="#PartitionedStructures.Utils.min_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.Utils.min_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">indice_min = min_indices(list_of_element_variables::Vector{Vector{T}}) where T
indice_min = min_indices(elt_set::Vector{T}) where T &lt;: Element_struct</code></pre><p>Return the minimum index of the element variables in <code>list_of_element_variables</code> or in <code>elt_set</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/utils.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Utils.my_and" href="#PartitionedStructures.Utils.my_and"><code>PartitionedStructures.Utils.my_and</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">my_and(a::Bool, b::Bool)</code></pre><p>Return <code>a &amp;&amp; b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/utils.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.eplo_lbfgs_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Elemental_pv{Y}}" href="#PartitionedStructures.Link.eplo_lbfgs_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Elemental_pv{Y}}"><code>PartitionedStructures.Link.eplo_lbfgs_from_epv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = eplo_lbfgs_from_epv(epv::T) where {Y &lt;: Number, T &lt;: Elemental_pv{Y}}</code></pre><p>Create an elemental limited-memory partitioned quasi-Newton operator PLBFGS <code>eplo</code> with the same partitioned structure than <code>epv</code>. Each element linear-operator of <code>eplo</code> is set to a <code>LBFGSOperator</code> of suitable size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.eplo_lose_from_epv-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T&lt;:Number" href="#PartitionedStructures.Link.eplo_lose_from_epv-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.Link.eplo_lose_from_epv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = eplo_lose_from_epv(epv::Elemental_pv{T}) where {T &lt;: Number}</code></pre><p>Create an elemental limited-memory partitioned quasi-Newton operator PLSE <code>eplo</code> with the same partitioned structure than <code>epv</code>. Each element linear-operator of <code>eplo</code> is set to a <code>LBFGSOperator</code> of suitable size, but it may change to a <code>LSR1Operator</code> later on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.eplo_lsr1_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Elemental_pv{Y}}" href="#PartitionedStructures.Link.eplo_lsr1_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Elemental_pv{Y}}"><code>PartitionedStructures.Link.eplo_lsr1_from_epv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = eplo_lsr1_from_epv(epv::T) where {Y &lt;: Number, T &lt;: Elemental_pv{Y}}</code></pre><p>Create an elemental limited-memory partitioned quasi-Newton operator PLSR1 <code>eplo</code> with the same partitioned structure than <code>epv</code>. Each element linear-operator of <code>eplo</code> is set to a <code>LSR1Operator</code> of suitable size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.epm_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Elemental_pv{Y}}" href="#PartitionedStructures.Link.epm_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Elemental_pv{Y}}"><code>PartitionedStructures.Link.epm_from_epv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epm = epm_from_epv(epv::T) where {Y &lt;: Number, T &lt;: Elemental_pv{Y}}</code></pre><p>Create an elemental partitioned quasi-Newton operator <code>epm</code> with the same partitioned structure than <code>epv</code>. Each element-matrix of <code>epm</code> is set with an identity matrix of suitable size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.epv_from_eplo-Tuple{Any}" href="#PartitionedStructures.Link.epv_from_eplo-Tuple{Any}"><code>PartitionedStructures.Link.epv_from_eplo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv = epv_from_eplo(eplo::T) where T &lt;: Part_mat{Y}</code></pre><p>Create an elemental partitioned-vector <code>epv</code> with the same partitioned structure than <code>eplo</code>. Each element-vector of <code>epv</code> is set to a random vector of suitable size. Make a name difference with the method <code>epv_from_epm()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.epv_from_epm-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}" href="#PartitionedStructures.Link.epv_from_epm-Union{Tuple{T}, Tuple{Y}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.epv_from_epm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv = epv_from_epm(epm::T) where T &lt;: Part_mat{Y}</code></pre><p>Create an elemental partitioned-vector <code>epv</code> with the same partitioned structure than <code>epm</code>. Each element-vector of <code>epv</code> is set to a random vector of suitable size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.mul_epm_epv!-Union{Tuple{T}, Tuple{Y}, Tuple{Elemental_pv{Y}, T, Elemental_pv{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}" href="#PartitionedStructures.Link.mul_epm_epv!-Union{Tuple{T}, Tuple{Y}, Tuple{Elemental_pv{Y}, T, Elemental_pv{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.mul_epm_epv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mul_epm_epv!(epv_res::Elemental_pv{Y}, epm::T, epv::Elemental_pv{Y}) where {Y &lt;: Number, T &lt;: Part_mat{Y}}</code></pre><p>Compute the elementwise product between the elemental partitioned-matrix <code>epm</code> and the elemental partitioned-vector <code>epv</code>. The result of each element-matrix element-vector product is stored in the elemental partitioned-vector <code>epv_res</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.mul_epm_epv-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}" href="#PartitionedStructures.Link.mul_epm_epv-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.mul_epm_epv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">epv_res = mul_epm_epv(epm::T, epv::Elemental_pv{Y}) where {Y &lt;: Number, T &lt;: Part_mat{Y}}</code></pre><p>Compute the elementwise product between the elemental partitioned-matrix <code>epm</code> and the elemental partitioned-vector <code>epv</code>. The result is an elemental partitioned-vector <code>epv_res</code> storing the elementwise products between <code>epm</code> and <code>epv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.mul_epm_vector!-Union{Tuple{T}, Tuple{Y}, Tuple{Vector{Y}, T, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}" href="#PartitionedStructures.Link.mul_epm_vector!-Union{Tuple{T}, Tuple{Y}, Tuple{Vector{Y}, T, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.mul_epm_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mul_epm_vector!(res::Vector{Y}, epm::T, x::Vector{Y}) where {Y &lt;: Number, T &lt;: Part_mat{Y}}
mul_epm_vector!(res::Vector{Y}, epm::T, epv::Elemental_pv{Y}, x::Vector{Y}) where {Y &lt;: Number, T &lt;: Part_mat{Y}}</code></pre><p>Compute the product between the elemental partitioned-matrix <code>epm</code> and the vector <code>x</code>. The method uses temporary the elemental partitioned-vector <code>epv</code>. The result is stored in <code>res</code>, a vector similar to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L155-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.mul_epm_vector-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}" href="#PartitionedStructures.Link.mul_epm_vector-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.Link.mul_epm_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">result = mul_epm_vector(epm::T, x::Vector{Y}) where {Y &lt;: Number, T &lt;: Part_mat{Y}}
result = mul_epm_vector(epm::T, epv::Elemental_pv{Y}, x::Vector{Y}) where {Y &lt;: Number, T &lt;: Part_mat{Y}}</code></pre><p>Compute the product between the elemental partitioned-matrix <code>epm &lt;: Part_mat</code> and the vector <code>x</code>. The method uses temporary the elemental partitioned-vector <code>epv</code>. The method returns <code>result</code>, a vector similar to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L142-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.string_counters_iter-Tuple{T} where T&lt;:Part_mat" href="#PartitionedStructures.Link.string_counters_iter-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.Link.string_counters_iter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">s = string_counters_iter(pm::T; name = :PQN) where {T &lt;: Part_mat}</code></pre><p>Produce <code>s::String</code> that summarizes the partitioned update applied onto <code>pm</code> at the last iterate. The method accumulates the informations gathered by each element-counter during the last iterate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L213-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Link.string_counters_total-Tuple{T} where T&lt;:Part_mat" href="#PartitionedStructures.Link.string_counters_total-Tuple{T} where T&lt;:Part_mat"><code>PartitionedStructures.Link.string_counters_total</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">s = string_counters_total(pm::T; name = :PQN) where {T &lt;: Part_mat}</code></pre><p>Produce <code>s::String</code> that summarizes the partitioned update applied onto <code>pm</code> since its allocations. The method accumulates the informations gathered by each element-counter since their allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/link.jl#L236-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PBFGS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T
PBFGS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T</code></pre><p>Perform the PBFGS update onto the elemental partitioned-matrix <code>epm_B</code>, given the step <code>s</code> (or the element-steps <code>epv_s</code>) and the difference of elemental partitioned-gradients <code>epv_y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedQuasiNewton.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedQuasiNewton.PBFGS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PBFGS_update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy_epm_B = PBFGS_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T</code></pre><p>Perform the PBFGS update onto a copy of the elemental partitioned-matrix <code>epm_B</code>, given the step <code>s</code> and the difference of elemental partitioned-gradients <code>epv_y</code>. Return the updated copy of <code>epm_B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedQuasiNewton.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedQuasiNewton.PCS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedQuasiNewton.PCS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PCS_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PCS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T
PCS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T</code></pre><p>Perform the PCS update onto the elemental partitioned-matrix <code>epm_B</code>, given the step <code>s</code> (or the element-steps <code>epv_s</code>) and the difference of elemental partitioned-gradients <code>epv_y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedQuasiNewton.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedQuasiNewton.PCS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedQuasiNewton.PCS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PCS_update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">B = PCS_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T</code></pre><p>Perform the PCS update onto a copy of the elemental partitioned-matrix <code>epm_B</code>, given the step <code>s</code> and the difference of elemental partitioned-gradients <code>epv_y</code>. Each elemental element-matrix <code>eem</code> is update given its <code>convex</code> field, if <code>convex==true</code> the elemental element-matrix <code>eem</code> is update with BFGS otherwise it is SR1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedQuasiNewton.jl#L211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedQuasiNewton.PSE_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedQuasiNewton.PSE_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PSE_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PSE_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T
PSE_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T</code></pre><p>Perform the PSE update onto the elemental partitioned-matrix <code>epm_B</code>, given the step <code>s</code> (or the element-steps <code>epv_s</code>) and the difference of elemental partitioned-gradients <code>epv_y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedQuasiNewton.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedQuasiNewton.PSE_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedQuasiNewton.PSE_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PSE_update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy_epm_B = PSE_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T</code></pre><p>Perform the PSE update onto a copy of the elemental partitioned-matrix <code>epm_B</code>, given the step <code>s</code> and the difference of elemental partitioned-gradients <code>epv_y</code>. Return the updated copy of <code>epm_B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedQuasiNewton.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedQuasiNewton.PSR1_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedQuasiNewton.PSR1_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PSR1_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PSR1_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T
PSR1_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T</code></pre><p>Performs the PSR1 update onto the elemental partitioned-matrix <code>epm_B</code>, given the step <code>s</code> (or the element-steps <code>epv_s</code>) and the difference of elemental partitioned-gradients <code>epv_y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedQuasiNewton.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedQuasiNewton.PSR1_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedQuasiNewton.PSR1_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedQuasiNewton.PSR1_update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy_epm_B = PSR1_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T</code></pre><p>Perform the PSR1 update onto a copy of the elemental partitioned-matrix <code>epm_B</code>, given the step <code>s</code> and the difference of elemental partitioned-gradients <code>epv_y</code>. Return the updated copy of <code>epm_B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedQuasiNewton.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PLBFGS_update!(eplo_B::Elemental_plo_bfgs{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T
PLBFGS_update!(eplo_B::Elemental_plo_bfgs{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, reset=true, kwargs...) where T</code></pre><p>Perform the PLBFGS update onto the partitioned limited-memory operator <code>eplo_B</code>, given the step <code>s</code> (or the element-steps <code>epv_s</code>) and the difference of elemental partitioned-gradients <code>epv_y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedLOQuasiNewton.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy_eplo_B = PLBFGS_update(eplo_B::Elemental_plo_bfgs{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T</code></pre><p>Perform the PLBFGS update onto a copy of the partitioned limited-memory operator <code>eplo_B</code>, given the step <code>s</code> and the difference of elemental partitioned-gradients <code>epv_y</code>. Return the updated copy of <code>eplo_B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedLOQuasiNewton.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}" href="#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PLSE_update!(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where {T, Y &lt;: Part_LO_mat{T}}
PLSE_update!(eplo_B::Y, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; ω = 1e-6, verbose=true, reset=4, kwargs...) where {T, Y &lt;: Part_LO_mat{T}}</code></pre><p>Perform the partitionned update PLSE onto the partitioned limited-memory operator <code>eplo_B</code>, given the step <code>s</code> (or the element-steps <code>epv_s</code>) and the difference of elemental partitioned-gradients <code>epv_y</code>. Each element linear-operator from <code>eplo_B</code> is either a <code>LBFGSOperator</code> or <code>LSR1Operator</code>. The update tries to apply a LBFGS update to every Bᵢ, but if the curvature condition yᵢᵀUᵢs &gt; 0 is not satisfied it replaces the <code>LBFGSOperator</code> by a <code>LSR1Operator</code> and applies a LSR1 update. If Bᵢ is initally a LSR1Opeartor, we replace it by a <code>LBFGSOperator</code> if the curvature condition yᵢᵀUᵢs &gt; 0 holds and we update it, otherwise the <code>LSR1Operator</code> Bᵢ is update.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedLOQuasiNewton.jl#L248-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}" href="#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy_eplo_B = PLSE_update(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where {T, Y &lt;: Part_LO_mat{T}}</code></pre><p>Perform the partitionned update PLSE onto a copy of the partitioned limited-memory operator <code>eplo_B</code>, given the step <code>s</code> and the difference of elemental partitioned-gradients <code>epv_y</code>. Each element linear-operator from <code>eplo_B</code> is either a <code>LBFGSOperator</code> or <code>LSR1Operator</code>. The update tries to apply a LBFGS update to every Bᵢ, but if the curvature condition yᵢᵀUᵢs &gt; 0 is not satisfied it replaces the <code>LBFGSOperator</code> by a <code>LSR1Operator</code> and applies a LSR1 update. If Bᵢ is initally a LSR1Opeartor, we replace it by a <code>LBFGSOperator</code> if the curvature condition yᵢᵀUᵢs &gt; 0 holds and we update it, otherwise the <code>LSR1Operator</code> Bᵢ is update. Return the updated copy of <code>eplo_B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedLOQuasiNewton.jl#L228-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PLSR1_update!(eplo_B::Elemental_plo_sr1{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T
PLSR1_update!(eplo_B::Elemental_plo_sr1{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T</code></pre><p>Perform the PLSR1 update onto the partitioned limited-memory operator <code>eplo_B</code>, given the step <code>s</code> (or the element-steps <code>epv_s</code>) and the difference of elemental partitioned-gradients <code>epv_y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedLOQuasiNewton.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T" href="#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T"><code>PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy_eplo_B = PLSR1_update(eplo_B::Elemental_plo_sr1{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T</code></pre><p>Perform the PSR1 update onto a copy of the partitioned limited-memory operator <code>eplo_B</code>, given the step <code>s</code> and the difference of elemental partitioned-gradients <code>epv_y</code>. Return the updated copy of <code>eplo_B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedLOQuasiNewton.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedLOQuasiNewton.Part_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}" href="#PartitionedStructures.PartitionedLOQuasiNewton.Part_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}"><code>PartitionedStructures.PartitionedLOQuasiNewton.Part_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Part_update!(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}) where {T, Y &lt;: Part_LO_mat{T}}
Part_update!(eplo_B::Y, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; kwargs...) where {T, Y &lt;: Part_LO_mat{T}}</code></pre><p>Perform a partitioned quasi-Newton update onto the partitioned limited-memory operator <code>eplo_B</code>, given the step <code>s</code> (or the element-steps <code>epv_s</code>) and the difference of elemental partitioned-gradients <code>epv_y</code>. Each elemental element linear-operator from <code>eplo_B</code> is either a <code>LBFGSOperator</code> or <code>LSR1Operator</code>. The update performs on each element the quasi-Newton update associated to the linear-operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedLOQuasiNewton.jl#L185-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartitionedLOQuasiNewton.Part_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}" href="#PartitionedStructures.PartitionedLOQuasiNewton.Part_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y&lt;:Part_LO_mat{T}}"><code>PartitionedStructures.PartitionedLOQuasiNewton.Part_update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy_eplo_B = Part_update(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}) where {T, Y &lt;: Part_LO_mat{T}}</code></pre><p>Perform a quasi-Newton partitionned update onto a copy of the partitioned limited-memory operator <code>eplo_B</code>, given the step <code>s</code> and the difference of elemental partitioned-gradients <code>epv_y</code>. Each elemental element linear-operator from <code>eplo_B</code> is either a <code>LBFGSOperator</code> or <code>LSR1Operator</code>. The update performs on each element the quasi-Newton update associated to the linear-operator. Return the updated copy of <code>eplo_B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/PartitionedLOQuasiNewton.jl#L166-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_bfgs.Elemental_elo_bfgs" href="#PartitionedStructures.ModElemental_elo_bfgs.Elemental_elo_bfgs"><code>PartitionedStructures.ModElemental_elo_bfgs.Elemental_elo_bfgs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Elemental_elo_bfgs{T} &lt;: LOEltMat{T}</code></pre><p>Represent an elemental element <code>LBFGSOperator</code>:</p><ul><li><code>indices</code> retains the indices of the elemental variables;</li><li><code>nie</code> is the elemental size (<code>=length(indices)</code>);</li><li><code>Bie</code> a <code>LBFGSOperator</code>;</li><li><code>linear</code>: if <code>linear==true</code>, then the element matrix contribution is null;</li><li><code>counter</code> counts how many update the elemental limited-memory operator goes through from its allocation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_BFGS.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo-Tuple{Int64}" href="#PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo-Tuple{Int64}"><code>PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eelo = LBFGS_eelo(nie::Int; T=Float64, index=1)</code></pre><p>Return an <code>Elemental_elo_bfgs</code> of type <code>T</code> of size <code>nie</code>, the indices are all the values in the range <code>index:index+nie-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_BFGS.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo_rand-Tuple{Int64}" href="#PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo_rand-Tuple{Int64}"><code>PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eelo = LBFGS_eelo_rand(nie::Int; T=Float64, n=nie^2)</code></pre><p>Return an <code>Elemental_elo_bfgs</code> of type <code>T</code> with <code>nie</code> random indices within the range <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_BFGS.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_bfgs.init_eelo_LBFGS-Tuple{Vector{Int64}}" href="#PartitionedStructures.ModElemental_elo_bfgs.init_eelo_LBFGS-Tuple{Vector{Int64}}"><code>PartitionedStructures.ModElemental_elo_bfgs.init_eelo_LBFGS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eelo = init_eelo_LBFGS(elt_var::Vector{Int}; T=Float64, mem=5)</code></pre><p>Return an <code>Elemental_elo_bfgs</code> of type <code>T</code> based on the vector of the elemental variables<code>elt_var</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_BFGS.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_bfgs.reset_eelo_bfgs!-Union{Tuple{Elemental_elo_bfgs{T}}, Tuple{T}} where T&lt;:Number" href="#PartitionedStructures.ModElemental_elo_bfgs.reset_eelo_bfgs!-Union{Tuple{Elemental_elo_bfgs{T}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_elo_bfgs.reset_eelo_bfgs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_eelo_bfgs!(eelo::Elemental_elo_bfgs{T}) where T &lt;: Number</code></pre><p>Reset the LBFGS linear-operator of the elemental element linear-operator <code>eelo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_BFGS.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo_bfgs.Elemental_plo_bfgs" href="#PartitionedStructures.ModElemental_plo_bfgs.Elemental_plo_bfgs"><code>PartitionedStructures.ModElemental_plo_bfgs.Elemental_plo_bfgs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Elemental_plo_bfgs{T} &lt;: Part_LO_mat{T}</code></pre><p>Represent an elemental partitioned quasi-Newton limited-memory operator PLBFGS. Each element is an elemental element <code>LBFGSOperator</code>. <code>N</code> is the number of elements. <code>n</code> is the size of the elemental partitioned limited-memory operator. <code>eelo_set</code> is the set of elemental element linear-operators. <code>spm</code> and <code>L</code> are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of <code>spm</code>. <code>component_list</code> summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by <code>i</code>. <code>permutation</code> is the current permutation of the elemental partitioned limited-memory operator (<code>[1:n;]</code> initially).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo_BFGS.jl#L14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo-Tuple{}" href="#PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo-Tuple{}"><code>PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = PLBFGS_eplo(; n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1)</code></pre><p>Return an elemental partitioned limited-memory operator PLBFGS of <code>N</code> (deduced from <code>n</code> and <code>nie</code>) elemental element linear-operators. Each element overlaps the coordinates of the next element by <code>overlapping</code> components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo_BFGS.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo_rand-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo_rand-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = PLBFGS_eplo_rand(N::Int, n::Int; T=Float64, nie::Int=5)</code></pre><p>Return an elemental partitioned limited-memory operator PLBFGS of <code>N</code> elemental element linear-operators. The size of each element is <code>nie</code>, whose positions are random in the range <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo_BFGS.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo_bfgs.identity_eplo_LBFGS-Tuple{Vector{Vector{Int64}}}" href="#PartitionedStructures.ModElemental_plo_bfgs.identity_eplo_LBFGS-Tuple{Vector{Vector{Int64}}}"><code>PartitionedStructures.ModElemental_plo_bfgs.identity_eplo_LBFGS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = identity_eplo_LBFGS(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64, linear_vector::Vector{Bool} = zeros(Bool, N), mem=5)
eplo = identity_eplo_LBFGS(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64, linear_vector::Vector{Bool} = zeros(Bool, N), mem=5)</code></pre><p>Return an elemental partitioned limited-memory operator PLBFGS of <code>N</code> elemental element linear-operators. The positions are given by the vector of the element variables <code>element_variables</code>. <code>linear_vector</code> indicates which element linear-opeartor should not contribute to the partitioned linear-operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo_BFGS.jl#L64-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_sr1.Elemental_elo_sr1" href="#PartitionedStructures.ModElemental_elo_sr1.Elemental_elo_sr1"><code>PartitionedStructures.ModElemental_elo_sr1.Elemental_elo_sr1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Elemental_elo_sr1{T} &lt;: LOEltMat{T}</code></pre><p>Represent an elemental element <code>LSR1Operator</code>;</p><ul><li><code>indices</code> retains the indices of the elemental variables;</li><li><code>nie</code> is the elemental size (<code>=length(indices)</code>);</li><li><code>Bie</code> a <code>LSR1Operator</code>;</li><li><code>linear</code>: if <code>linear==true</code>, then the element matrix contribution is null;</li><li><code>counter</code> counts how many update the elemental limited-memory operator goes through from its allocation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_SR1.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo-Tuple{Int64}" href="#PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo-Tuple{Int64}"><code>PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eelo = LSR1_eelo(nie::Int; T=Float64, index=1)</code></pre><p>Return an <code>Elemental_elo_sr1</code> of type <code>T</code> of size <code>nie</code>, the indices are all the values in the range <code>index:index+nie-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_SR1.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo_rand-Tuple{Int64}" href="#PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo_rand-Tuple{Int64}"><code>PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eelo = LSR1_eelo_rand(nie::Int; T=Float64, n=nie^2)</code></pre><p>Return an <code>Elemental_elo_sr1</code> of type <code>T</code> with <code>nie</code> random indices within the range <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_SR1.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_sr1.init_eelo_LSR1-Tuple{Vector{Int64}}" href="#PartitionedStructures.ModElemental_elo_sr1.init_eelo_LSR1-Tuple{Vector{Int64}}"><code>PartitionedStructures.ModElemental_elo_sr1.init_eelo_LSR1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eelo = init_eelo_LSR1(elt_var::Vector{Int}; T=Float64, mem=5)</code></pre><p>Return an <code>Elemental_elo_sr1</code> of type <code>T</code> based on the vector of the elemental variables <code>elt_var</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_SR1.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_elo_sr1.reset_eelo_sr1!-Union{Tuple{Elemental_elo_sr1{T}}, Tuple{T}} where T&lt;:Number" href="#PartitionedStructures.ModElemental_elo_sr1.reset_eelo_sr1!-Union{Tuple{Elemental_elo_sr1{T}}, Tuple{T}} where T&lt;:Number"><code>PartitionedStructures.ModElemental_elo_sr1.reset_eelo_sr1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_eelo_sr1!(eelo::Elemental_elo_sr1{T}) where T &lt;: Number</code></pre><p>Reset the LSR1 linear-operator of the elemental element linear-operator matrix <code>eelo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_elo_SR1.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo_sr1.Elemental_plo_sr1" href="#PartitionedStructures.ModElemental_plo_sr1.Elemental_plo_sr1"><code>PartitionedStructures.ModElemental_plo_sr1.Elemental_plo_sr1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Elemental_plo_sr1{T} &lt;: Part_LO_mat{T}</code></pre><p>Represent an elemental partitioned quasi-Newton limited-memory operator PLSR1. Each element is an elemental element <code>LSR1Operator</code>. <code>N</code> is the number of elements. <code>n</code> is the size of the elemental partitioned limited-memory operator. <code>eelo_set</code> is the set of elemental element linear-operators. <code>spm</code> and <code>L</code> are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of <code>spm</code>. <code>component_list</code> summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by <code>i</code>. <code>permutation</code> is the current permutation of the elemental partitioned limited-memory operator (<code>[1:n;]</code> initially).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo_SR1.jl#L15-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo-Tuple{}" href="#PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo-Tuple{}"><code>PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = PLSR1_eplo(; n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1)</code></pre><p>Return an elemental partitionned limited-memory operator PLSR1 of <code>N</code> (deduced from <code>n</code> and <code>nie</code>) elemental element linear-operators. Each element overlaps the coordinates of the next element by <code>overlapping</code> components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo_SR1.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo_rand-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo_rand-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = PLSR1_eplo_rand(N::Int, n::Int; T=Float64, nie::Int=5)</code></pre><p>Return an elemental partitionned limited-memory operator PLSR1 of <code>N</code> elemental element linear-operators. The size of each element is <code>nie</code>, whose positions are random in the range <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo_SR1.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo_sr1.identity_eplo_LSR1-Tuple{Vector{Vector{Int64}}}" href="#PartitionedStructures.ModElemental_plo_sr1.identity_eplo_LSR1-Tuple{Vector{Vector{Int64}}}"><code>PartitionedStructures.ModElemental_plo_sr1.identity_eplo_LSR1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = identity_eplo_LSR1(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64, linear_vector::Vector{Bool} = zeros(Bool, N); mem=5)
eplo = identity_eplo_LSR1(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64, linear_vector::Vector{Bool} = zeros(Bool, N); mem=5)</code></pre><p>Return an elemental partitionned limited-memory operator PLSR1 of <code>N</code> elemental element linear-operators. The positions are given by the vector of the element variables <code>element_variables</code>. <code>linear_vector</code> indicates which element linear-opeartor should not contribute to the partitioned linear-operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo_SR1.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo.Elemental_plo" href="#PartitionedStructures.ModElemental_plo.Elemental_plo"><code>PartitionedStructures.ModElemental_plo.Elemental_plo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Elemental_plo{T} &lt;: Part_LO_mat{T}</code></pre><p>Represent an elemental partitioned quasi-Newton limited-memory operator PLSE. Each element may either be a <code>LBFGSOperator</code> or a <code>LSR1Operator</code>. <code>N</code> is the number of elements. <code>n</code> is the size of the elemental partitioned limited-memory operator. <code>eelo_set</code> is the set of elemental element linear-operators. <code>spm</code> and <code>L</code> are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of <code>spm</code>. <code>component_list</code> summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by <code>i</code>. <code>permutation</code> is the current permutation of the elemental partitioned limited-memory operator (<code>[1:n;]</code> initially).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo.jl#L18-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo-Tuple{}" href="#PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo-Tuple{}"><code>PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = PLBFGSR1_eplo(;n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1, prob=0.5)</code></pre><p>Create an elemental partitionned limited-memory operator PLSE of <code>N</code> (deduced from <code>n</code> and <code>nie</code>) elemental element linear-operators. Each element overlaps the coordinates of the next element by <code>overlapping</code> components. Each element is randomly (<code>rand() &gt; p</code>) choose between an elemental element LBFGS operator or an elemental element LSR1 operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo_rand-Tuple{Int64, Int64}" href="#PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo_rand-Tuple{Int64, Int64}"><code>PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = PLBFGSR1_eplo_rand(N::Int, n ::Int; T=Float64, nie::Int=5, prob=0.5)</code></pre><p>Create an elemental partitionned limited-memory operator PLSE of <code>N</code> elemental element linear-operators. The size of each element is <code>nie</code>, whose positions are random in the range <code>1:n</code>. Each element is randomly (rand() &gt; p) choose between an elemental element LBFGS operator or an elemental element LSR1 operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo.jl#L140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.ModElemental_plo.identity_eplo_LOSE-Tuple{Vector{Vector{Int64}}}" href="#PartitionedStructures.ModElemental_plo.identity_eplo_LOSE-Tuple{Vector{Vector{Int64}}}"><code>PartitionedStructures.ModElemental_plo.identity_eplo_LOSE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eplo = identity_eplo_LOSE(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64, linear_vector::Vector{Bool} = zeros(Bool, N), mem=5)
eplo = identity_eplo_LOSE(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64, linear_vector::Vector{Bool} = zeros(Bool, N), mem=5)</code></pre><p>Create an elemental partitionned limited-memory operator of <code>N</code> elemental element linear-operators initialized with LBFGS operators. The positions are given by the vector of the element variables <code>element_variables</code>. <code>linear_vector</code> indicates which element linear-opeartor should not contribute to the partitioned linear-operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/P_mat/elemental_plo.jl#L72-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Instances.create_epv_eplo-Tuple{}" href="#PartitionedStructures.Instances.create_epv_eplo-Tuple{}"><code>PartitionedStructures.Instances.create_epv_eplo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(eplo,epv) = create_epv_eplo_sr1(;n=9,nie=5,overlapping=1, mul_v=100.)</code></pre><p>Create an elemental partitioned limited-memory quasi-Newton operator <code>eplo</code> and elemental partitioned-vector <code>epv</code>. Both have the same partitioned structure defined by the size of the problem <code>n::Int</code>, the size of the element <code>nie::Int</code> and the overlapping between the consecutive elements <code>overlapping::Int</code>. Each elemental element-matrix is instantiated as a <code>LBFGSOperator</code>, but it may change to a <code>LSR1Operator</code> later on. The value of each elemental element-vector is <code>rand(nie) .* mul_v::Real</code>. Warning: You have to choose carefully the values <code>n</code>, <code>nie</code> and <code>overlap</code>, otherwise the method may fail. The default values are correct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/instances.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Instances.create_epv_eplo_bfgs-Tuple{}" href="#PartitionedStructures.Instances.create_epv_eplo_bfgs-Tuple{}"><code>PartitionedStructures.Instances.create_epv_eplo_bfgs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(eplo,epv) = create_epv_eplo_bfgs(;n=9,nie=5,overlapping=1, mul_v=100.)</code></pre><p>Create an elemental partitioned limited-memory quasi-Newton operator PLBFGS <code>eplo</code> and an elemental partitioned-vector <code>epv</code>. Both have the same partitioned structure defined by the size of the problem <code>n::Int</code>, the size of the element <code>nie::Int</code> and the overlapping between the consecutive elements <code>overlapping::Int</code>. Each elemental element-matrix is a <code>LBFGSOperator</code>. The value of each elemental element-vector is <code>rand(nie) .* mul_v::Real</code>. Warning: You have to choose carefully the values <code>n</code>, <code>nie</code> and <code>overlap</code>, otherwise the method may fail. The default values are correct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/instances.jl#L51-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Instances.create_epv_eplo_sr1-Tuple{}" href="#PartitionedStructures.Instances.create_epv_eplo_sr1-Tuple{}"><code>PartitionedStructures.Instances.create_epv_eplo_sr1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(eplo,epv) = create_epv_eplo_sr1(;n=9,nie=5,overlapping=1, mul_v=100.)</code></pre><p>Create an elemental partitioned limited-memory quasi-Newton operator PLSR1 <code>eplo</code> and an elemental partitioned-vector <code>epv</code>. Both have the same partitioned structure defined by the size of the problem <code>n::Int</code>, the size of the element <code>nie::Int</code> and the overlapping between the consecutive elements <code>overlapping::Int</code>. Each elemental element-matrix is a <code>LSR1Operator</code>. The value of each elemental element-vector is <code>rand(nie) .* mul_v::Real</code>. Warning: You have to choose carefully the values <code>n</code>, <code>nie</code> and <code>overlap</code>, otherwise the method may fail. The default values are correct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/instances.jl#L67-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Instances.create_epv_epm-Tuple{}" href="#PartitionedStructures.Instances.create_epv_epm-Tuple{}"><code>PartitionedStructures.Instances.create_epv_epm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(epm,epv) = create_epv_epm(;n=9,nie=5,overlapping=1,mul_m=5., mul_v=100.)</code></pre><p>Create an elemental partitioned-matrix <code>epm</code> and an elemental partitioned-vector <code>epv</code>. Both have the same partitioned structure defined by the size of the problem <code>n::Int</code>, the size of the element <code>nie::Int</code> and the overlapping between the consecutive elements <code>overlapping::Int</code>. Each elemental element-matrix is fill with ones, except the terms of the diagonal of value <code>mul_v::Real</code>. The value of each elemental element-vector is <code>rand(nie) .* mul_v::Real</code>. Warning: You have to choose carefully the values <code>n</code>, <code>nie</code> and <code>overlap</code>, otherwise the method may fail. The default values are correct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/instances.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.Instances.create_epv_epm_rand-Tuple{}" href="#PartitionedStructures.Instances.create_epv_epm_rand-Tuple{}"><code>PartitionedStructures.Instances.create_epv_epm_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(epm,epv) = create_epv_epm_rand(;n=9,nie=5,overlapping=1,range_mul_m=nie:2*nie, mul_v=100.)</code></pre><p>Create an elemeental partitioned quasi-Newton operator <code>epm</code> and an elemental partitioned-vector <code>epv</code>. Both have the same partitioned structure defined by the size of the problem <code>n::Int</code>, the size of the element <code>nie::Int</code> and the overlapping between the consecutive elements <code>overlapping::Int</code>. Each elemental element-matrix is fill with ones, except the terms of the diagonal of value <code>rand(1:range_mul_v)</code>. The value of each elemental element-vector is <code>rand(nie) .* mul_v::Real</code>. Warning: You have to choose carefully the values <code>n</code>, <code>nie</code> and <code>overlap</code>, otherwise the method may fail. The default values are correct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/instances.jl#L29-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartMatInterface.update!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}" href="#PartitionedStructures.PartMatInterface.update!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.PartMatInterface.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(epm::T, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; name=:pse, kwargs...) where {Y &lt;: Number, T &lt;: Part_mat{Y}}
update!(epm::T, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where {Y &lt;: Number, T &lt;: Part_mat{Y}}</code></pre><p>Update the elemental partitioned-matrix <code>epm</code> with a partitioned quasi-Newton update considering the difference of elemental partitioned-gradients <code>epv_y</code> and the step <code>s</code> (or elemental steps <code>epv_s</code>). The PSE update is run by default, you can apply a PBFGS or a PSR1 update with the optionnal argument <code>name</code>, respectively <code>name=:pbfgs</code> or <code>name=:psr1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/part_mat_interface.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_bfgs{Y}, Elemental_pv{Y}, Vector{Y}}} where Y&lt;:Number" href="#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_bfgs{Y}, Elemental_pv{Y}, Vector{Y}}} where Y&lt;:Number"><code>PartitionedStructures.PartMatInterface.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(eplo::Elemental_plo_bfgs{Y}, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where Y &lt;: Number
update!(eplo::Elemental_plo_bfgs{Y}, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; kwargs...) where Y &lt;: Number</code></pre><p>Updates the elemental partitioned limited-memory operator <code>eplo</code> with the partitioned quasi-Newton update PLBFGS considering the difference of elemental partitioned-gradients <code>epv_y</code> and the step <code>s</code> (or elemental steps <code>epv_s</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/part_mat_interface.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_sr1{Y}, Elemental_pv{Y}, Vector{Y}}} where Y&lt;:Number" href="#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_sr1{Y}, Elemental_pv{Y}, Vector{Y}}} where Y&lt;:Number"><code>PartitionedStructures.PartMatInterface.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(eplo::Elemental_plo_sr1{Y}, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where Y &lt;: Number
update!(eplo::Elemental_plo_sr1{Y}, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; kwargs...) where Y &lt;: Number</code></pre><p>Updates the elemental partitioned limited-memory operator <code>eplo</code> with the partitioned quasi-Newton update PLSR1 considering the difference of elemental partitioned-gradients <code>epv_y</code> and the step <code>s</code> (or elemental steps <code>epv_s</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/part_mat_interface.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo{Y}, Elemental_pv{Y}, Vector{Y}}} where Y&lt;:Number" href="#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo{Y}, Elemental_pv{Y}, Vector{Y}}} where Y&lt;:Number"><code>PartitionedStructures.PartMatInterface.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(eplo::Elemental_plo{Y}, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where Y &lt;: Number
update!(eplo::Elemental_plo{Y}, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; kwargs...) where Y &lt;: Number</code></pre><p>Updates the elemental partitioned limited-memory operator <code>eplo</code> with the partitioned quasi-Newton update PLSE considering the difference of elemental partitioned-gradients <code>epv_y</code> and the step <code>s</code> (or elemental steps <code>epv_s</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/part_mat_interface.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartitionedStructures.PartMatInterface.update-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}" href="#PartitionedStructures.PartMatInterface.update-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y&lt;:Number, T&lt;:Part_mat{Y}}"><code>PartitionedStructures.PartMatInterface.update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">B = update(epm::T, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where {Y &lt;: Number, T &lt;: Part_mat{Y}}</code></pre><p>Update the elemental partitioned operator <code>epm &lt;: Part_mat</code> with a partitioned quasi-Newton update considering the difference of elemental partitioned-gradients <code>epv_y</code> and the step <code>s</code>. If <code>epm</code> is an elemental partitioned-matrix, the PSE update is run by default. You can apply a PBFGS or a PSR1 update with the optionnal argument <code>name</code>, respectively <code>name=:pbfgs</code> or <code>name=:psr1</code>. It returns a matrix accumulating every element-contribtion of the updated <code>epm</code>. Warning: this method should be use to test your algorithm, if you don&#39;t intend to form the matrix use <code>update!(epm, epv_y, s)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartitionedStructures.jl/blob/572d6d1fda7985422c6fbe1ecc071c9808e5a210/src/methods/part_mat_interface.jl#L13-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../developer_note/">Developer note »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 19 September 2023 20:32">Tuesday 19 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
