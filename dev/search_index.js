var documenterSearchIndex = {"docs":
[{"location":"developper_note/#Important-things-to-know","page":"Developper note","title":"Important things to know","text":"","category":"section"},{"location":"developper_note/","page":"Developper note","title":"Developper note","text":"There is several type of partial separability  $  f(x) = \\sum{i=1}^N \\widehat{f}i Ui(x), $ Ui$ may be based from the elemental variables or the internal variables of widehatf_i. The elemental variables represent the subset of variables that parametrizes hatf_i while the internal variables are the linear combination of the variables that parametrizes hatf_i. In consequence the implementation of the linear operator U_i, which support entirely the partial separability, change depending interal or elemental variables.","category":"page"},{"location":"developper_note/","page":"Developper note","title":"Developper note","text":"If you take a look at the code, you will see some","category":"page"},{"location":"developper_note/","page":"Developper note","title":"Developper note","text":"eev # refers to an elemental element vector\niev # refers to an internal element vector\nepv # refers to an elemental partitioned vector\nipv # refers to an internal partitioned vector\neem # refers to an elemental element matrix\neelom # refers to limited-memory elemental element matrix\niem # refers to an internal element matrix\nepm # refers to an elemental partitioned matrix\nipm # refers to an internal partitioned matrix\neplom # refers to limited-memory elemental partitioned matrix","category":"page"},{"location":"developper_note/","page":"Developper note","title":"Developper note","text":"At the moment, we mainly developed the elemental partitioned structures, but we left the door open to the development of internal partitioned structures in the future.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PartitionedStructures, M_abstract_part_struct,M_abstract_element_struct,M_internal_elt_vec,M_internal_pv,M_elt_vec,ModElemental_ev,ModElemental_pv,M_elt_mat,M_part_mat,M_part_v,ModElemental_pm,ModElemental_em,M_okoubi_koko,M_frontale, M_1_parallel, M_2_parallel, M_3_parallel, Utils, Link, PartitionedQuasiNewton, PartitionedLOQuasiNewton, ModElemental_elom_bfgs, ModElemental_plom_bfgs, ModElemental_elom_sr1, ModElemental_plom_sr1, ModElemental_plom, Instances, PartMatInterface]","category":"page"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.Internal_elt_vec","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.Internal_elt_vec","text":"Internaleltvec{T} <: Elt_vec{T}\n\nType that represents an internal element vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_internal_pv.Internal_pv","page":"Reference","title":"PartitionedStructures.M_internal_pv.Internal_pv","text":"Internaleltvec{T} <: Elt_vec{T}\n\nType that represents an internal element vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_internal_pv.rand_ipv-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.M_internal_pv.rand_ipv","text":"new_internal_pv(N,n;nᵢ,T)\n\nDefine an internal partitionned vector of N elemental nᵢ-sized vector simulating a n-sized T-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_vec.Elt_vec","page":"Reference","title":"PartitionedStructures.M_elt_vec.Elt_vec","text":"Abstract type representing element vectors.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_ev.Elemental_elt_vec","page":"Reference","title":"PartitionedStructures.ModElemental_ev.Elemental_elt_vec","text":"Elementaleltvec{T} <: Elt_vec{T}\n\nType that represents an elemental element vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_ev.create_eev-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.create_eev","text":"create_eev(vector_indices)\n\nCreate a random elemental element vector from vector_indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.eev_from_sparse_vec-Union{Tuple{SparseArrays.SparseVector{T, Y}}, Tuple{Y}, Tuple{T}} where {T, Y}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.eev_from_sparse_vec","text":"eev_from_sparse_vec(sparse_vec)\n\neevfromsparsevec is an interface with SparseArrays.SparseVector. The indices and the values of the elemental element vector are define using findnz(sparsevec).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.new_eev-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.new_eev","text":"new_eev(nie; T, n)\n\nCreate an elemental element vector, with nie randoms values placed at indices within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.ones_eev-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.ones_eev","text":"ones_eev(nie; T, n)\n\nCreate an elemental element vector, with nie values at 1 placed at indices within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.sparse_vec_from_eev-Union{Tuple{Elemental_elt_vec{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_ev.sparse_vec_from_eev","text":"sparse_vec_from_eev(eev)\n\nCreate a sparse vector from the element element vector eev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.specific_ones_eev-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.specific_ones_eev","text":"specific_ones_eev(nie, index; T, mul)\n\nCreate an elemental element vector, with nie randoms values multiplied by mul placed at indices in range index:index+nie, with .\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.Elemental_pv","page":"Reference","title":"PartitionedStructures.ModElemental_pv.Elemental_pv","text":"Elementalpv{T} <: Partv{T}\n\nType that represents an elemental partitioned vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{Elemental_pv}","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.initialize_component_list!","text":"initialize_component_list!(epm)\n\ninitializecomponentlist! Build for each index i (∈ {1,...,n}) the list of the blocs using i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.build_v!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_v.build_v!","text":"build_v!(pv)\n\nBuild from pv the vector v according to the information of each {evᵢ}ᵢ\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.add_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.add_epv!","text":"add_epv!(epv1,epv2)\n\nBuild in place of epv2 the addition of epv1 and epv2. Concretely each corresponding elemental vector will be add. \n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.create_epv-Union{Tuple{Array{SparseArrays.SparseVector{T, Y}, 1}}, Tuple{Y}, Tuple{T}} where {T, Y}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.create_epv","text":"create_elemental_pv(elt_ev_set)\n\ncreate an elemental partitioned vector from a collection (vector) of: sparse vector, elemental element vector or a vector of indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.epv_from_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.epv_from_epv!","text":"epv_from_epv!(evp1, epv2)\n\nSet the elemental partitioned vector epv1 to epv2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.epv_from_v!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.epv_from_v!","text":"epv_from_v!(epv, x)\n\nSet the values of the element partitioned vector epv to x. Usefull to define Uᵢ x, ∀ x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.epv_from_v-Union{Tuple{T}, Tuple{Vector{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.epv_from_v","text":"epv_from_v(x, epv)\n\nDefine a new elemental partitioned vector from x that have the same structure than epv. The value of each elemental element vector comes from the corresponding indices of x. Usefull to define Uᵢ x, ∀ x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.minus_epv!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.minus_epv!","text":"minus_epv!(epv)\n\nBuild in place the -epv, by inversing the value of each elemental element vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.ones_kchained_epv-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.ones_kchained_epv","text":"ones_kchained_epv(N, k; T)\n\nConstruct a N-partitionned k-sized vector such as n = N+k.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.rand_epv-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.rand_epv","text":"new_elemental_pv(N,n;nᵢ,T)\n\nDefine an elemental partitionned vector of N elemental nᵢ-sized vector simulating a n-sized T-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.set_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Array{Vector{T}, 1}}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.set_epv!","text":"set_epv!(epv, vec_value_eev)\n\nSet the values of the elemental element vectors of epv to the components of vec_value_eev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.Counter_elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.Counter_elt_mat","text":"Counter_elt_mat\n\nCount for a element matrix the update performed on it, from its definition. total_update + total_reset + total_untouched == iter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.DenseEltMat","page":"Reference","title":"PartitionedStructures.M_elt_mat.DenseEltMat","text":"Abstract type representing a dense element matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.Elt_mat","text":"Abstract type representing an element matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.LOEltMat","page":"Reference","title":"PartitionedStructures.M_elt_mat.LOEltMat","text":"Abstract type representing a element linear operator\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_Bie-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_Bie","text":"get_Bie(elt_mat)\n\nReturns the element matrix elt_mat.Bie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_cem-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_cem","text":"get_cem(elt_mat)\n\nReturns the Counter_elt_mat of the elemental element matrix elt_mat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_counter_elt_mat-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_counter_elt_mat","text":"get_counter_elt_mat(elt_mat)\n\nReturns the Counter_elt_mat of the elemental element matrix elt_mat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.iter_info-Tuple{Counter_elt_mat}","page":"Reference","title":"PartitionedStructures.M_elt_mat.iter_info","text":"iter_info(cem)\n\nReturns the information about the last quasi-Newton update applied onto the element associated to the counter cem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.total_info-Tuple{Counter_elt_mat}","page":"Reference","title":"PartitionedStructures.M_elt_mat.total_info","text":"iter_info(cem)\n\nReturns the informations about all the quasi-Newton updates applied onto the element associated to the counter cem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.update_counter_elt_mat!-Tuple{Counter_elt_mat, Int64}","page":"Reference","title":"PartitionedStructures.M_elt_mat.update_counter_elt_mat!","text":"update_counter_elt_mat!(cem, qn)\n\nUpdates the cem counter given the index qn from the quasi-Newton update.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.Part_LO_mat","text":"Abstract type representing partitioned matrix using linear operators\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_mat.Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.Part_mat","text":"Abstract type representing partitioned matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_mat.get_ee_struct_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_ee_struct_Bie","text":"get_ee_struct_Bie(pm, i)\n\nReturns the i-th elemental element matrix of the partitioned matrix pm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_permutation-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_permutation","text":"get_permutation(pm)\n\nGets the current permutation of the partitioned matrix pm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_spm-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_spm","text":"get_spm(pm)\n\nget_spm(pm, i, j)\n\nGet either the sparse matrix associated to the partitioned matrix pm or pm[i,j].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.hard_reset_L!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.hard_reset_L!","text":"hard_reset_L!(pm)\n\nReset the sparse matrix pm.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.hard_reset_spm!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.hard_reset_spm!","text":"hard_reset_spm!(pm)\n\nReset the sparse matrix pm.spm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.reset_L!-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.M_part_mat.reset_L!","text":"reset_L!(pm)\n\nSet the elements of sparse matrix pm.L to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.reset_spm!-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.M_part_mat.reset_spm!","text":"reset_spm!(pm)\n\nSet the elements of sparse matrix pm.spm to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_permutation!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.set_permutation!","text":"get_permutation(pm, perm)\n\nSet the permutation of the partitioned matrix pm to perm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.Part_v","text":"Abstract type representing partitioned vectors.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_v.add_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Int64, Y}} where {Y, T<:Part_v{Y}}","page":"Reference","title":"PartitionedStructures.M_part_v.add_v!","text":"add_v!(pv, i, value)\n\nadd_v!(pv, indices, values)\n\nAdd value (resp values) to the vector associated to the partitioned vector pv.v at the indice i (resp indices).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.build_v-Tuple{T} where T<:Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.build_v","text":"build_v(pv)\n\nBuild the vector v from the partitionned vector pv. Call specialised method depending the type of the element vector inside pv For now if there is mix of elemental and internal element vectors it must be previously transform as internal partitioned vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.set_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y, T<:Part_v{Y}}","page":"Reference","title":"PartitionedStructures.M_part_v.set_v!","text":"set_v!(pv, vec)\n\nset_v!(pv, index, value)\n\nSet to value the vector associated to the partitioned vector pv.v at the indice index. Set to vec the vector associated to the partitioned vector pv.v.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.Elemental_pm","page":"Reference","title":"PartitionedStructures.ModElemental_pm.Elemental_pm","text":"Elementalpm{T} <: Partmat{T}\n\nType that represents an elemental partitioned quasi-Newton linear operator, each Bᵢ may use a BFGS or SR1 update.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.permute!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T","page":"Reference","title":"Base.permute!","text":"permute!(epm, p)\n\nApply the permutation p to the elemental partitionned matrix epm. The permutation is applied to each elemental element matrice eem via indices. The current epm permutation is stored in epm.permutation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"get_ee_struct(epm)\n\nReturns the vector of every elemental element matrix epm.eem_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"get_ee_struct(epm, i)\n\nReturns the i-th elemental element matrix epm.eem_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{Elemental_pm}","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.initialize_component_list!","text":"initialize_component_list!(epm)\n\nBuild for each index i (∈ {1, ..., n}) a list of the elements using the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_spm!-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.set_spm!","text":"set_spm!(epm)\n\nBuild the sparse matrix of eplom in eplom.spm from the blocs eplom.eelom_set.  The sparse matrix is build according to the indices of each elemental element linear operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.correlated_var-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.correlated_var","text":"correlated_var(epm, i)\n\nGets the variables that appears in the same elements than the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_L-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_L","text":"get_L(epm)\n\nReturns the sparse matrix epm.L, whose aim to store a cholesky factor. By default epm.L is not instantiate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_L-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_L","text":"get_L(epm, i, j)\n\nReturns the value epm.L[i,j], from the sparse matrix epm.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_set","text":"get_eem_set(epm)\n\nReturns the vector of every elemental element matrix epm.eem_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_set","text":"get_eem_set(epm :: Elemental_pm_bfgs{T}, i :: Int)\n\nReturns the i-th elemental element matrix epm.eem_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_set_Bie-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_set_Bie","text":"get_eem_set_Bie(epm, i)\n\nGet the linear operator of the i-th elemental element linear operator of epm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_sub_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_sub_set","text":"get_eem_set_Bie(epm, indices)\n\nReturns a subset of the elemental element matrix composing epm. indices selects the differents elemental element matrix needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.identity_epm","text":"identity_epm(N, n; T=T, nie)\n\nCreate a partitionned matrix of type T of N identity elemental element matrices. Each elemental element matrix is of size nie with randoms positions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Vector{Vector{Int64}}, Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.identity_epm","text":"identity_epm(element_variables, N, n; T=T)\n\nCreate a partitionned matrix of type T of N identity elemental element matrices. The elemental variables are based from the indices informed in element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Vector{Vector{Int64}}}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.identity_epm","text":"identity_epm(element_variables; N, n, T=T)\n\nCreate a partitionned matrix of type T of N identity elemental element matrices. N and n are extrapolate from element_variables. The elemental variables are based from the indices informed in element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.n_i_SPS-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.n_i_SPS","text":"n_i_SPS(n; T, nie, overlapping, mul)\n\nDefines an elemental partitioned matrix of size n. The partitioned matrix is composed by N ≈ (n/nie)*2 elemental element matrices, of size nie, overlapping onto the diagonal. The diagonal terms of each elemental element matrix are of value mul.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.n_i_sep-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.n_i_sep","text":"n_i_sep(n; T=T, nie=nie, mul=mul)\n\nDefine a partitioned nie bloc separable matrix. Each elemental element matrix is composed of 1 except the diagonal terms which are of value mul.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.ones_epm-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.ones_epm","text":"ones_epm(N, n; T=T, nie=nie)\n\nCreate a partitionned matrix of type T of N elemental element matrices ones(nie, nie) whose positions are random. The partitionned matrix created may be singular.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.ones_epm_and_id-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.ones_epm_and_id","text":"ones_epm_and_id(N, n; T=T, nie=nie)\n\nCreate a partitionned matrix of type T with N+n elemental element matrices. Each elemental element matrice is ones(nie, nie) with randoms positions in the range 1:n. The remaining n elemental element matrices are of size 1, with value [1], they are placed in the diagonal terms. This way, the partitionned matrix is generally not singular.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.part_mat-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.part_mat","text":"part_mat(;n=n, T=T, nie=nie, overlapping=overlapping, mul=mul)\n\nDefine a elemental partitioned matrix formed by N (deduced from n and nie) elemental element matrices of size nie. Each elemental element matrix overlaps the previous one and the next one by overlapping.\t\t\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.set_L!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64, Int64, T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.set_L!","text":"set_L!(epm, i, j, value)\n\nSets the value of epm.L[i,j] = value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.set_L_to_spm!-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.set_L_to_spm!","text":"set_L_to_spm!(epm, i, j, value)\n\nSets the sparse matrix epm.L to the sparse matrix epm.spm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.Elemental_em","page":"Reference","title":"PartitionedStructures.ModElemental_em.Elemental_em","text":"Elemental_em{T} <: DenseEltMat{T}\n\nType that represents an elemental element matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.permute!-Union{Tuple{T}, Tuple{Elemental_em{T}, Vector{Int64}}} where T","page":"Reference","title":"Base.permute!","text":"permute!(eem, p)\n\nSet the indices of the element variables of eem to p. Must be use with caution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.create_id_eem-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_em.create_id_eem","text":"create_id_eem(elt_var; T=T)\n\nCreates a nie identity elemental element matrix of type T at the indices elt_var.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.fixed_ones_eem-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.fixed_ones_eem","text":"fixed_ones_eem(index, nie; type=T, mul=mul)\n\nCreates a nie elemental element matrix of type T at indices index:index+nie-1. All the components of the element matrix are set to 1 except the diagonal terms that are set to mul. This method is used to define diagonal dominant element matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.identity_eem-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.identity_eem","text":"identity_eem(nie; T=T, n=n)\n\nCreates a nie identity elemental element matrix of type T from nie random indices in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.one_size_bloc-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.one_size_bloc","text":"one_size_bloc(index)\n\nDefines an elemental element matrix of type T of size one at index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.ones_eem-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.ones_eem","text":"ones_eem(nie; T=T, n=n)\n\nCreates a nie ones elemental element matrix of type T from nie random indices in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_okoubi_koko.okoubi!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.M_okoubi_koko.okoubi!","text":"okoubi!(epm, epv, epv_tmp, res)\n\nSolve the partitioned linear problem using the Okoubi and Koko method described in the paper available at https://doi.org/10.1007/s11590-016-1020-x. This method avoid the allocation of epv_tmp and res.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_okoubi_koko.okoubi-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.M_okoubi_koko.okoubi","text":"okoubi(epm, epv)\n\nSolve the partitioned linear problem from epm and epv using the Okoubi and Koko method described in the paper available at https://doi.org/10.1007/s11590-016-1020-x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_frontale.frontale!-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_frontale.frontale!","text":"frontale!(epm)\n\nProduce the Cholesky factorization of the elemental partitioned matrix epm using a frontal method. The sparse factor L is stored in epm.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_1_parallel.subproblem-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}, Vector{Int64}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_1_parallel.subproblem","text":"subproblem(epm_A, epv_b, epv_x, comp_list, i)\n\ndefine the subproblem which must be solve for the i-th variable\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_2_parallel.subproblem!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}, Int64, Vector{Bool}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.M_2_parallel.subproblem!","text":"subproblem(epm_A, epv_b, epv_x, comp_list, i)\n\ndefine the subproblem which must be solve for the i-th variable\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_3_parallel.subproblem3!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}, Int64, Vector{Bool}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.M_3_parallel.subproblem3!","text":"subproblem(epm_A, epv_b, epv_x, comp_list, i)\n\ndefine the subproblem which must be solve for the i-th variable\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.BFGS-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.BFGS","text":"BFGS(s, y, B)\n\nPerform the BFGS update over the matrix B by using the vector s and y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SE-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SE","text":"SE(s, y, B)\n\nPerform either the BFGS update or SR1 over the matrix B by using the vector s and y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SR1-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SR1","text":"SR1(s, y, B)\n\nPerform the BFGS update over the matrix B by using the vector s and y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.eplom_lbfgs_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Elemental_pv{Y}}","page":"Reference","title":"PartitionedStructures.Link.eplom_lbfgs_from_epv","text":"eplom = eplom_lbfgs_from_epv(epv)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator PLBFGS eplom with the same partitioned structure than epv. Each element linear operator of eplom is set to a LBFGSOperator of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.eplom_lose_from_epv-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.Link.eplom_lose_from_epv","text":"\teplom = eplom_lose_from_epv(epv)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator PLSR1 eplom with the same partitioned structure than epv. Each element linear operator of eplom is set to a LBFGSOperator of suitable size, but it may change to LSR1Operator later on.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.eplom_lsr1_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Elemental_pv{Y}}","page":"Reference","title":"PartitionedStructures.Link.eplom_lsr1_from_epv","text":"\teplom = eplom_lsr1_from_epv(epv)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator PLSR1 eplom with the same partitioned structure than epv. Each element linear operator of eplom is set to a LBFGSOperator of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.epm_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Elemental_pv{Y}}","page":"Reference","title":"PartitionedStructures.Link.epm_from_epv","text":"epm = epm_from_epv(epv)\n\nCreate an elemental partitioned quasi-Newton operator epm with the same partitioned structure than epv. Each element matrix of epm is set with an identity matrix of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.epv_from_epm-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.epv_from_epm","text":"epv = epv_from_epm(epm)\n\nCreate an elemental partitioned vector epv with the same partitioned structure than epm. Each element vector of epv is set to a random vector of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_epv!-Union{Tuple{T}, Tuple{Y}, Tuple{Elemental_pv{Y}, T, Elemental_pv{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_epv!","text":"mul_epm_epv!(epv_res, epm, epv)\n\nCompute the product between the elemental partitioned matrix epm and the elemental partitioned vector epv.\t The result of each element matrix vector product is stored in the elemental partitioned vector epv_res.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_epv-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_epv","text":"mul_epm_epv(epm, epv)\n\nCompute the product between the elemental partitioned matrix epm and the elemental partitioned vector epv.\t\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_vector!-Union{Tuple{T}, Tuple{Y}, Tuple{Vector{Y}, T, Elemental_pv{Y}, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_vector!","text":"mul_epm_vector!(res, epm, epv, x)\n\nCompute the product between the elemental partitioned matrix epm and the vector x using temporary the elemental partitioned vector epv. The result is stored in the vector res.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_vector!-Union{Tuple{T}, Tuple{Y}, Tuple{Vector{Y}, T, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_vector!","text":"mul_epm_vector!(res, epm, x)\n\nIt computes the product between the elemental partitioned matrix epm and the vector x. The result is stored in the vector res.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_vector-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_vector","text":"\tresult = mul_epm_vector!(epm, epv, x)\n\nIt computes the product between the elemental partitioned matrix epm and the vector x using temporary the elemental partitioned vector epv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_vector-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_vector","text":"result = mul_epm_vector(epm, x)\n\nIt computes the product between the elemental partitioned matrix epm <: Part_mat and the vector x. The method return the vector result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.string_counters_iter-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.Link.string_counters_iter","text":"string_counters_iter(pm)\n\nProduces a string that summarize the partitioned update applied onto pm at the last iterate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.string_counters_total-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.Link.string_counters_total","text":"string_counters_total(pm)\n\nProduces a string that summarize the partitioned update applied onto pm from its allocation at the start of an algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!","text":"\tPBFGS_update!(epm_B, epv_y, epv_s)\n\nPerforms the partitioned BFGS update onto the partitioned matrix epm_B, given the element steps epv_s and the element gradient differences epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PBFGS_update","text":"\tB = PBFGS_update(epm_B, epv_y, s)\n\nPerforms the partitioned BFGS update onto the partitioned matrix epm_B, given the step s and the element gradient difference epv_y\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSE_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSE_update!","text":"\tPSE_update!(epm_B, epv_y, epv_s)\n\nPerforms the partitioned update PSE of the elemental partitioned matrix epm_B, given the element steps epv_s and the element gradient differences epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSE_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSE_update","text":"\tB = PSE_update(epm_B, epv_y, s)\n\nPerforms the partitioned update PSE of the elemental partitioned matrix epm_B, given the step s and the element gradient difference epv_y\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSR1_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSR1_update!","text":"\tPSR1_update!(epm_B, epv_y, s)\n\nPerforms the partitioned-SR1 update of the elemental partitioned matrix epm_B, given the element steps epv_s and the element gradient differences epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSR1_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSR1_update","text":"\tB = PSR1_update(epm_B, epv_y, s)\n\nPerforms the partitioned SR1 update of the elemental partitioned matrix epm_B, given the step s and the element gradient difference epv_y\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!-Union{Tuple{T}, Tuple{Elemental_plom_bfgs{T}, Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!","text":"PLBFGS_update!(eplom_B, s, epv_y)\n\nPerforms the partitioned-LBFGS update onto the limited-memory partitioned operator eplom_B, given the element steps epv_s and the element gradient differences epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update-Union{Tuple{T}, Tuple{Elemental_plom_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update","text":"B = PLBFGS_update(eplom_B, s, epv_y)\n\nPerforms the partitioned-LBFGS update onto the limited-memory partitioned operator eplom_B, given the step s and the element gradient differences epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Elemental_pv{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!","text":"PLSE_update!(eplom_B, epv_y, epv_s)\n\nPerforms the partitionned update PLSE of eplom_B, which is made of LBFGS or LSR1 elemental element matrices, given the element steps epv_s and the element gradient differences epv_y. The update try to apply a LBFGS update to every Bᵢ, but if the curvature condition yᵢᵀs > 0 is not satisfied it applies LSR1 in place of LBFGS.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update","text":"B = PLSE_update(eplom_B, epv_y, s)\n\nPerforms the partitionned update PLSE of eplom_B, which is made of LBFGS or LSR1 elemental element matrices, given the step s and the element gradient differences epv_y. The update try to apply a LBFGS update to every Bᵢ, but if the curvature condition yᵢᵀs > 0 is not satisfied it applies LSR1 in place of LBFGS.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!-Union{Tuple{T}, Tuple{Elemental_plom_sr1{T}, Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!","text":"PLSR1_update!(eplom_B, s, epv_y)\n\nPerforms the partitioned-SR1 update onto the limited-memory partitioned operator eplom_B, given the element steps epv_s and the element gradient differences epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update-Union{Tuple{T}, Tuple{Elemental_plom_sr1{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update","text":"B = PLSR1_update(eplom_B, s, epv_y)\n\nPerforms the partitioned-SR1 update onto the limited-memory partitioned operator eplom_B, given the step s and the element gradient differences epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.Part_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Elemental_pv{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.Part_update!","text":"Part_update!(eplom_B, epv_y, s)\n\nPerforms a quasi-Newton partitionned update of eplom_B, given the element steps epv_s and the element gradient differences epv_y. Each element linear operator from eplom_B is either a LBFGSOperator or LSR1Operator. The update performs on each element the quasi-Newton to the linear operator associated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.Part_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.Part_update","text":"B = Part_update(eplom_B, epv_y, s)\n\nPerforms a quasi-Newton partitionned update of eplom_B, given the step s and the element gradient differences epv_y. Each element linear operator from eplom_B is either a LBFGSOperator or LSR1Operator. The update performs on each element the quasi-Newton to the linear operator associated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elom_bfgs.Elemental_elom_bfgs","page":"Reference","title":"PartitionedStructures.ModElemental_elom_bfgs.Elemental_elom_bfgs","text":"Elemental_elom_bfgs{T} <: LOEltMat{T}\n\nType that represents an elemental element linear operator LBFGS\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_elom_bfgs.LBFGS_eelom-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elom_bfgs.LBFGS_eelom","text":"LBFGS_eelom(nie; T=T, index=index)\n\nCreates an Elemental_elom_bfgs of type T of size nie, the indices are all the values in the range index:index+nie-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elom_bfgs.LBFGS_eelom_rand-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elom_bfgs.LBFGS_eelom_rand","text":"LBFGS_eelom_rand(nie; T=T, n=n)\n\nCreates an Elemental_elom_bfgs of type T with nie random indices within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elom_bfgs.init_eelom_LBFGS-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_elom_bfgs.init_eelom_LBFGS","text":"init_eelom_LBFGS(elt_var; T=T)\n\nDefines an Elemental_elom_bfgs of type T based from the vector of indices elt_var.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elom_bfgs.reset_eelom_bfgs!-Union{Tuple{Elemental_elom_bfgs{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_elom_bfgs.reset_eelom_bfgs!","text":"reset_eelom_bfgs!(eelom)\n\nResets the LBFGS linear operator of the elemental element linear operator matrix eelom.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.Elemental_plom_bfgs","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.Elemental_plom_bfgs","text":"Elemental_plom_bfgs{T} <: Part_LO_mat{T}\n\nType that represents an elemental limited-memory partitioned quasi-Newton operator PLBFGS.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{Elemental_plom_bfgs{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"get_ee_struct(eplom)\n\nReturns the vector of every elemental element linear operator eplom.eelom_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{T}, Tuple{Elemental_plom_bfgs{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"get_ee_struct(eplom, i)\n\nReturns the i-th elemental element linear operator eplom.eelom_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{Elemental_plom_bfgs}","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.initialize_component_list!","text":"initialize_component_list!(eplom)\n\nBuild for each index i (∈ {1, ..., n}) a list of the elements using the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelom_set-Union{Tuple{Elemental_plom_bfgs{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelom_set","text":"get_eelom_set(eplom)\n\nReturns the vector of every elemental element linear operator eplom.eelom_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelom_set-Union{Tuple{T}, Tuple{Elemental_plom_bfgs{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelom_set","text":"get_eelom_set(eplom :: Elemental_plom_bfgs{T}, i :: Int)\n\nReturns the i-th elemental element linear operator eplom.eelom_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_spm!-Union{Tuple{Elemental_plom_bfgs{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.set_spm!","text":"set_spm!(eplom)\n\nBuild the sparse matrix of eplom in eplom.spm from the blocs eplom.eelom_set.  The sparse matrix is build according to the indices of each elemental element linear operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.PLBFGS_eplom-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.PLBFGS_eplom","text":"PLBFGS_eplom(;n, type, nie, overlapping)\n\nCreates an elemental partitionned limited-memory operator PLBFGS of N (deduced from n and nie) elemental element linear operators. Each element overlaps the coordinates of the next element by overlapping components.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.PLBFGS_eplom_rand-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.PLBFGS_eplom_rand","text":"PLBFGS_eplom_rand(N, n; type, nie)\n\nCreate an elemental partitionned limited-memory operator PLBFGS of N elemental element linear operators. The size of each element is nie, whose positions are random in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.get_L-Union{Tuple{Elemental_plom_bfgs{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.get_L","text":"get_L(eplom)\n\nReturns the sparse matrix eplom.L, whose aim to store a cholesky factor. By default eplom.L is not instantiate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.get_L-Union{Tuple{T}, Tuple{Elemental_plom_bfgs{T}, Int64, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.get_L","text":"get_L(eplom, i, j)\n\nReturns the value eplom.L[i,j], from the sparse matrix eplom.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.get_eelom_set_Bie-Union{Tuple{T}, Tuple{Elemental_plom_bfgs{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.get_eelom_set_Bie","text":"get_eelom_set_Bie(eplom, i)\n\nGet the linear operator of the i-th elemental element linear operator of eplom.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.get_eelom_sub_set-Union{Tuple{T}, Tuple{Elemental_plom_bfgs{T}, Vector{Int64}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.get_eelom_sub_set","text":"get_eelom_set_Bie(eplom, indices)\n\nReturns a subset of the elemental element linear operators composing eplom. indices selects the differents elemental element linear operators needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.identity_eplom_LBFGS-Tuple{Vector{Vector{Int64}}, Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.identity_eplom_LBFGS","text":"identity_eplom_LBFGS(element_variables, N, n; T=T)\n\nCreates an elemental partitionned limited-memory operator PLBFGS of N elemental element linear operators. The positions are given by the vector of the element variables element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.set_L!-Union{Tuple{T}, Tuple{Elemental_plom_bfgs{T}, Int64, Int64, T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.set_L!","text":"set_L!(eplom, i, j, value)\n\nSets the value of eplom.L[i,j] = value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_bfgs.set_L_to_spm!-Union{Tuple{Elemental_plom_bfgs{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_bfgs.set_L_to_spm!","text":"set_L_to_spm!(eplom, i, j, value)\n\nSets the sparse matrix eplom.L to the sparse matrix eplom.spm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elom_sr1.Elemental_elom_sr1","page":"Reference","title":"PartitionedStructures.ModElemental_elom_sr1.Elemental_elom_sr1","text":"Elemental_elom_sr1{T} <: LOEltMat{T}\n\nType that represents an elemental element linear operator LSR1\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_elom_sr1.LSR1_eelom-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elom_sr1.LSR1_eelom","text":"LSR1_eelom(nie, T=T, index=index)\n\nCreates an Elemental_elom_sr1 of type T of size nie, the indices are all the values in the range index:index+nie-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elom_sr1.LSR1_eelom_rand-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elom_sr1.LSR1_eelom_rand","text":"LSR1_eelom_rand(nie, T=T, n=n)\n\nCreates an Elemental_elom_sr1 of type T with nie random indices within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elom_sr1.init_eelom_LSR1-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_elom_sr1.init_eelom_LSR1","text":"init_eelom_LSR1(elt_var; T=T)\n\nDefines an Elemental_elom_sr1 of type T based from the vector of indices elt_var.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elom_sr1.reset_eelom_sr1!-Union{Tuple{Elemental_elom_sr1{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_elom_sr1.reset_eelom_sr1!","text":"index_eelom_sr1!(eelom)\n\nResets the LSR1 linear operator of the elemental element linear operator matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.Elemental_plom_sr1","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.Elemental_plom_sr1","text":"\tElemental_plom_sr1{T} <: Part_LO_mat{T}\n\nType that represents an elemental limited-memory partitioned quasi-Newton operator PLSR1.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{Elemental_plom_sr1{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"get_ee_struct(eplom)\n\nReturns the vector of every elemental element linear operator eplom.eelom_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{T}, Tuple{Elemental_plom_sr1{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"get_ee_struct(eplom, i)\n\nReturns the i-th elemental element linear operator eplom.eelom_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{Elemental_plom_sr1}","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.initialize_component_list!","text":"\tinitialize_component_list!(eplom)\n\nBuild for each index i (∈ {1, ..., n}) a list of the elements using the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelom_set-Union{Tuple{Elemental_plom_sr1{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelom_set","text":"get_eelom_set(eplom)\n\nReturns the vector of every elemental element linear operator eplom.eelom_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelom_set-Union{Tuple{T}, Tuple{Elemental_plom_sr1{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelom_set","text":"get_eelom_set(eplom :: Elemental_plom_bfgs{T}, i :: Int)\n\nReturns the i-th elemental element linear operator eplom.eelom_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_spm!-Union{Tuple{Elemental_plom_sr1{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.set_spm!","text":"\tset_spm!(eplom)\n\nBuild the sparse matrix of eplom in eplom.spm from the blocs eplom.eelom_set.  The sparse matrix is build according to the indices of each elemental element linear operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.PLSR1_eplom-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.PLSR1_eplom","text":"\tPLSR1_eplom(N, n; type, nie)\n\nCreates an elemental partitionned limited-memory operator PLSR1 of N (deduced from n and nie) elemental element linear operators. Each element overlaps the coordinates of the next element by overlapping components.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.PLSR1_eplom_rand-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.PLSR1_eplom_rand","text":"\tPLSR1_eplom_rand(N, n; type, nie)\n\nCreate an elemental partitionned limited-memory operator PLSR1 of N elemental element linear operators. The size of each element is nie, whose positions are random in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.get_L-Union{Tuple{Elemental_plom_sr1{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.get_L","text":"get_L(eplom)\n\nReturns the sparse matrix eplom.L, whose aim to store a cholesky factor. By default eplom.L is not instantiate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.get_L-Union{Tuple{T}, Tuple{Elemental_plom_sr1{T}, Int64, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.get_L","text":"get_L(eplom, i, j)\n\nReturns the value eplom.L[i,j], from the sparse matrix eplom.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.get_eelom_set_Bie-Union{Tuple{T}, Tuple{Elemental_plom_sr1{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.get_eelom_set_Bie","text":"get_eelom_set_Bie(eplom, i)\n\nGet the linear operator of the i-th elemental element linear operator of eplom.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.get_eelom_sub_set-Union{Tuple{T}, Tuple{Elemental_plom_sr1{T}, Vector{Int64}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.get_eelom_sub_set","text":"get_eelom_set_Bie(eplom, indices)\n\nReturns a subset of the elemental element linear operators composing eplom. indices selects the differents elemental element linear operators needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.identity_eplom_LSR1-Tuple{Vector{Vector{Int64}}, Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.identity_eplom_LSR1","text":"\tidentity_eplom_LSR1(vec_indices, N, n; T=T)\n\nCreates an elemental partitionned limited-memory operator PLSR1 of N elemental element linear operators. The positions are given by the vector of the element variables element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.set_L!-Union{Tuple{T}, Tuple{Elemental_plom_sr1{T}, Int64, Int64, T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.set_L!","text":"set_L!(eplom, i, j, value)\n\nSets the value of eplom.L[i,j] = value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom_sr1.set_L_to_spm!-Union{Tuple{Elemental_plom_sr1{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom_sr1.set_L_to_spm!","text":"set_L_to_spm!(eplom, i, j, value)\n\nSets the sparse matrix eplom.L to the sparse matrix eplom.spm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.Elemental_plom","page":"Reference","title":"PartitionedStructures.ModElemental_plom.Elemental_plom","text":"Elementalplomsr1{T} <: PartLOmat{T}\n\nType that represents an elemental limited-memory partitioned quasi-Newton linear operator, each Bᵢ may use a LBFGS or LSR1 linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{Elemental_plom{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"get_ee_struct(eplom)\n\nReturns the vector of every elemental element linear operator eplom.eelom_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{T}, Tuple{Elemental_plom{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"get_ee_struct(eplom, i)\n\nReturns the i-th elemental element linear operator eplom.eelom_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{Elemental_plom}","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.initialize_component_list!","text":"initialize_component_list!(eplom)\n\nBuild for each index i (∈ {1, ..., n}) a list of the elements using the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelom_set-Union{Tuple{Elemental_plom{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelom_set","text":"get_eelom_set(eplom)\n\nReturns the vector of every elemental element linear operator eplom.eelom_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelom_set-Union{Tuple{T}, Tuple{Elemental_plom{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelom_set","text":"get_eelom_set(eplom :: Elemental_plom_bfgs{T}, i :: Int)\n\nReturns the i-th elemental element linear operator eplom.eelom_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_eelom_set!-Union{Tuple{Y}, Tuple{T}, Tuple{Elemental_plom{T}, Int64, Y}} where {T, Y<:LOEltMat{T}}","page":"Reference","title":"PartitionedStructures.M_part_mat.set_eelom_set!","text":"set_eelom_set!(eplom, i, eelom)\n\nSets the i-th elemental elemental linear operator of eplom to eelom.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_spm!-Union{Tuple{Elemental_plom{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_mat.set_spm!","text":"set_spm!(eplom)\n\nBuild the sparse matrix of eplom in eplom.spm from the blocs eplom.eelom_set.  The sparse matrix is build according to the indices of each elemental element linear operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.PLBFGSR1_eplom-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_plom.PLBFGSR1_eplom","text":"PLBFGSR1_eplom(; n, type, nie, overlapping, prob)\n\nCreates an elemental partitionned limited-memory operator PLSE of N (deduced from n and nie) elemental element linear operators. Each element overlaps the coordinates of the next element by overlapping components. Each element is randomly (rand() > p) choose between an elemental element LBFGS operator or an elemental element LSR1 operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.PLBFGSR1_eplom_rand-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plom.PLBFGSR1_eplom_rand","text":"PLBFGS_eplom_rand(N,n; type, nie)\n\nCreate an elemental partitionned limited-memory operator PLSE of N elemental element linear operators. The size of each element is nie, whose positions are random in the range 1:n. Each element is randomly (rand() > p) choose between an elemental element LBFGS operator or an elemental element LSR1 operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.get_L-Union{Tuple{Elemental_plom{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom.get_L","text":"get_L(eplom)\n\nReturns the sparse matrix eplom.L, whose aim to store a cholesky factor. By default eplom.L is not instantiate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.get_L-Union{Tuple{T}, Tuple{Elemental_plom{T}, Int64, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom.get_L","text":"get_L(eplom, i, j)\n\nReturns the value eplom.L[i,j], from the sparse matrix eplom.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.get_eelom_set_Bie-Union{Tuple{T}, Tuple{Elemental_plom{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom.get_eelom_set_Bie","text":"get_eelom_set_Bie(eplom, i)\n\nGet the linear operator of the i-th elemental element linear operator of eplom.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.get_eelom_sub_set-Union{Tuple{T}, Tuple{Elemental_plom{T}, Vector{Int64}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom.get_eelom_sub_set","text":"get_eelom_set_Bie(eplom, indices)\n\nReturns a subset of the elemental element linear operators composing eplom. indices selects the differents elemental element linear operators needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.identity_eplom_LOSE-Tuple{Vector{Vector{Int64}}, Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plom.identity_eplom_LOSE","text":"identity_eplom_LOSE(vec_indices, N, n; T=T)\n\nCreates an elemental partitionned limited-memory operator of N elemental element linear operators initialized with LBFGS operators. The positions are given by the vector of the element variables element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.set_L!-Union{Tuple{T}, Tuple{Elemental_plom{T}, Int64, Int64, T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom.set_L!","text":"set_L!(eplom, i, j, value)\n\nSets the value of eplom.L[i,j] = value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plom.set_L_to_spm!-Union{Tuple{Elemental_plom{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_plom.set_L_to_spm!","text":"set_L_to_spm!(eplom, i, j, value)\n\nSets the sparse matrix eplom.L to the sparse matrix eplom.spm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_eplom-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_eplom","text":"(eplom,epv) = create_epv_eplom_sr1(;n=9,nie=5,overlapping=1, mul_v=100.)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator eplom and elemental partitioned vector epv. Both have the same partitioned structure defined by the size of the problem n, the size of the element nie and the overlapping between the consecutive element overlapping. Each elemental element linear operator is instantiated as a LBFGSOperator, but it may change to a LSR1Operator later on. Each elemental element vector is made from rand(nie) .* mul_v. Warning: You have to choose carefully the values n, nie and overlap otherwise the method may fail.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_eplom_bfgs-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_eplom_bfgs","text":"(eplom,epv) = create_epv_eplom_bfgs(;n=9,nie=5,overlapping=1, mul_v=100.)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator PLBFGS eplom and elemental partitioned vector epv. Both have the same partitioned structure defined by the size of the problem n, the size of the element nie and the overlapping between the consecutive element overlapping. Each elemental element linear operator is a LBFGSOperator. Each elemental element vector is made from rand(nie) .* mul_v. Warning: You have to choose carefully the values n, nie and overlap otherwise the method may fail.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_eplom_sr1-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_eplom_sr1","text":"(eplom,epv) = create_epv_eplom_sr1(;n=9,nie=5,overlapping=1, mul_v=100.)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator PLSR1 eplom and elemental partitioned vector epv. Both have the same partitioned structure defined by the size of the problem n, the size of the element nie and the overlapping between the consecutive element overlapping. Each elemental element linear operator is a LSR1Operator. Each elemental element vector is made from rand(nie) .* mul_v. Warning: You have to choose carefully the values n, nie and overlap otherwise the method may fail.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_epm-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_epm","text":"(epm,epv) = create_epv_epm(;n=9,nie=5,overlapping=1,mul_m=5., mul_v=100.)\n\nCreate an elemental partitioned matrix epm and elemental partitioned vector epv. Both have the same partitioned structure defined by the size of the problem n :: Int, the size of the element nie :: Int and the overlapping between the consecutives  element overlapping :: Int. Each elemental element matrix is fill with ones, except the terms of the diagonal which are of value mul_v :: Real. The value of each elemental element vector is made from rand(nie) .* mul_v :: Real. Warning: You have to choose carefully the values n, nie and overlap otherwise the method may fail.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_epm_rand-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_epm_rand","text":"(epm,epv) = create_epv_epm_rand(;n=9,nie=5,overlapping=1,range_mul_m=nie:2*nie, mul_v=100.)\n\nCreate an partitioned quasi-Newton operator epm and elemental partitioned vector epv. Both have the same partitioned structure defined by the size of the problem n :: Int, the size of the element nie :: Int and the overlapping between the consecutive element overlapping :: Int. Each elemental element matrix is fill with ones, except the terms of the diagonal which are a random value from rand(range_mul_v). Each elemental element vector is made from rand(nie) .* mul_v :: Real. Warning: You have to choose carefully the values n, nie and overlap otherwise the method may fail.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"\tupdate!(epm, epv_y, s)\n\nUpdate the elemental partitioned operator epm with a partitioned quasi-Newton update considering the difference of elemental partitioned gradients epv_y and the step s. The PSE update is run by default, you can apply a PBFGS or a PSR1 update with the optionnal argument name, respectively name=:pbfgs or name=:psr1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plom_bfgs{Y}, Elemental_pv{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"\tupdate(epm, epv_y, s)\n\nUpdate the limited-memory elemental partitioned operator eplom with the partitioned quasi-Newton update PLSR1 considering the difference of elemental partitioned gradients epv_y and the step s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plom_sr1{Y}, Elemental_pv{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"\tupdate(epm, epv_y, s)\n\nUpdate the limited-memory elemental partitioned operator eplom with the partitioned quasi-Newton update PLSR1 considering the difference of elemental partitioned gradients epv_y and the step s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plom{Y}, Elemental_pv{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"\tupdate!(epm, epv_y, s)\n\nUpdate the limited-memory elemental partitioned operator eplom with the partitioned quasi-Newton update PLSE considering the difference of elemental partitioned gradients epv_y and the step s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.PartMatInterface.update","text":"\tB = update(epm, epv_y, s)\n\nUpdate the elemental partitioned operator epm <: Part_mat with a partitioned quasi-Newton update considering the difference of elemental partitioned gradients epv_y and the step s. If epm is an elemental partitioned matrix, the PSE update is run by default. You can apply a PBFGS or a PSR1 update with the optionnal argument name, respectively name=:pbfgs or name=:psr1. It returns a matrix B formed from the updated epm.\n\n\n\n\n\n","category":"method"},{"location":"#PartitionedStructures.jl","page":"Home","title":"PartitionedStructures.jl","text":"","category":"section"},{"location":"tutorial/#PartitionedStructures.jl:-Tutorial","page":"Tutorial","title":"PartitionedStructures.jl: Tutorial","text":"","category":"section"},{"location":"tutorial/#Reminder-about-the-partially-separable-structure-and-partitioned-quasi-Newton-updates","page":"Tutorial","title":"Reminder about the partially separable structure and partitioned quasi-Newton updates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The quasi-Newton methods exploiting the partially separable function  $  f(x) = \\sum{i=1}^N \\hat{f}i (Ui) : \\R^n \\to \\R, $ where \\hat{f}i : \\R^{ni} \\to \\R, \\; Ui \\in \\R^{ni \\times n},\\; ni < n manipulate the partitioned derivatives   nabla f(x) = sum_i=1^N U_i^top hatf_i (U_i x) quad nabla^2 f(x) = sum_i=1^N U_i^top hatf_i (U_i x) U_i  which accumulate the element derivatives hatf_i and nabla^2 hatf_i to form nabla f and nabla^2 f.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These partitioned quasi-Newton methods define partitioned quasi-Newton approximations of the Hessian B approx nabla^2 f, such that B accumulate the element Hessian approximation hatB_i approx nabla^2 hatf_i with respect to U_i. $ B = \\sum{i=1}^N Ui^\\top \\hat{B}i Ui $ The partitioned quasi-Newton approximations structurally keep the sparsity structure of nabla^2 f, which is not the case of classical quasi-Newton approximation. Moreover, the rank of the partitioned updates may be proportional to the number of elements N, whereas classical quasi-Newton approximation are low rank updates. To perform a partitioned quasi-Newton update after a step s, you must update every element Hessian approximation hatB_i. Then, the update of each element requires hatB_i, U_i s and nabla hatf_i (U_i (x+s)) - nabla hatf_i (U_i x)","category":"page"},{"location":"tutorial/#Reference","page":"Tutorial","title":"Reference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A. Griewank and P. Toint, On the unconstrained optimization of partially separable functions, Numerische Nonlinear Optimization 1981, 39, pp. 301–312, 1982.","category":"page"},{"location":"tutorial/#The-partitioned-structure-of-a-quadratic","page":"Tutorial","title":"The partitioned structure of a quadratic","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's take the quadratic function f as an example ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x) = x[1]^2 + x[2]^2 + x[3]^2 + x[1]*x[2] + 3x[2]*x[3]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f can be considered as the sum of two element functions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f1(x) = x[1]^2 + x[1]*x[2]\nf2(x) = x[1]^2 + x[2]^2 + 3x[1]*x[2]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"considering","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U1 = [1, 2] # [1 0 0; 0 1 0] as a matrix\nU2 = [2, 3] # [0 1 0; 0 0 1] as a matrix","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"inform the variables required by each element function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By gathering the different U_i together","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U = [U1, U2]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we define the function f_pss = f exploiting the partially separable structure as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f_pss(x, U) = f1(x[U[1]]) + f2(x[U[2]])\n\nusing Test\nx0 = [2., 3., 4.]\n@test f(x0) == f_pss(x0, U)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, you can compute: the gradient, the element gradients and explicit how the gradient is partitioned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"∇f(x) = [2x[1] + x[2], x[1] + 2x[2] + 3x[3], 2x[3] + 3x[2]]\n∇f1(x) = [2x[1] + x[2], x[1]]\n∇f2(x) = [2x[1] + 3x[2], 2x[2] + 3x[1]]\nfunction ∇f_pss(x, U)\n  gradient = zeros(length(x))\n  gradient[U1] = ∇f1(x[U[1]])\n  gradient[U2] .+= ∇f2(x[U[2]])\n  return gradient\nend\n@test ∇f(x0) == ∇f_pss(x0, U)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"However, ∇f_pss accumulates directly the element gradient and does not store the value of each element gradients ∇f1, ∇f2. We would like to store every element gradient, such that afterward it is possible to build the difference element gradients required for the partitioned quasi-Newton update. We define the partitioned vector, from U and n, to store each element gradient and form the nabla f when required","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PartitionedStructures\nU = [U1, U2]\nn = length(x0)\npartitioned_gradient_x0 = create_epv(U, n) # creates the partitioned vector","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Elemental_pv{Float64}(2, 3, Elemental_elt_vec{Float64}[Elemental_elt_vec{Float64}([0.5582481752025726, 0.5536916309593504], [1, 2], 2), Elemental_elt_vec{Float64}([0.974556124813947, 0.8994868430015379], [2, 3], 2)], [0.0, 0.0, 0.0], [[1], [1, 2], [2]], [1, 2, 3])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We set the value of each element vector to the corresponding element gradient","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"vector_gradient_element(x, U) = [∇f1(x[U[1]]), ∇f2(x[U[2]])] :: Vector{Vector{Float64}} # returns every element gradient\nset_epv!(partitioned_gradient_x0, vector_gradient_element(x0, U)) # sets each element vector to its corresponding element gradient\n\nbuild_v!(partitioned_gradient_x0) # builds the gradient vector\n@test get_v(partitioned_gradient_x0) == ∇f(x0) # with the same value as the gradient","category":"page"},{"location":"tutorial/#Quasi-Newton-approximation-of-the-quadratic","page":"Tutorial","title":"Quasi-Newton approximation of the quadratic","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the case of the BFGS method, you want to approximate the Hessian matrix from s = x1 - x0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x1 = [1., 2., 3.]\ns = x1 .- x0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the gradient difference y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"y = (∇f(x1) .- ∇f(x0))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the approximation B, initially set to the identity","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B = [ i==j ? 1. : 0. for i in 1:n, j in 1:n]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By applying the BFGS update, you satisfy the secant equation Bs = y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_BFGS = BFGS(s,y,B) # PartitionedStructures.jl implements BFGS\n\nusing LinearAlgebra\t\t\n@test norm(B_BFGS * s - y) == 0. # numerical verification of the secant equation ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"but the approximation B_BFGS is dense.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_BFGS","category":"page"},{"location":"tutorial/#Partitioned-quasi-Newton-approximation-of-the-quadratic","page":"Tutorial","title":"Partitioned quasi-Newton approximation of the quadratic","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to make a sparse quasi-Newton approximation of nabla^2 f, you may define a partitioned matrix with the same partially separable structure than partitioned_gradient_x0 where each element matrix is set to the identity","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_matrix = epm_from_epv(partitioned_gradient_x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Matrix(partitioned_matrix)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The second term of the diagonal accumulates two 1.0 from the two initial element approximations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then you compute the partitioned gradient at x1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_gradient_x1 = create_epv(U, n)\nset_epv!(partitioned_gradient_x1, vector_gradient_element(x1, U))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and compute the difference of the partitioned gradients partitioned_gradient_difference = partitioned_gradient_x1 - partitioned_gradient_x0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_gradient_difference = copy(partitioned_gradient_x0) # copy to avoid side effects on partitioned_gradient_x0 \nminus_epv!(partitioned_gradient_difference) # applies a unary minus to every element gradient\nadd_epv!(partitioned_gradient_x1, partitioned_gradient_difference) # add the element vector of partitioned_gradient_x1 to the correspond element vector of partitioned_gradient_difference, add partitioned_gradient_x1 to partitioned_gradient_difference\n\nbuild_v!(partitioned_gradient_difference) # computes the vector y\n@test get_v(partitioned_gradient_difference) == y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then you can define the partitioned quasi-Newton update PBFGS","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_PBFGS = update(partitioned_matrix, partitioned_gradient_difference, s; name=:pbfgs) # applies the partitioned update PBFGS to partitioned_matrix and returns Matrix(partitioned_matrix)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":" B_PBFGS","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which keeps the sparsity structure of nabla^2 f.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition, update() informs the number of element: updated, not updated or untouched, as long as the user don't set verbose=false. The partitioned update verifies the secant equation","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@test norm(B_PBFGS*s - y) == 0.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which may also be calculated with ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Bs = mul_epm_vector(partitioned_matrix, s) # compute the product partitioned-matrix vector\n@test norm(Bs - y) == 0.","category":"page"},{"location":"tutorial/#Other-partitioned-quasi-Newton-approximation","page":"Tutorial","title":"Other partitioned quasi-Newton approximation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There exist two categories of partitioned quasi-Newton updates. In the first category, each element Hessian is approximate with a dense matrix, for example: PBFGS. In the second category, each element Hessian is approximate with a quasi-Newton linear operator.","category":"page"},{"location":"tutorial/#Partitioned-quasi-Newton-operators","page":"Tutorial","title":"Partitioned quasi-Newton operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the partitioned matrix is allocated, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_matrix_PBFGS = epm_from_epv(partitioned_gradient_x0)\npartitioned_matrix_PSR1 = epm_from_epv(partitioned_gradient_x0)\npartitioned_matrix_PSE = epm_from_epv(partitioned_gradient_x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"you can apply on it any of the three partitioned updates : PBFGS, PSR1, PSE (by default) : ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PBFGS update each element approximation with BFGS;\nPSR1 update each element approximation with SR1;\nPSE update each element approximate with BFGS if it is possible or with SR1 otherwise.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_PBFGS = update(partitioned_matrix_PBFGS, partitioned_gradient_difference, s; name=:pbfgs)\nB_PSR1 = update(partitioned_matrix_PSR1, partitioned_gradient_difference, s; name=:psr1)\nB_PSE = update(partitioned_matrix_PSE, partitioned_gradient_difference, s) # ; name=:pse by default","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All these methods satisfy the secant equation as long as every element approximation is update","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@test norm(mul_epm_vector(partitioned_matrix_PBFGS, s) - y) == 0.\n@test norm(mul_epm_vector(partitioned_matrix_PSR1, s) - y) == 0.\n@test norm(mul_epm_vector(partitioned_matrix_PSE, s) - y) == 0.","category":"page"},{"location":"tutorial/#Limited-memory-partitioned-quasi-Newton-operators","page":"Tutorial","title":"Limited-memory partitioned quasi-Newton operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These operators are made to apply the partitioned quasi-Newton methods to the partially separable function with large elements, whose element approximations can't be store by dense matrices. The limited-memory partitioned quasi-Newton operators allocate for each element approximation a quasi-Newton operator LBFGS or LSR1 defined in LinearOperators.jl. It defines three approximations:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PLBFGS, each element approximation is a LBFGSOperator;\nPLSR1, each element approximation is a LSR1Operator (issue in LinearOperator.jl);\nPLSE, each element approximation may be a LBFGSOperator or LSR1Operator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Contrary to the partitioned quasi-Newton operators, each limited-memory version is typed differently","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_linear_operator_PLBFGS = eplom_lbfgs_from_epv(partitioned_gradient_x0)\npartitioned_linear_operator_PLSR1 = eplom_lsr1_from_epv(partitioned_gradient_x0)\npartitioned_linear_operator_PLSE = eplom_lose_from_epv(partitioned_gradient_x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The different types simplify the update method, since no argument name is required to determine the update that will be applied","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_PLBFGS = update(partitioned_linear_operator_PLBFGS, partitioned_gradient_difference, s)\nB_PLSE = update(partitioned_linear_operator_PLSE, partitioned_gradient_difference, s)\nB_PLSR1 = update(partitioned_linear_operator_PLSR1, partitioned_gradient_difference, s)\n\n@test norm(B_PLBFGS * s - y) == 0.\n@test norm(B_PLSE * s - y) == 0.\n# @test norm(B_PLSR1 * s - y) == 0. # the second element hessian approximation is not update, since the element step and the gradient element difference are collinear.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it, you have all the tools to implement a partitioned quasi-Newton method, enjoy!","category":"page"},{"location":"tutorial/#Features","page":"Tutorial","title":"Features","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For now, PartitionedStructures.jl supports only the elemental U_i, i.e. the lines of U_i are vectors from the euclidean basis. Concretely, each U_i is a vector of size n_i whose the components indicate the indices of the variables used by the i-th element function.","category":"page"}]
}
