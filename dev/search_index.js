var documenterSearchIndex = {"docs":
[{"location":"developer_note/#Elemental-and-internal-variables","page":"Developer note","title":"Elemental and internal variables","text":"","category":"section"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"There is several types of partial separability","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"  f(x) = sum_i=1^N f_i U_i(x)  R^n to R f_i  R^n_i to R  U_i in R^n_i times n n_i  n","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"Uᵢ may be based from the elemental variables or the internal variables of fᵢ:","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"the elemental variables represent the subset of variables that parametrizes fᵢ, i.e. the lines of Uᵢ are vectors from the euclidean basis;\nthe internal variables are the linear combination of the variables that parametrizes fᵢ, i.e. Uᵢ may be a dense matrix.","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"In consequence, the implementation of the linear-operator Uᵢ, which support entirely the partial separability, change depending on internal or elemental variables. At the moment, we mainly developed the elemental partitioned structures, but we left the door open to the development of internal partitioned structures in the future.","category":"page"},{"location":"developer_note/#Abbreviations-in-the-code","page":"Developer note","title":"Abbreviations in the code","text":"","category":"section"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"If you take a look at the code, you will see some","category":"page"},{"location":"developer_note/","page":"Developer note","title":"Developer note","text":"Acronyms Description\neev elemental element-vector\niev internal element-vector\nepv elemental partitioned-vector\nipv internal partitioned-vector\neem elemental element-matrix\neelo elemental partitioned limited-memory operator\niem internal element-matrix\nepm elemental partitioned-matrix\nipm internal partitioned-matrix\neplo elemental partitioned limited-memory operator\nees elemental element-structure\neps elemental partitioned-structure","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PartitionedStructures, M_abstract_part_struct,M_abstract_element_struct,M_internal_elt_vec,M_internal_pv,M_elt_vec,ModElemental_ev,ModElemental_pv,M_elt_mat,M_part_mat,M_part_v,ModElemental_pm,ModElemental_em,M_okoubi_koko,M_frontale, M_1_parallel, M_2_parallel, M_3_parallel, Utils, Link, PartitionedQuasiNewton, PartitionedLOQuasiNewton, ModElemental_elo_bfgs, ModElemental_plo_bfgs, ModElemental_elo_sr1, ModElemental_plo_sr1, ModElemental_plo, Instances, PartMatInterface]","category":"page"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.Part_struct","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.Part_struct","text":"Supertype of every partitioned-structure, ex: Elementalpv, Elementalpm, Elementalplobfgs, Internal_pv, ...\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:Part_struct","page":"Reference","title":"Base.:==","text":"(==)(ps1::T, ps2::T) where T <: Part_struct\n\nReturn true if both partitioned-structures are composed of the same amont of element-structures, and have the same size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y<:Part_struct, Z<:Part_struct}","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.check_epv_epm","text":"bool = check_epv_epm(epm::Y, epv::Z) where {Y <: Part_struct, Z <: Part_struct}\n\nSimilar to ==, but it can compare different partitioned-structures, example: an Elemental_pv and an Elemental_pm. check_epv_epm is a superficial test, see full_check_epv_epm(epm, epv) for a complete check of the partitioned-structure (i.e. if each element depends of the same variable subset).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.full_check_epv_epm-Union{Tuple{Z}, Tuple{Y}, Tuple{Y, Z}} where {Y<:Part_struct, Z<:Part_struct}","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.full_check_epv_epm","text":"full_check_epv_epm(ep1::Y, ep2::Z) where {Y <: Part_struct, Z <: Part_struct}\n\nCheck if each element-structure of both partitioned-structures depend of the same subset of variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_N-Tuple{T} where T<:Part_struct","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_N","text":"get_N(ps::T) where T <: Part_struct\n\nReturn the number of element composing the partitioned-structure ps.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_component_list-Tuple{T} where T<:Part_struct","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_component_list","text":"list = get_component_list(ps::T) where T <: Part_struct\nith_component = get_component_list(ps::T, i::Int) where T <: Part_struct\n\nReturn either the list of every element-structure composing the partitioned-structure ps or the i-th element-structure of ps.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Tuple{T} where T<:Part_struct","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"ee_vector = get_ee_struct(eps::Part_struct{T}) where T\nee = get_ee_struct(eps::Part_struct{T}, i::Int) where T\n\nReturn the vector composed of every elemental element ee_vector from the elemental element-vector eev or the i-th elemental element of eps.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_n-Tuple{T} where T<:Part_struct","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_n","text":"get_n(ps::T) where T <: Part_struct\n\nReturn the total size of the partitioned-structure ps.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.initialize_component_list!-Tuple{T} where T<:Part_struct","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.initialize_component_list!","text":"initialize_component_list!(ps::T) where T <: Part_struct)\n\nBuild for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.Element_struct","text":"Supertype of every element-structure, ex : Elementaleltvec, Elementalem, Elementalelobfgs, Internalelt_vec...\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.get_indices-Tuple{T} where T<:Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.get_indices","text":"indices = get_indices(elt::T) where T <: Element_struct\nindice = get_indices(elt::T, i::Int) where T <: Element_struct\n\nEvery element-structure is based on a variable subset of a partitioned-structure. get_indices(elt) retrieves the variable set of an element elt. get_indices(elt, i) retrieves the i-th variable associated to elt.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.get_nie-Tuple{T} where T<:Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.get_nie","text":"nie = get_nie(elt::T) where T <: Element_struct\n\nReturn the elemental size of the element elt.nie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.set_indices!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.set_indices!","text":"set_indices!(elt::T, indices::Vector{Int}) where T <: Element_struct\n\nSet the indices of the element elt.indices to indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_element_struct.set_nie!-Union{Tuple{T}, Tuple{T, Int64}} where T<:Element_struct","page":"Reference","title":"PartitionedStructures.M_abstract_element_struct.set_nie!","text":"set_nie!(elt::T, nie::Int) where T <: Element_struct\n\nSet the element size of elt to nie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.Internal_elt_vec","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.Internal_elt_vec","text":"Internal_elt_vec{T} <: Elt_vec{T}\n\nRepresent an internal element-vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.build_tmp!-Union{Tuple{Internal_elt_vec{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.build_tmp!","text":"build_tmp!(iev::Internal_elt_vec{T}) where T\n\nWarning: unsupported and not tested. Build in place iev.tmp, the contribution of the internal element-vector iev as a part of a partitioned-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.get_lin_comb-Union{Tuple{Internal_elt_vec{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.get_lin_comb","text":"linear_combination = get_lin_comb(iev::Internal_elt_vec{T}) where T\n\nWarning: unsupported and not tested. Return linear_combination, as a SparseMatrixCSC informing the internal variables of the interal element-vector iev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.get_nii-Union{Tuple{Internal_elt_vec{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.get_nii","text":"nii = get_nii(iev::Internal_elt_vec{T}) where T\n\nWarning: unsupported and not tested. Return nii, the internal dimension of the internal element-vector iev. It may differ from the elemental dimension iev.nie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.get_tmp-Union{Tuple{Internal_elt_vec{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.get_tmp","text":"tmp = get_tmp(iev::Internal_elt_vec{T}) where T\ntmp_i = get_tmp(iev::Internal_elt_vec{T}, i::Int) where T\n\nWarning: unsupported and not tested. Return the vector associated to the internal element-vector of tmp, or its i-th component. The size of tmp is iev.nie. tmp is the contribution of the internal element-vector iev as a part of a partitioned-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.iev_from_eev-Union{Tuple{Elemental_elt_vec{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.iev_from_eev","text":"iev = iev_from_eev(eev::Elemental_elt_vec{T}) where T\n\nWarning: unsupported and not tested. Return an internal element-vector iev from an elemental element-vector eev. The internal variables are the same than the element variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.iev_from_sparse_vec-Union{Tuple{SparseArrays.SparseVector{T, Y}}, Tuple{Y}, Tuple{T}} where {T, Y}","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.iev_from_sparse_vec","text":"iev = iev_from_sparse_vec(sv::SparseVector{T,Y}) where {T,Y}\n\nWarning: unsupported and not tested. Return an internal element-vector from sv::SparseVector. iev is created from the elemental element-vector deduces of sv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.new_iev-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.new_iev","text":"iev = new_iev(nᵢᴱ:: Int, nᵢᴵ:: Int; T=Float64, n=nᵢᴱ^2, prop=0.5)\n\nWarning: unsupported and not tested. Return a internal element-vector iev with random vectors of suitable size and a random SparseMatrixCSC informing the internal variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.ones_iev-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.ones_iev","text":"iev = ones_iev(nᵢᴱ:: Int, nᵢᴵ:: Int; T=Float64, n=nᵢᴱ^2, prop=0.5)\n\nWarning: unsupported and not tested. Return a internal element-vector iev. iev.vec is set to ones(T, nᵢᴵ), the other vectors are randomly choose of suitable size. In addition a random SparseMatrixCSC informing the internal variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.set_lin_comb!-Union{Tuple{T}, Tuple{Internal_elt_vec{T}, SparseArrays.SparseMatrixCSC{T, Int64}}} where T","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.set_lin_comb!","text":"set_lin_comb!(iev::Internal_elt_vec{T}, lin_comb::SparseMatrixCSC{T,Int}) where T\n\nWarning: unsupported and not tested. Set the internal variables iev.lin_comb of the internal element-vector iev to the lin_comb::SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_elt_vec.set_nii!-Union{Tuple{T}, Tuple{Internal_elt_vec{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_internal_elt_vec.set_nii!","text":"set_nii!(iev::Internal_elt_vec{T}, nii::Int) where T\n\nWarning: unsupported and not tested. Set the internal dimension iev.nii of the internal element-vector to nii.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_pv.Internal_pv","page":"Reference","title":"PartitionedStructures.M_internal_pv.Internal_pv","text":"Internal_elt_vec{T} <: Elt_vec{T}\n\nRepresent an internal partitioned-vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_internal_pv.create_ipv-Union{Tuple{Array{Internal_elt_vec{T}, 1}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_internal_pv.create_ipv","text":"ipv = create_ipv(iev_set::Vector{Internal_elt_vec{T}}; n=max_indices(iev_set)) where T\n\nWarning: unsupported and not tested. Return an internal partitioned-vector ipv from the set of internal element-vectors iev_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_pv.get_iev-Union{Tuple{T}, Tuple{Internal_pv{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_internal_pv.get_iev","text":"iev = get_iev(ipv::Internal_pv{T}, i::Int) where T\n\nWarning: unsupported and not tested. Return the i-th internal element-vector of the internal partitioned-vector ipv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_pv.get_iev_set-Union{Tuple{Internal_pv{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_internal_pv.get_iev_set","text":"iev_set = get_iev_set(ipv::Internal_pv{T}) where T\n\nWarning: unsupported and not tested. Return the set of internal element-vectors iev_set, which are contribuating to the internal partitioned-vector ipv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_pv.ipv_from_epv-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_internal_pv.ipv_from_epv","text":"ipv = ipv_from_epv(epv::Elemental_pv{T}) where T\n\nWarning: unsupported and not tested. Return an internal partitioned-vector ipv from the elemental partitioned vector epv. The internal variables of every internal element-vectors are the same as the elemental variables of the elemental element-vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_internal_pv.rand_ipv-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.M_internal_pv.rand_ipv","text":"ipv = new_internal_pv(N::Int,n::Int; nᵢ=3, T=Float64)\n\nWarning: unsupported and not tested. Define an internal partitioned-vector of N elemental element-vectors of size nᵢ and type T.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.build_v!-Union{Tuple{Internal_pv{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_v.build_v!","text":"build_v!(ipv::Internal_pv{T}) where T\n\nWarning1: unsupported and not tested. Build in place the vector ipv.v by accumating the contributions of every internal element-vector. Warning2: the order of ipv.indices is crucial to get the expected result. The order of ipv.lin_comb, ipv.vec, ipv.indices must be synchronized.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_vec.Elt_vec","page":"Reference","title":"PartitionedStructures.M_elt_vec.Elt_vec","text":"Supertype of element-vectors.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_vec.get_vec-Tuple{T} where T<:Elt_vec","page":"Reference","title":"PartitionedStructures.M_elt_vec.get_vec","text":"vec = get_vec(ev::T) where T <: Elt_vec\nvec_i = get_vec(ev::T, i::Int) where T <: Elt_vec\n\nReturn the vector ev.vec or ev.vec[i] from an element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_vec.set_add_vec!-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T<:Elt_vec, Y<:Number}","page":"Reference","title":"PartitionedStructures.M_elt_vec.set_add_vec!","text":"set_add_vec!(ev::T, vec::Vector{Y}) where {T <: Elt_vec, Y <: Number}\n\nAdd vec to the vector ev.vec of the element-vector ev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_vec.set_minus_vec!-Tuple{T} where T<:Elt_vec","page":"Reference","title":"PartitionedStructures.M_elt_vec.set_minus_vec!","text":"set_minus_vec!(ev::T) where T <: Elt_vec\n\nMultiply by -1 the vector inside the element-vector ev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_vec.set_vec!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y<:Number, T<:Elt_vec{Y}}","page":"Reference","title":"PartitionedStructures.M_elt_vec.set_vec!","text":"set_vec!(ev::T, vec::Vector{Y}) where {Y <: Number, T <: Elt_vec{Y}}\nset_vec!(ev::T, i::Int, val::Y) where {Y <: Number, T <: Elt_vec{Y}}\n\nSet ev.vec to vec or ev.vec[i] = val of the element-vector ev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.Elemental_elt_vec","page":"Reference","title":"PartitionedStructures.ModElemental_ev.Elemental_elt_vec","text":"Elemental_elt_vec{T} <: Elt_vec{T}\n\nRepresent an elemental element-vector. indices retains the indices of the elemental variables. nie is the elemental size (=length(indices)). vec is the current value of the elemental element vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_ev.create_eev-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.create_eev","text":"eev = create_eev(elt_var::Vector{Int}; type=Float64)\n\nCreate a random elemental element-vector eev from the elemental variables elt_var. eev is set to random values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.eev_from_sparse_vec-Union{Tuple{SparseArrays.SparseVector{T, Y}}, Tuple{Y}, Tuple{T}} where {T, Y}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.eev_from_sparse_vec","text":"eem = eev_from_sparse_vec(sparsevec::SparseVector{T,Y})\n\nDefine an elemental element-vector from a sparsevec::SparseVector. The indices and the values are define with findnz(sparse_vec).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.new_eev-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.new_eev","text":"eem = new_eev(nᵢ::Int; T=Float64, n=nᵢ^2)\n\nCreate an elemental element-vector of size nie, with random values and whose the indices are within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.ones_eev-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.ones_eev","text":"eem = ones_eev(nᵢ::Int; T=Float64, n=nᵢ^2)\n\nCreate an elemental element-vector of size nie with values set to 1 and whose the indices are within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.sparse_vec_from_eev-Union{Tuple{Elemental_elt_vec{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_ev.sparse_vec_from_eev","text":"sp_vec = sparse_vec_from_eev(eev::Elemental_elt_vec{T}; n::Int=maximum(get_indices(eev))) where T\n\nCreate a SparseVector from the element element-vector eev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_ev.specific_ones_eev-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_ev.specific_ones_eev","text":"eem = specific_ones_eev(nie::Int, index::Int; T=Float64, mul::Float64=1.)\n\nCreate an elemental element-vector of size nie, of random values multiplied by mul and whose indices are in range index:index+nie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.Elemental_pv","page":"Reference","title":"PartitionedStructures.ModElemental_pv.Elemental_pv","text":"Elemental_pv{T} <: Part_v{T}\n\nRepresent an elemental partitioned-vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_v.build_v!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_part_v.build_v!","text":"build_v!(epv::Elemental_pv{T}) where T\n\nBuild the vector epv.v by accumulating the contribution of each elemental element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.add_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.add_epv!","text":"add_epv!(epv1::Elemental_pv{T}, epv2::Elemental_pv{T})\n\nBuild in place of epv2 the elementwise addition of epv1 and epv2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.create_epv-Union{Tuple{Array{SparseArrays.SparseVector{T, Y}, 1}}, Tuple{Y}, Tuple{T}} where {T, Y}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.create_epv","text":"epv = create_epv(sp_set::Vector{SparseVector{T,Y}}; kwargs...) where {T,Y}\nepv = create_epv(eev_set::Vector{Elemental_elt_vec{T}}; n=max_indices(eev_set)) where T\n\nCreate an elemental partitioned-vector from a vector eev_set of: SparseVector, elemental element-vector or a vector of indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.epv_from_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.epv_from_epv!","text":"epv_from_epv!(epv1::Elemental_pv{T}, epv2::Elemental_pv{T}) where T\n\nSet the elemental partitioned-vector epv1 to epv2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.epv_from_v!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.epv_from_v!","text":"epv_from_v!(epv_x::Elemental_pv{T}, x::Vector{T}) where T\n\nSet the values of the element partitioned-vector epv to x. Usefull to define Uᵢ x, ∀ i ∈ {1,...,N}.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.epv_from_v-Union{Tuple{T}, Tuple{Vector{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.epv_from_v","text":"epv = epv_from_v(x::Vector{T}, shape_epv::Elemental_pv{T}) where T\n\nDefine a new elemental partitioned-vector from x that have the same structure than shape_epv. The value of each elemental element-vector comes from the corresponding indices of x. Usefull to define Uᵢ x, ∀ x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.get_eev_set-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.get_eev_set","text":"eev_set = get_eev_set(epv::Elemental_pv{T}) where T\n\nReturn either the vector of every elemental element-vector of the elemental partitioned-vector epv or the i-th elemental element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.get_eev_subset-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{Int64}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.get_eev_subset","text":"eev_subset = get_eev_subset(epv::Elemental_pv{T}, indices::Vector{Int}) where T\n\nReturn a subset of the elemental element vector composing the elemental partitioned-vector epv. indices selects the differents elemental element-vector needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.get_eev_value-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.get_eev_value","text":"eev_i_value = get_eev_value(epv::Elemental_pv{T}, i::Int) where T\neev_ij_value = get_eev_value(epv::Elemental_pv{T}, i::Int, j::Int) where T\n\nReturn either the value of the i-th elemental element-vector of the elemental partitioned-vector epv or only the j-th component of the i-th elemental element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.minus_epv!-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.minus_epv!","text":"minus_epv!(epv::Elemental_pv{T}) where T <: Number\n\nBuild in place the -epv, by inversing the value of each elemental element-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.ones_kchained_epv-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.ones_kchained_epv","text":"epv = ones_kchained_epv(N::Int, k::Int; T=Float64)\n\nConstruct an elemental partitioned-vector of N elemental element-vector of size k which overlaps the next element-vector on k-1 variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.part_vec-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.part_vec","text":"epv = part_vec(;n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1, mul::Float64=1.)\n\nDefine an elemental partitioned-vector formed by N (deduced from n and nie) elemental element-vectors of size nie. Each elemental element-vector overlaps the previous and the next element by overlapping.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.prod_part_vectors-Union{Tuple{T}, Tuple{Elemental_pv{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.prod_part_vectors","text":"(acc, res) = prod_part_vectors(epv1::Elemental_pv{T}, epv2::Elemental_pv{T}) where T\n\nPerform an elementwise scalar product between the two elemental partitioned-vector epv1 and epv2. acc accumulates the sum of the element-vectors scalar product. res contrains the details of every element-vector scalar product.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.rand_epv-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pv.rand_epv","text":"epv = rand_epv(N::Int,n::Int; nie=3, T=Float64)\n\nDefine an elemental partitioned-vector of N elemental element-vector of size nᵢ whose values are randoms and the indices are in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.scale_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.scale_epv!","text":"v = scale_epv!(epv::Elemental_pv{T}, scalars::Vector{T}) where T\n\nReturn a vector v from epv where the contribution of each element-vector is multiply by the corresponding value from scalars. v is extract from epv.v\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.scale_epv-Union{Tuple{T}, Tuple{Elemental_pv{T}, Vector{T}}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.scale_epv","text":"v = scale_epv(epv::Elemental_pv{T}, scalars::Vector{T}) where T <: Number\n\nReturn a vector v from epv where the contribution of each element-vector is multiply by the corresponding value from scalars.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.set_eev!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Int64, Int64, T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pv.set_eev!","text":"set_eev!(epv::Elemental_pv{T}, i::Int, vec::Vector{T}) where T\nset_eev!(epv::Elemental_pv{T}, i::Int, j::Int, val:: T) where T\n\nSet either the i-th elemental element-vector epv to vec or its j-th component to val.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pv.set_epv!-Union{Tuple{T}, Tuple{Elemental_pv{T}, Array{Vector{T}, 1}}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_pv.set_epv!","text":"set_epv!(epv::Elemental_pv{T}, vec_value_eev::Vector{Vector{T}}) where T <: Number\n\nSet the values of the elemental element-vectors of epv with the components of vec_value_eev.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.Counter_elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.Counter_elt_mat","text":"Counter_elt_mat\n\nCount for an element-matrix the updates performed on it, from its allocation. total_update + total_reset + total_untouched == attempt, .\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.DenseEltMat","page":"Reference","title":"PartitionedStructures.M_elt_mat.DenseEltMat","text":"Supertype of every dense element-matrix, ex: Elemental_em\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.Elt_mat","text":"Supertype of every element-matrix, ex: Elementalem, Elementalelosr1, Elementalelo_bfgs\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.LOEltMat","page":"Reference","title":"PartitionedStructures.M_elt_mat.LOEltMat","text":"Supertype of every element linear-operator, ex: Elementalelosr1, Elementalelobfgs\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_Bie-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_Bie","text":"get_Bie(elt_mat::T) where T <: Elt_mat\n\nReturn the element-matrix elt_mat.Bie.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_cem-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_cem","text":"cem = get_cem(elt_mat::T) where T <: Elt_mat\n\nReturn the Counter_elt_mat of the elemental element-matrix elt_mat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_counter_elt_mat-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_counter_elt_mat","text":"cem = get_counter_elt_mat(elt_mat::T) where T <: Elt_mat\n\nReturn the Counter_elt_mat of the elemental element-matrix elt_mat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_current_untouched-Tuple{Counter_elt_mat}","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_current_untouched","text":"index = get_current_untouched(cem::Counter_elt_mat)\n\nReturn index: the number of the last partitioned-updates that did not update the element-matrix elt_mat. If the last partitioned-update updates elt_mat then index will be equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.get_index-Tuple{T} where T<:Elt_mat","page":"Reference","title":"PartitionedStructures.M_elt_mat.get_index","text":"index = get_index(elt_mat::T) where T <: Elt_mat\n\nReturn index: the number of the last partitioned-updates that did not update the element-matrix elt_mat. If the last partitioned-update updates elt_mat then index will be equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.iter_info-Tuple{Counter_elt_mat}","page":"Reference","title":"PartitionedStructures.M_elt_mat.iter_info","text":"(current_update, current_untouched, current_reset) = iter_info(cem::Counter_elt_mat)\n\nReturn the information about the last partitioned quasi-Newton update applied onto the element counter cem (associated to an element-matrix).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.total_info-Tuple{Counter_elt_mat}","page":"Reference","title":"PartitionedStructures.M_elt_mat.total_info","text":"(total_update, total_untouched, current_reset) = iter_info(cem::Counter_elt_mat)\n\nReturn the informations about all the quasi-Newton updates applied onto the element associated to the counter cem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_elt_mat.update_counter_elt_mat!-Tuple{Counter_elt_mat, Int64}","page":"Reference","title":"PartitionedStructures.M_elt_mat.update_counter_elt_mat!","text":"update_counter_elt_mat!(cem::Counter_elt_mat, qn::Int)\n\nUpdate the cem counter given the index qn from the quasi-Newton update BFGS!, SR1!, SE!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.Part_LO_mat","text":"Supertype of every partitioned limited-memory operator, ex: Elementalplobfgs, Elementalplosr1, Elemental_plo \n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_mat.Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.Part_mat","text":"Supertype of every partitioned-matrix, ex: Elementalpm, Elementalplobfgs, Elementalplosr1, Elementalplo\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_mat.get_L-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_L","text":"L = get_L(pm::T) where T <: Part_mat\n\nReturn the sparse matrix pm.L, who aims to store a Cholesky factor. By default pm.L is not instantiate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_L-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_L","text":"L_ij = get_L(pm::T, i::Int, j::Int) where T <: Part_mat\n\nReturn the value pm.L[i,j], from the sparse matrix pm.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_ee_struct_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_ee_struct_Bie","text":"get_ee_struct_Bie(pm::T, i::Int) where T <: Part_mat\n\nReturn the i-th elemental element-matrix of the partitioned-matrix pm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelo_set-Tuple{T} where T<:Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelo_set","text":"eelo_set = get_eelo_set(plm::T) where T <: Part_LO_mat\neelo = get_eelo_set(plm::T, i::Int) where T <: Part_LO_mat\n\nReturn either the vector of every elemental element linear-operator plm.eelo_set or the i-th elemental element linear-operator plm.eelo_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelo_set_Bie-Union{Tuple{T}, Tuple{T, Int64}} where T<:Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelo_set_Bie","text":"Bie = get_eelo_set_Bie(plm::T, i::Int) where T <: Part_LO_mat\n\nReturn the linear-operator of the i-th elemental element linear-operator of plm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_eelo_sub_set-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_eelo_sub_set","text":"eelo_subset = get_eelo_sub_set(plm::T, indices::Vector{Int}) where T <: Part_LO_mat\n\nReturn a subset of the elemental element linear-operators composing the elemental partitioned limited-memory operator plm. indices selects the differents elemental element linear-operators needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_permutation-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_permutation","text":"perm = get_permutation(pm::T) where T <: Part_mat\n\nGet the current permutation of the partitioned-matrix pm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.get_spm-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.get_spm","text":"spm = get_spm(pm::T) where T <: Part_mat\nspm_ij = get_spm(pm::T, i::Int, j::Int) where T <: Part_mat\n\nGet either the sparse matrix associated to the partitioned-matrix pm or pm[i,j].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.hard_reset_L!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.hard_reset_L!","text":"hard_reset_L!(pm::T) where T <: Part_mat\n\nReset the sparse matrix pm.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.hard_reset_spm!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.hard_reset_spm!","text":"hard_reset_spm!(pm::T) where T <: Part_mat\n\nReset the sparse matrix pm.spm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.reset_L!-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.M_part_mat.reset_L!","text":"reset_L!(pm)\n\nSet the elements of sparse matrix pm.L to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.reset_spm!-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.M_part_mat.reset_spm!","text":"reset_spm!(pm::T) where {Y <: Number, T <: Part_mat{Y}}\n\nSet the elements of sparse matrix pm.spm to 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_L!-Union{Tuple{P}, Tuple{T}, Tuple{P, Int64, Int64, T}} where {T<:Number, P<:Part_mat{T}}","page":"Reference","title":"PartitionedStructures.M_part_mat.set_L!","text":"set_L!(pm::P, i::Int, j::Int, value::T) where {T <: Number, P <: Part_mat{T}}\n\nSet the value of pm.L[i,j] = value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_L_to_spm!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.set_L_to_spm!","text":"set_L_to_spm!(pm::T) where T <: Part_mat\n\nSet the sparse matrix plm.L to the sparse matrix plm.spm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_eelo_set!-Tuple{T} where T<:Part_LO_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.set_eelo_set!","text":"set_eelo_set!(eplo::P, i::Int, eelo::Y) where {T, P <: Part_LO_mat{T}, Y <: LOEltMat{T}}\n\nSet the i-th elemental element linear-operator eplo.eelo to eelo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_permutation!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.set_permutation!","text":"set_permutation!(pm::T, perm::Vector{Int}) where T <: Part_mat\n\nSet the permutation of the partitioned-matrix pm to perm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_mat.set_spm!-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.M_part_mat.set_spm!","text":"set_spm!(pm::P) where {T <: Number, P <: Part_mat{T}}\n\nBuild the sparse matrix of the partitioned-matrix pm in pm.spm by gathering the contribution of every element-matrix. The sparse matrix is built with respect to the indices of each elemental element linear-operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.Part_v","text":"Supertype of every partitioned-vectors, ex : Elementaleltvec, Internaleltvec.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.M_part_v.add_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Int64, Y}} where {Y, T<:Part_v{Y}}","page":"Reference","title":"PartitionedStructures.M_part_v.add_v!","text":"add_v!(pv::T, i::Int, value::Y) where {Y, T <: Part_v{Y}}\nadd_v!(pv::T, indices::Vector{Int}, values::Vector{Y}) where {Y, T <: Part_v{Y}}\n\nAdd value (resp values) to the vector of the partitioned-vector pv.v at the indice i (resp indices).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.build_v!-Tuple{T} where T<:Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.build_v!","text":"build_v!(pv::T) where T <: Part_v\n\nAccumulate in pv.v the contributions of every element-vector of the partitioned-vector pv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.build_v-Tuple{T} where T<:Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.build_v","text":"vec = build_v(pv::T) where T <: Part_v\n\nBuild the vector v = pv.v by accumulating inside pv.v the contributions of every element-vector of the partitioned-vector pv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.get_v-Tuple{T} where T<:Part_v","page":"Reference","title":"PartitionedStructures.M_part_v.get_v","text":"v = get_v(pv::T) where T <: Part_v\n\nReturn the vector pv.v of the partitioned-vector pv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.reset_v!-Union{Tuple{T}, Tuple{Y}} where {Y, T<:Part_v{Y}}","page":"Reference","title":"PartitionedStructures.M_part_v.reset_v!","text":"reset_v!(pv::T) where {Y, T <: Part_v{Y}}\n\nReset the vector embedded in the partitioned-vector pv, i.e. pv.v .= (Y)(0).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_part_v.set_v!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y, T<:Part_v{Y}}","page":"Reference","title":"PartitionedStructures.M_part_v.set_v!","text":"set_v!(pv::T, v::Vector{Y}) where {Y, T <: Part_v{Y}}\nset_v!(pv::T, i::Int, value::Y) where {Y, T <: Part_v{Y}}\n\nSet the components of the vector pv.v (resp. pv.v[i]) from the partitioned-vector pv to the vector v (resp. value).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.Elemental_pm","page":"Reference","title":"PartitionedStructures.ModElemental_pm.Elemental_pm","text":"Elemental_pm{T} <: Part_mat{T}\n\nRepresent an elemental partitioned quasi-Newton linear-operator. Each element is an elemental element-matrix which may apply a BFGS or a SR1 update. N is the number of elements. n is the size of the elemental partitioned limited-memory operator. eelo_set is the set of elemental element linear-operators. spm and L are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of spm. component_list summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i. permutation is the current permutation of the elemental partitioned limited-memory operator ([1:n;] initially).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.permute!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T","page":"Reference","title":"Base.permute!","text":"permute!(epm::Elemental_pm{T}, p::Vector{Int}) where T\n\nApply the permutation p to the elemental partitionned matrix epm. The permutation is applied to every elemental element-matrix eem via indices. The current epm permutation is stored in epm.permutation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"eem_set = get_ee_struct(epm::Elemental_pm{T}) where T\n\nReturn the vector of every elemental element-matrices epm.eem_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_abstract_part_struct.get_ee_struct-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_abstract_part_struct.get_ee_struct","text":"eem = get_ee_struct(epm::Elemental_pm{T}, i::Int) where T\n\nReturn the i-th elemental element-matrix epm.eem_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.correlated_var-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.correlated_var","text":"correlated_var(epm::Elemental_pm{T}, i::Int) where T\n\nGather all the variables appearing in the elements also paramtrized by the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_set","text":"eem_set = get_eem_set(epm::Elemental_pm{T}) where T\n\nReturn the vector of every elemental element-matrices epm.eem_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_set","text":"eem = get_eem_set(epm::Elemental_pm{T}, i::Int) where T\n\nReturn the i-th elemental element-matrix epm.eem_set[i].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_set_Bie-Union{Tuple{T}, Tuple{Elemental_pm{T}, Int64}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_set_Bie","text":"Bie = get_eem_set_Bie(get_eem_set_Bie(epm::Elemental_pm{T}, i::Int) where T\n\nGet the matrix of the i-th elemental element-matrix of epm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.get_eem_sub_set-Union{Tuple{T}, Tuple{Elemental_pm{T}, Vector{Int64}}} where T","page":"Reference","title":"PartitionedStructures.ModElemental_pm.get_eem_sub_set","text":"eem_subset = get_eem_sub_set(epm::Elemental_pm{T}, indices::Vector{Int}) where T\n\nReturn a subset of elemental element-matrices composing epm. indices selects the different elemental element-matrices needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.identity_epm","text":"epm = identity_epm(N::Int, n::Int; T=Float64, nie::Int=5)\n\nReturn a partitionned matrix of type T of N identity elemental element-matrices. Each elemental element-matrix is of size nie with randoms positions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.identity_epm-Tuple{Vector{Vector{Int64}}}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.identity_epm","text":"epm = identity_epm(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64)\nepm = identity_epm(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64)\n\nReturn a partitionned matrix of type T of N identity elemental element-matrices. N and n may be extrapolate from element_variables. The elemental variables are based from the indices informed in element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.n_i_SPS-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.n_i_SPS","text":"epm = n_i_SPS(n::Int; T=Float64, nie::Int=5, overlapping::Int=1, mul=5.)\n\nDefine an elemental partitioned-matrix epm of size n. The partitioned-matrix is composed by N ≈ (n/nie)*2 elemental element-matrices, of size nie, they overlap onto the next element by overlapping. The diagonal terms of each elemental element-matrix are of value mul, whereas the other terms are set to 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.n_i_sep-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.n_i_sep","text":"epm = n_i_sep(n::Int; T=Float64, nie::Int=5, mul=5.)\n\nDefine an elemental partitioned-matrix epm composed of nie separable blocs. Each elemental element-matrix is composed of 1 except the diagonal terms which are of value mul.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.ones_epm-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.ones_epm","text":"epm = ones_epm(N::Int, n::Int; T=Float64, nie::Int=5)\n\nCreate a partitionned matrix of type T of N elemental element-matrices ones(nie, nie) whose positions are random. The partitionned matrix created may be singular.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.ones_epm_and_id-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.ones_epm_and_id","text":"epm = ones_epm_and_id(N::Int, n::Int; T=Float64, nie::Int=5)\n\nCreate a partitionned matrix of type T with N+n elemental element-matrices. The first N elemental element-matrices are ones(nie, nie) with randoms positions in the range 1:n. The remaining n elemental element-matrices are of size 1, with value [1], they are placed in the diagonal terms This way, the partitionned matrix is generally not singular.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_pm.part_mat-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_pm.part_mat","text":"epm = part_mat(;n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1, mul=5.)\n\nDefine an elemental partitioned-matrix epm composed of N (deduced from n and nie) elemental element-matrices of size nie. Each elemental element-matrix overlaps the previous and the next element by overlapping.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.Elemental_em","page":"Reference","title":"PartitionedStructures.ModElemental_em.Elemental_em","text":"Elemental_em{T} <: DenseEltMat{T}\n\nRepresent an elemental element-matrix. indices retains the indices of the elemental variables. nie is the elemental size (=length(indices)). Bie a Symmetric{T, Matrix{T}}. counter counts how many update the elemental matrix goes through from its allocation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.permute!-Union{Tuple{T}, Tuple{Elemental_em{T}, Vector{Int64}}} where T","page":"Reference","title":"Base.permute!","text":"permute!(eem::Elemental_em{T}, p::Vector{Int}) where T\n\nSet the indices of the element variables of eem to p. Must be use with caution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.create_id_eem-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_em.create_id_eem","text":"eem = create_id_eem(elt_var::Vector{Int}; T=Float64)\n\nCreate a nie identity elemental element-matrix of type T based on the vector of the elemental variables elt_var.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.fixed_ones_eem-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.fixed_ones_eem","text":"eem = fixed_ones_eem(i::Int, nie::Int; T=Float64, mul=5.)\n\nCreate a nie elemental element-matrix of type T at indices index:index+nie-1. All the components of the element-matrix are set to 1 except the diagonal terms that are set to mul. This method is used to define diagonal dominant element-matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.identity_eem-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.identity_eem","text":"eem = identity_eem(nie::Int; T=Float64, n=nie^2)\n\nReturn a nie identity elemental element-matrix of type T from nie random indices in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.one_size_bloc-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.one_size_bloc","text":"eem = one_size_bloc(index::Int; T=Float64)\n\nReturn an elemental element-matrix of type T of size one at index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_em.ones_eem-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_em.ones_eem","text":"eem = ones_eem(nie::Int; T=Float64, n=nie^2)\n\nReturn a nie ones elemental element-matrix of type T from nie random indices in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_okoubi_koko.okoubi!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.M_okoubi_koko.okoubi!","text":"okoubi!(epm, epv, epv_tmp, res)\n\nSolve the partitioned linear problem using the Okoubi and Koko method. This method avoid the allocation of epv_tmp and res.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_okoubi_koko.okoubi-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}}} where T","page":"Reference","title":"PartitionedStructures.M_okoubi_koko.okoubi","text":"okoubi(epm, epv)\n\nSolve the partitioned linear problem from the elemental partitioned-matrix epm and the elemental partitioned-vector epv using the Okoubi and Koko method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_frontale.frontale!-Union{Tuple{Elemental_pm{T}}, Tuple{T}} where T","page":"Reference","title":"PartitionedStructures.M_frontale.frontale!","text":"frontale!(epm)\n\nProduce the Cholesky factorization of the elemental partitioned-matrix epm using a frontal method. The sparse factor L is stored in epm.L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_1_parallel.subproblem-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}, Vector{Int64}, Int64}} where T","page":"Reference","title":"PartitionedStructures.M_1_parallel.subproblem","text":"subproblem(epm_A, epv_b, epv_x, comp_list, i)\n\ndefine the subproblem which must be solve for the i-th variable\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_2_parallel.subproblem!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}, Int64, Vector{Bool}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.M_2_parallel.subproblem!","text":"subproblem(epm_A, epv_b, epv_x, comp_list, i)\n\ndefine the subproblem which must be solve for the i-th variable\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.M_3_parallel.subproblem3!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Elemental_pv{T}, Int64, Vector{Bool}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.M_3_parallel.subproblem3!","text":"subproblem(epm_A, epv_b, epv_x, comp_list, i)\n\ndefine the subproblem which must be solve for the i-th variable\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.BFGS!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.BFGS!","text":"BFGS!(x0::Vector{Y}, x1::Vector{Y}, g0::Vector{Y}, g1::Vector{Y}, B0::Array{Y,2}, B1::Array{Y,2}; kwargs...) where Y <: Number\nBFGS!(s::Vector{Y}, y::Vector{Y}, B::Symmetric{Y,Matrix{Y}}, B1::Symmetric{Y,Matrix{Y}}; kwargs...) where Y <: Number\nBFGS!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}, B1::Array{Y,2}; index=0, reset=4, kwargs...)\n\nPerform the BFGS update in place of the matrix B1 by using the vectors s = x1 - x0 and y = g1 - g0 and the current matrix B0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.BFGS-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.BFGS","text":"BFGS(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nBFGS(x0::Vector{Y}, x1::Vector{Y}, g0::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\n\nPerform the BFGS update over the matrix B by using the vectors s = x1 - x0 and y = g1 - g0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SE!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SE!","text":"SE!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSE!(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSE!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}, B1::Array{Y,2}; index=0, reset=4, ω = 1e-6, kwargs...)\n\nPerform a BFGS update in place of B1 by using the matrix B, the vectors s = x1 - x0 and y = g1 - g0 if the curvature condition dot(s,y) > eps(eltype(s)) holds. Otherwise, it performs a SR1 update onto B1 with B, s, y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SE-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SE","text":"SE(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSE(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\n\nPerform a BFGS update over the matrix B by using the vectors s = x1 - x0 and y = g1 - g0 if the curvature condition dot(s,y) > eps(eltype(s)) holds. Otherwise, it performs a SR1 update with B, s, y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SR1!-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Vector{Y}, Vector{Y}, Matrix{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SR1!","text":"SR1!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSR1!(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSR1!(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}, B1::Array{Y,2}; index=0, reset=4, ω = 1e-6, kwargs...)\n\nPerform the SR1 update in place of the matrix B1 by using the vectors s = x1 - x0 and y = g1 - g0 and the current matrix B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.SR1-Union{Tuple{Y}, Tuple{Vector{Y}, Vector{Y}, Matrix{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.Utils.SR1","text":"SR1(s::Vector{Y}, y::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\nSR1(x::Vector{Y}, x1::Vector{Y}, g::Vector{Y}, g1::Vector{Y}, B::Array{Y,2}; kwargs...) where Y <: Number\n\nPerform the SR1 update over the matrix B by using the vectors s = x1 - x0 and y = g1 - g0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.max_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.Utils.max_indices","text":"indice_max = max_indices(list_of_element_variables::Vector{Vector{T}}) where T\nindice_max = max_indices(elt_set::Vector{T}) where T <: Element_struct\n\nReturn the maximum index of the element variables in list_of_element_variables or in elt_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.min_indices-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.Utils.min_indices","text":"indice_min = min_indices(list_of_element_variables::Vector{Vector{T}}) where T\nindice_min = min_indices(elt_set::Vector{T}) where T <: Element_struct\n\nReturn the minimum index of the element variables in list_of_element_variables or in elt_set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Utils.my_and","page":"Reference","title":"PartitionedStructures.Utils.my_and","text":"my_and(a::Bool, b::Bool)\n\nReturn a && b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PartitionedStructures.Link.eplo_lbfgs_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Elemental_pv{Y}}","page":"Reference","title":"PartitionedStructures.Link.eplo_lbfgs_from_epv","text":"eplo = eplo_lbfgs_from_epv(epv::T) where {Y <: Number, T <: Elemental_pv{Y}}\n\nCreate an elemental limited-memory partitioned quasi-Newton operator PLBFGS eplo with the same partitioned structure than epv. Each element linear-operator of eplo is set to a LBFGSOperator of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.eplo_lose_from_epv-Union{Tuple{Elemental_pv{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.Link.eplo_lose_from_epv","text":"eplo = eplo_lose_from_epv(epv::Elemental_pv{T}) where {T <: Number}\n\nCreate an elemental limited-memory partitioned quasi-Newton operator PLSE eplo with the same partitioned structure than epv. Each element linear-operator of eplo is set to a LBFGSOperator of suitable size, but it may change to a LSR1Operator later on.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.eplo_lsr1_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Elemental_pv{Y}}","page":"Reference","title":"PartitionedStructures.Link.eplo_lsr1_from_epv","text":"eplo = eplo_lsr1_from_epv(epv::T) where {Y <: Number, T <: Elemental_pv{Y}}\n\nCreate an elemental limited-memory partitioned quasi-Newton operator PLSR1 eplo with the same partitioned structure than epv. Each element linear-operator of eplo is set to a LSR1Operator of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.epm_from_epv-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Elemental_pv{Y}}","page":"Reference","title":"PartitionedStructures.Link.epm_from_epv","text":"epm = epm_from_epv(epv::T) where {Y <: Number, T <: Elemental_pv{Y}}\n\nCreate an elemental partitioned quasi-Newton operator epm with the same partitioned structure than epv. Each element-matrix of epm is set with an identity matrix of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.epv_from_eplo-Tuple{Any}","page":"Reference","title":"PartitionedStructures.Link.epv_from_eplo","text":"epv = epv_from_eplo(eplo::T) where T <: Part_mat{Y}\n\nCreate an elemental partitioned-vector epv with the same partitioned structure than eplo. Each element-vector of epv is set to a random vector of suitable size. Make a name difference with the method epv_from_epm().\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.epv_from_epm-Union{Tuple{T}, Tuple{Y}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.epv_from_epm","text":"epv = epv_from_epm(epm::T) where T <: Part_mat{Y}\n\nCreate an elemental partitioned-vector epv with the same partitioned structure than epm. Each element-vector of epv is set to a random vector of suitable size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_epv!-Union{Tuple{T}, Tuple{Y}, Tuple{Elemental_pv{Y}, T, Elemental_pv{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_epv!","text":"mul_epm_epv!(epv_res::Elemental_pv{Y}, epm::T, epv::Elemental_pv{Y}) where {Y <: Number, T <: Part_mat{Y}}\n\nCompute the elementwise product between the elemental partitioned-matrix epm and the elemental partitioned-vector epv. The result of each element-matrix element-vector product is stored in the elemental partitioned-vector epv_res.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_epv-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_epv","text":"epv_res = mul_epm_epv(epm::T, epv::Elemental_pv{Y}) where {Y <: Number, T <: Part_mat{Y}}\n\nCompute the elementwise product between the elemental partitioned-matrix epm and the elemental partitioned-vector epv. The result is an elemental partitioned-vector epv_res storing the elementwise products between epm and epv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_vector!-Union{Tuple{T}, Tuple{Y}, Tuple{Vector{Y}, T, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_vector!","text":"mul_epm_vector!(res::Vector{Y}, epm::T, x::Vector{Y}) where {Y <: Number, T <: Part_mat{Y}}\nmul_epm_vector!(res::Vector{Y}, epm::T, epv::Elemental_pv{Y}, x::Vector{Y}) where {Y <: Number, T <: Part_mat{Y}}\n\nCompute the product between the elemental partitioned-matrix epm and the vector x. The method uses temporary the elemental partitioned-vector epv. The result is stored in res, a vector similar to x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.mul_epm_vector-Union{Tuple{T}, Tuple{Y}, Tuple{T, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.Link.mul_epm_vector","text":"result = mul_epm_vector(epm::T, x::Vector{Y}) where {Y <: Number, T <: Part_mat{Y}}\nresult = mul_epm_vector(epm::T, epv::Elemental_pv{Y}, x::Vector{Y}) where {Y <: Number, T <: Part_mat{Y}}\n\nCompute the product between the elemental partitioned-matrix epm <: Part_mat and the vector x. The method uses temporary the elemental partitioned-vector epv. The method returns result, a vector similar to x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.string_counters_iter-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.Link.string_counters_iter","text":"s = string_counters_iter(pm::T; name = :PQN) where {T <: Part_mat}\n\nProduce s::String that summarizes the partitioned update applied onto pm at the last iterate. The method accumulates the informations gathered by each element-counter during the last iterate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Link.string_counters_total-Tuple{T} where T<:Part_mat","page":"Reference","title":"PartitionedStructures.Link.string_counters_total","text":"s = string_counters_total(pm::T; name = :PQN) where {T <: Part_mat}\n\nProduce s::String that summarizes the partitioned update applied onto pm since its allocations. The method accumulates the informations gathered by each element-counter since their allocations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PBFGS_update!","text":"PBFGS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPBFGS_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T\n\nPerform the PBFGS update onto the elemental partitioned-matrix epm_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PBFGS_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PBFGS_update","text":"copy_epm_B = PBFGS_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PBFGS update onto a copy of the elemental partitioned-matrix epm_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of epm_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSE_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSE_update!","text":"PSE_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPSE_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T\n\nPerform the PSE update onto the elemental partitioned-matrix epm_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSE_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSE_update","text":"copy_epm_B = PSE_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PSE update onto a copy of the elemental partitioned-matrix epm_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of epm_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSR1_update!-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSR1_update!","text":"PSR1_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPSR1_update!(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, kwargs...) where T\n\nPerforms the PSR1 update onto the elemental partitioned-matrix epm_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedQuasiNewton.PSR1_update-Union{Tuple{T}, Tuple{Elemental_pm{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedQuasiNewton.PSR1_update","text":"copy_epm_B = PSR1_update(epm_B::Elemental_pm{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PSR1 update onto a copy of the elemental partitioned-matrix epm_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of epm_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update!","text":"PLBFGS_update!(eplo_B::Elemental_plo_bfgs{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPLBFGS_update!(eplo_B::Elemental_plo_bfgs{T}, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; verbose=true, reset=true, kwargs...) where T\n\nPerform the PLBFGS update onto the partitioned limited-memory operator eplo_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update-Union{Tuple{T}, Tuple{Elemental_plo_bfgs{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLBFGS_update","text":"copy_eplo_B = PLBFGS_update(eplo_B::Elemental_plo_bfgs{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PLBFGS update onto a copy of the partitioned limited-memory operator eplo_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of eplo_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update!","text":"PLSE_update!(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where {T, Y <: Part_LO_mat{T}}\nPLSE_update!(eplo_B::Y, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; ω = 1e-6, verbose=true, reset=4, kwargs...) where {T, Y <: Part_LO_mat{T}}\n\nPerform the partitionned update PLSE onto the partitioned limited-memory operator eplo_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y. Each element linear-operator from eplo_B is either a LBFGSOperator or LSR1Operator. The update tries to apply a LBFGS update to every Bᵢ, but if the curvature condition yᵢᵀUᵢs > 0 is not satisfied it replaces the LBFGSOperator by a LSR1Operator and applies a LSR1 update. If Bᵢ is initally a LSR1Opeartor, we replace it by a LBFGSOperator if the curvature condition yᵢᵀUᵢs > 0 holds and we update it, otherwise the LSR1Operator Bᵢ is update.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSE_update","text":"copy_eplo_B = PLSE_update(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where {T, Y <: Part_LO_mat{T}}\n\nPerform the partitionned update PLSE onto a copy of the partitioned limited-memory operator eplo_B, given the step s and the difference of elemental partitioned-gradients epv_y. Each element linear-operator from eplo_B is either a LBFGSOperator or LSR1Operator. The update tries to apply a LBFGS update to every Bᵢ, but if the curvature condition yᵢᵀUᵢs > 0 is not satisfied it replaces the LBFGSOperator by a LSR1Operator and applies a LSR1 update. If Bᵢ is initally a LSR1Opeartor, we replace it by a LBFGSOperator if the curvature condition yᵢᵀUᵢs > 0 holds and we update it, otherwise the LSR1Operator Bᵢ is update. Return the updated copy of eplo_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update!","text":"PLSR1_update!(eplo_B::Elemental_plo_sr1{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\nPLSR1_update!(eplo_B::Elemental_plo_sr1{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PLSR1 update onto the partitioned limited-memory operator eplo_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update-Union{Tuple{T}, Tuple{Elemental_plo_sr1{T}, Elemental_pv{T}, Vector{T}}} where T","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.PLSR1_update","text":"copy_eplo_B = PLSR1_update(eplo_B::Elemental_plo_sr1{T}, epv_y::Elemental_pv{T}, s::Vector{T}; kwargs...) where T\n\nPerform the PSR1 update onto a copy of the partitioned limited-memory operator eplo_B, given the step s and the difference of elemental partitioned-gradients epv_y. Return the updated copy of eplo_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.Part_update!-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.Part_update!","text":"Part_update!(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}) where {T, Y <: Part_LO_mat{T}}\nPart_update!(eplo_B::Y, epv_y::Elemental_pv{T}, epv_s::Elemental_pv{T}; kwargs...) where {T, Y <: Part_LO_mat{T}}\n\nPerform a partitioned quasi-Newton update onto the partitioned limited-memory operator eplo_B, given the step s (or the element-steps epv_s) and the difference of elemental partitioned-gradients epv_y. Each elemental element linear-operator from eplo_B is either a LBFGSOperator or LSR1Operator. The update performs on each element the quasi-Newton update associated to the linear-operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartitionedLOQuasiNewton.Part_update-Union{Tuple{Y}, Tuple{T}, Tuple{Y, Elemental_pv{T}, Vector{T}}} where {T, Y<:Part_LO_mat{T}}","page":"Reference","title":"PartitionedStructures.PartitionedLOQuasiNewton.Part_update","text":"copy_eplo_B = Part_update(eplo_B::Y, epv_y::Elemental_pv{T}, s::Vector{T}) where {T, Y <: Part_LO_mat{T}}\n\nPerform a quasi-Newton partitionned update onto a copy of the partitioned limited-memory operator eplo_B, given the step s and the difference of elemental partitioned-gradients epv_y. Each elemental element linear-operator from eplo_B is either a LBFGSOperator or LSR1Operator. The update performs on each element the quasi-Newton update associated to the linear-operator. Return the updated copy of eplo_B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.Elemental_elo_bfgs","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.Elemental_elo_bfgs","text":"Elemental_elo_bfgs{T} <: LOEltMat{T}\n\nRepresent an elemental element LBFGSOperator. indices retains the indices of the elemental variables. nie is the elemental size (=length(indices)). Bie a LBFGSOperator. counter counts how many update the elemental limited-memory operator goes through from its allocation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo","text":"eelo = LBFGS_eelo(nie::Int; T=Float64, index=1)\n\nReturn an Elemental_elo_bfgs of type T of size nie, the indices are all the values in the range index:index+nie-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo_rand-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.LBFGS_eelo_rand","text":"eelo = LBFGS_eelo_rand(nie::Int; T=Float64, n=nie^2)\n\nReturn an Elemental_elo_bfgs of type T with nie random indices within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.init_eelo_LBFGS-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.init_eelo_LBFGS","text":"eelo = init_eelo_LBFGS(elt_var::Vector{Int}; T=Float64)\n\nReturn an Elemental_elo_bfgs of type T based on the vector of the elemental variableselt_var.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_bfgs.reset_eelo_bfgs!-Union{Tuple{Elemental_elo_bfgs{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_elo_bfgs.reset_eelo_bfgs!","text":"reset_eelo_bfgs!(eelo::Elemental_elo_bfgs{T}) where T <: Number\n\nReset the LBFGS linear-operator of the elemental element linear-operator eelo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_bfgs.Elemental_plo_bfgs","page":"Reference","title":"PartitionedStructures.ModElemental_plo_bfgs.Elemental_plo_bfgs","text":"Elemental_plo_bfgs{T} <: Part_LO_mat{T}\n\nRepresent an elemental partitioned quasi-Newton limited-memory operator PLBFGS. Each element is an elemental element LBFGSOperator. N is the number of elements. n is the size of the elemental partitioned limited-memory operator. eelo_set is the set of elemental element linear-operators. spm and L are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of spm. component_list summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i. permutation is the current permutation of the elemental partitioned limited-memory operator ([1:n;] initially).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo","text":"eplo = PLBFGS_eplo(; n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1)\n\nReturn an elemental partitioned limited-memory operator PLBFGS of N (deduced from n and nie) elemental element linear-operators. Each element overlaps the coordinates of the next element by overlapping components.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo_rand-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_bfgs.PLBFGS_eplo_rand","text":"eplo = PLBFGS_eplo_rand(N::Int, n::Int; T=Float64, nie::Int=5)\n\nReturn an elemental partitioned limited-memory operator PLBFGS of N elemental element linear-operators. The size of each element is nie, whose positions are random in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_bfgs.identity_eplo_LBFGS-Tuple{Vector{Vector{Int64}}}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_bfgs.identity_eplo_LBFGS","text":"eplo = identity_eplo_LBFGS(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64)\neplo = identity_eplo_LBFGS(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64)\n\nReturn an elemental partitioned limited-memory operator PLBFGS of N elemental element linear-operators. The positions are given by the vector of the element variables element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.Elemental_elo_sr1","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.Elemental_elo_sr1","text":"Elemental_elo_sr1{T} <: LOEltMat{T}\n\nRepresent an elemental element LSR1Operator. indices retains the indices of the elemental variables. nie is the elemental size (=length(indices)). Bie a LSR1Operator. counter counts how many update the elemental limited-memory operator goes through from its allocation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo","text":"eelo = LSR1_eelo(nie::Int; T=Float64, index=1)\n\nReturn an Elemental_elo_sr1 of type T of size nie, the indices are all the values in the range index:index+nie-1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo_rand-Tuple{Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.LSR1_eelo_rand","text":"eelo = LSR1_eelo_rand(nie::Int; T=Float64, n=nie^2)\n\nReturn an Elemental_elo_sr1 of type T with nie random indices within the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.init_eelo_LSR1-Tuple{Vector{Int64}}","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.init_eelo_LSR1","text":"eelo = init_eelo_LSR1(elt_var::Vector{Int}; T=Float64)\n\nReturn an Elemental_elo_sr1 of type T based on the vector of the elemental variables elt_var.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_elo_sr1.reset_eelo_sr1!-Union{Tuple{Elemental_elo_sr1{T}}, Tuple{T}} where T<:Number","page":"Reference","title":"PartitionedStructures.ModElemental_elo_sr1.reset_eelo_sr1!","text":"reset_eelo_sr1!(eelo::Elemental_elo_sr1{T}) where T <: Number\n\nReset the LSR1 linear-operator of the elemental element linear-operator matrix eelo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_sr1.Elemental_plo_sr1","page":"Reference","title":"PartitionedStructures.ModElemental_plo_sr1.Elemental_plo_sr1","text":"Elemental_plo_sr1{T} <: Part_LO_mat{T}\n\nRepresent an elemental partitioned quasi-Newton limited-memory operator PLSR1. Each element is an elemental element LSR1Operator. N is the number of elements. n is the size of the elemental partitioned limited-memory operator. eelo_set is the set of elemental element linear-operators. spm and L are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of spm. component_list summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i. permutation is the current permutation of the elemental partitioned limited-memory operator ([1:n;] initially).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo","text":"eplo = PLSR1_eplo(; n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1)\n\nReturn an elemental partitionned limited-memory operator PLSR1 of N (deduced from n and nie) elemental element linear-operators. Each element overlaps the coordinates of the next element by overlapping components.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo_rand-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_sr1.PLSR1_eplo_rand","text":"eplo = PLSR1_eplo_rand(N::Int, n::Int; T=Float64, nie::Int=5)\n\nReturn an elemental partitionned limited-memory operator PLSR1 of N elemental element linear-operators. The size of each element is nie, whose positions are random in the range 1:n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo_sr1.identity_eplo_LSR1-Tuple{Vector{Vector{Int64}}}","page":"Reference","title":"PartitionedStructures.ModElemental_plo_sr1.identity_eplo_LSR1","text":"eplo = identity_eplo_LSR1(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64)\neplo = identity_eplo_LSR1(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64)\n\nReturn an elemental partitionned limited-memory operator PLSR1 of N elemental element linear-operators. The positions are given by the vector of the element variables element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo.Elemental_plo","page":"Reference","title":"PartitionedStructures.ModElemental_plo.Elemental_plo","text":"Elemental_plo{T} <: Part_LO_mat{T}\n\nRepresent an elemental partitioned quasi-Newton limited-memory operator PLSE. Each element may either be a LBFGSOperator or a LSR1Operator. N is the number of elements. n is the size of the elemental partitioned limited-memory operator. eelo_set is the set of elemental element linear-operators. spm and L are sparse matrices either to form the sparse matrix gathering the elements or the Cholesky factor of spm. component_list summarizes for each variable i (∈ {1,..., n}) the list of elements (⊆ {1,...,N}) being parametrised by i. permutation is the current permutation of the elemental partitioned limited-memory operator ([1:n;] initially).\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo-Tuple{}","page":"Reference","title":"PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo","text":"eplo = PLBFGSR1_eplo(;n::Int=9, T=Float64, nie::Int=5, overlapping::Int=1, prob=0.5)\n\nCreate an elemental partitionned limited-memory operator PLSE of N (deduced from n and nie) elemental element linear-operators. Each element overlaps the coordinates of the next element by overlapping components. Each element is randomly (rand() > p) choose between an elemental element LBFGS operator or an elemental element LSR1 operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo_rand-Tuple{Int64, Int64}","page":"Reference","title":"PartitionedStructures.ModElemental_plo.PLBFGSR1_eplo_rand","text":"eplo = PLBFGSR1_eplo_rand(N::Int, n ::Int; T=Float64, nie::Int=5, prob=0.5)\n\nCreate an elemental partitionned limited-memory operator PLSE of N elemental element linear-operators. The size of each element is nie, whose positions are random in the range 1:n. Each element is randomly (rand() > p) choose between an elemental element LBFGS operator or an elemental element LSR1 operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.ModElemental_plo.identity_eplo_LOSE-Tuple{Vector{Vector{Int64}}}","page":"Reference","title":"PartitionedStructures.ModElemental_plo.identity_eplo_LOSE","text":"eplo = identity_eplo_LOSE(element_variables::Vector{Vector{Int}}; N::Int=length(element_variables), n::Int=max_indices(element_variables), T=Float64)\neplo = identity_eplo_LOSE(element_variables::Vector{Vector{Int}}, N::Int, n::Int; T=Float64)\n\nCreate an elemental partitionned limited-memory operator of N elemental element linear-operators initialized with LBFGS operators. The positions are given by the vector of the element variables element_variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_eplo-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_eplo","text":"(eplo,epv) = create_epv_eplo_sr1(;n=9,nie=5,overlapping=1, mul_v=100.)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator eplo and elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is instantiated as a LBFGSOperator, but it may change to a LSR1Operator later on. The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_eplo_bfgs-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_eplo_bfgs","text":"(eplo,epv) = create_epv_eplo_bfgs(;n=9,nie=5,overlapping=1, mul_v=100.)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator PLBFGS eplo and an elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is a LBFGSOperator. The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_eplo_sr1-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_eplo_sr1","text":"(eplo,epv) = create_epv_eplo_sr1(;n=9,nie=5,overlapping=1, mul_v=100.)\n\nCreate an elemental partitioned limited-memory quasi-Newton operator PLSR1 eplo and an elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is a LSR1Operator. The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_epm-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_epm","text":"(epm,epv) = create_epv_epm(;n=9,nie=5,overlapping=1,mul_m=5., mul_v=100.)\n\nCreate an elemental partitioned-matrix epm and an elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is fill with ones, except the terms of the diagonal of value mul_v::Real. The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.Instances.create_epv_epm_rand-Tuple{}","page":"Reference","title":"PartitionedStructures.Instances.create_epv_epm_rand","text":"(epm,epv) = create_epv_epm_rand(;n=9,nie=5,overlapping=1,range_mul_m=nie:2*nie, mul_v=100.)\n\nCreate an elemeental partitioned quasi-Newton operator epm and an elemental partitioned-vector epv. Both have the same partitioned structure defined by the size of the problem n::Int, the size of the element nie::Int and the overlapping between the consecutive elements overlapping::Int. Each elemental element-matrix is fill with ones, except the terms of the diagonal of value rand(1:range_mul_v). The value of each elemental element-vector is rand(nie) .* mul_v::Real. Warning: You have to choose carefully the values n, nie and overlap, otherwise the method may fail. The default values are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"update!(epm::T, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; name=:pse, kwargs...) where {Y <: Number, T <: Part_mat{Y}}\nupdate!(epm::T, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where {Y <: Number, T <: Part_mat{Y}}\n\nUpdate the elemental partitioned-matrix epm with a partitioned quasi-Newton update considering the difference of elemental partitioned-gradients epv_y and the step s (or elemental steps epv_s). The PSE update is run by default, you can apply a PBFGS or a PSR1 update with the optionnal argument name, respectively name=:pbfgs or name=:psr1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_bfgs{Y}, Elemental_pv{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"update!(eplo::Elemental_plo_bfgs{Y}, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where Y <: Number\nupdate!(eplo::Elemental_plo_bfgs{Y}, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; kwargs...) where Y <: Number\n\nUpdates the elemental partitioned limited-memory operator eplo with the partitioned quasi-Newton update PLBFGS considering the difference of elemental partitioned-gradients epv_y and the step s (or elemental steps epv_s).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo_sr1{Y}, Elemental_pv{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"update!(eplo::Elemental_plo_sr1{Y}, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where Y <: Number\nupdate!(eplo::Elemental_plo_sr1{Y}, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; kwargs...) where Y <: Number\n\nUpdates the elemental partitioned limited-memory operator eplo with the partitioned quasi-Newton update PLSR1 considering the difference of elemental partitioned-gradients epv_y and the step s (or elemental steps epv_s).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update!-Union{Tuple{Y}, Tuple{Elemental_plo{Y}, Elemental_pv{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartitionedStructures.PartMatInterface.update!","text":"update!(eplo::Elemental_plo{Y}, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where Y <: Number\nupdate!(eplo::Elemental_plo{Y}, epv_y::Elemental_pv{Y}, epv_s::Elemental_pv{Y}; kwargs...) where Y <: Number\n\nUpdates the elemental partitioned limited-memory operator eplo with the partitioned quasi-Newton update PLSE considering the difference of elemental partitioned-gradients epv_y and the step s (or elemental steps epv_s).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartitionedStructures.PartMatInterface.update-Union{Tuple{T}, Tuple{Y}, Tuple{T, Elemental_pv{Y}, Vector{Y}}} where {Y<:Number, T<:Part_mat{Y}}","page":"Reference","title":"PartitionedStructures.PartMatInterface.update","text":"B = update(epm::T, epv_y::Elemental_pv{Y}, s::Vector{Y}; kwargs...) where {Y <: Number, T <: Part_mat{Y}}\n\nUpdate the elemental partitioned operator epm <: Part_mat with a partitioned quasi-Newton update considering the difference of elemental partitioned-gradients epv_y and the step s. If epm is an elemental partitioned-matrix, the PSE update is run by default. You can apply a PBFGS or a PSR1 update with the optionnal argument name, respectively name=:pbfgs or name=:psr1. It returns a matrix accumulating every element-contribtion of the updated epm. Warning: this method should be use to test your algorithm, if you don't intend to form the matrix use update!(epm, epv_y, s).\n\n\n\n\n\n","category":"method"},{"location":"#PartitionedStructures.jl:-Partitioned-derivatives-storage-and-partitioned-quasi-Newton-updates","page":"Home","title":"PartitionedStructures.jl: Partitioned derivatives storage and partitioned quasi-Newton updates","text":"","category":"section"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The methods exploiting the derivatives of partially separable functions require specific structures to store their partitioned derivatives. In the case of partitioned quasi-Newton methods, it requires the storage of partitioned gradients and the partitioned-matrix. PartitionedStructures.jl facilitates the definition of those partitioned-structures and define methods to ease their use.","category":"page"},{"location":"#Compatibility","page":"Home","title":"Compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia 1 up to 1.7.","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add https://github.com/paraynaud/PartitionedStructures.jl\npkg> test PartitionedStructures","category":"page"},{"location":"#How-to-use","page":"Home","title":"How to use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check the tutorial.","category":"page"},{"location":"#Partitioned-structures-available","page":"Home","title":"Partitioned structures available","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Structure Description\nPart_struct The (abstract) supertype of every partitioned-structures\nElemental_pm An elemental partitioned-matrix, each element-matrix is dense\nElemental_plo_bfgs A limited-memory elemental partitioned-matrix, each elemental element limited-memory operator is a LBFGSOperator\nElemental_plo_sr1 A limited-memory elemental partitioned-matrix, each elemental element limited-memory operator is a LSR1Operator\nElemental_plo A limited-memory elemental partitioned-matrix, each elemental element limited-memory operator is a LBFGSOperator or a LSR1Operator\nElemental_pv An elemental partitioned-vector","category":"page"},{"location":"#Methods-available","page":"Home","title":"Methods available","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Method Description\nidentity_epm Creates a partitioned-matrix with identity element-matrix\nidentity_eplo_LBFGS Creates a limited-memory partitioned-matrix PLBFGS\nidentity_eplo_LSR1 Creates a limited-memory partitioned-matrix PLSR1\nidentity_eplo_LOSE Creates a limited-memory partitioned-matrix PLSE\nupdate Performs a partitioned quasi-Newton update onto a partitioned-matrix\neplo_lbfgs_from_epv Creates an Elemental_plo_bfgs from the partitioned-structure of an Elemental_pv\neplo_lsr1_from_epv Creates an Elemental_plo_sr1 from the partitioned-structure of an Elemental_pv\neplo_lose_from_epv Creates an Elemental_plo from the partitioned-structure of an Elemental_pv\nepm_from_epv Creates an Elemental_pm from the partitioned-structure of an Elemental_pv\nepv_from_epm Creates an Elemental_pv from the partitioned-structure of an Elemental_pm\nepv_from_eplo Creates an Elemental_pv from the partitioned-structure of: an Elemental_plo, an Elemental_plo_bfgs or an Elemental_plo_sr1\nmul_epm_epv Return a partitioned-vector from an elementwise product between a partitioned-matrix and a partitioned-vector\nmul_epm_vector Return the vector resulting of a partitioned-matrix vector product\nbuild_v! Build the vector associated to a partitioned-vector\nget_v Return the vector associated to a partitioned-vector  Warning: it doesn't build the vector\nset_epv! Set the value of every element-vectors\nminus_epv! Applies a unary minus on every element-vector of a partitioned-vector\nadd_epv! Performs an elementwise addition between two partitioned-vectors","category":"page"},{"location":"#Modules-applying-[PartitionedStructures.jl](https://github.com/paraynaud/PartitionedStructures.jl)","page":"Home","title":"Modules applying PartitionedStructures.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These structures are applied in the module PartiallySeparableSolvers.jl inside a trust-region using partitioned quasi-Newton operators and in PartitionedKnetNLPModel.jl to train a neural network of classification with a limited-memory partitioned quasi-Newton stochastic method.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For now, PartitionedStructures.jl supports only the elemental Uᵢ, i.e. a linear-operator where the lines of Uᵢ are vectors from the euclidean basis. Concretely, each Uᵢ is a vector of size nᵢ who's indicates the indices of the variables used by the i-th element function.","category":"page"},{"location":"tutorial/#PartitionedStructures.jl:-Tutorial","page":"Tutorial","title":"PartitionedStructures.jl: Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial shows how PartitionedStructures.jl can define partitioned quasi-Newton approximations, by using the partitioned-vectors and the partitioned matrices. Those partitioned structures are strongly related to partially-separable functions.","category":"page"},{"location":"tutorial/#What-are-the-partially-separable-structure-and-the-partitioned-quasi-Newton-approximations","page":"Tutorial","title":"What are the partially separable structure and the partitioned quasi-Newton approximations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The partitioned quasi-Newton methods exploit the partially separable function","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":" f(x) = sum_i=1^N f_i (U_i)  R^n to R f_i  R^n_i to R  U_i in R^n_i times n n_i  n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the sum of element function fᵢ. The gradient ∇f and the Hessian ∇²f","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nabla f(x) = sum_i=1^N U_i^top f_i (U_i x) quad nabla^2 f(x) = sum_i=1^N U_i^top f_i (U_i x) U_i","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"accumulate the element derivatives ∇fᵢ and ∇²fᵢ with respect to the Uᵢ.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These partitioned structure of the Hessian permit to define partitioned quasi-Newton approximations B ≈ ∇²f, such that B accumulates every element-Hessian approximation Bᵢ ≈ ∇²fᵢ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B = sum_i=1^N U_i^top B_i U_i","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The partitioned quasi-Newton approximations structurally keep the sparsity structure of ∇²f, which is not the case of classical quasi-Newton approximation (BFGS, SR1). Moreover, the rank of the partitioned updates may be proportional to the number of elements N, whereas classical quasi-Newton approximations are low rank updates. A partitioned quasi-Newton update must update every approximation of element-Hessian Bᵢ at each step s. It requires Bᵢ, Uᵢs and ∇fᵢ(Uᵢ(x+s)) - ∇fᵢ(Uᵢx), and therefore we have to store such a matrix and vectors for every element.","category":"page"},{"location":"tutorial/#Reference","page":"Tutorial","title":"Reference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A. Griewank and P. Toint, On the unconstrained optimization of partially separable functions, Numerische Nonlinear Optimization 1981, 39, pp. 301–312, 1982.","category":"page"},{"location":"tutorial/#Example:-the-partitioned-structure-of-a-quadratic-function","page":"Tutorial","title":"Example: the partitioned structure of a quadratic function","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's take the quadratic function f as an example","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x) = x[1]^2 + x[2]^2 + x[3]^2 + x[1]*x[2] + 3x[2]*x[3]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f can be considered as the sum of two element functions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f1(x) = x[1]^2 + x[1]*x[2]\nf2(x) = x[1]^2 + x[2]^2 + 3x[1]*x[2]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"considering U₁ and U₂ informing the variables required by each element function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U1 = [1, 2] # [1 0 0; 0 1 0] as a matrix\nU2 = [2, 3] # [0 1 0; 0 0 1] as a matrix","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By gathering the different Uᵢ together","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"U = [U1, U2]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we define the function exploiting the partially-separable structure f_pss as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f_pss(x, U) = f1(x[U[1]]) + f2(x[U[2]])\n\nusing Test\nx0 = [2., 3., 4.]\n@test f(x0) == f_pss(x0, U)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, you can compute: the gradient, the element-gradients and explicit how the gradient is partitioned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"∇f(x) = [2x[1] + x[2], x[1] + 2x[2] + 3x[3], 2x[3] + 3x[2]]\n∇f1(x) = [2x[1] + x[2], x[1]]\n∇f2(x) = [2x[1] + 3x[2], 2x[2] + 3x[1]]\nfunction ∇f_pss(x, U)\n  gradient = zeros(length(x))\n  gradient[U1] = ∇f1(x[U[1]])\n  gradient[U2] .+= ∇f2(x[U[2]])\n  return gradient\nend\n@test ∇f(x0) == ∇f_pss(x0, U)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"However, ∇f_pss accumulates directly the element-gradient and does not store the value of each element-gradients ∇f1, ∇f2. We would like to store every element-gradient to build afterward the element-gradients difference   required for the partitioned quasi-Newton update. Thus, we define the partitioned-vector from U, to store each element-gradient and form the ∇f when required","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PartitionedStructures\nU = [U1, U2]\nn = length(x0)\npartitioned_gradient_x0 = create_epv(U) # creates the partitioned-vector","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We set the value of each element-vector to the corresponding element-gradient","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"vector_gradient_element(x, U) = [∇f1(x[U[1]]), ∇f2(x[U[2]])] :: Vector{Vector{Float64}} # returns every element-gradient\n\nset_epv!(partitioned_gradient_x0, vector_gradient_element(x0, U)) # sets each element-vector to its corresponding element-gradient\n\nbuild_v!(partitioned_gradient_x0) # Build the gradient vector\n@test get_v(partitioned_gradient_x0) == ∇f(x0) # with the same value as the gradient","category":"page"},{"location":"tutorial/#Approximate-the-Hessian-f","page":"Tutorial","title":"Approximate the Hessian ∇f²","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There is at least two ways to approximate ∇f²: a classical quasi-Newton approximation (ex: BFGS) and a partitioned quasi-Newton approximation (ex: PBFGS). Both methods are presented, and we expose the sparse structure of partitioned approximation.","category":"page"},{"location":"tutorial/#Quasi-Newton-approximation-of-the-quadratic-(BFGS)","page":"Tutorial","title":"Quasi-Newton approximation of the quadratic (BFGS)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the case of the BFGS method, you want to approximate the Hessian matrix from s = x1 - x0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x1 = [1., 2., 2.]\ns = x1 .- x0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the gradient difference y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"y = (∇f(x1) .- ∇f(x0))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the approximation B, initially set to the identity","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B = [ i==j ? 1. : 0. for i in 1:n, j in 1:n]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By applying the BFGS update, you satisfy the secant equation Bs = y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# PartitionedStructures.jl export a BFGS implementation\nB_BFGS = BFGS(s,y,B) \n\nusing LinearAlgebra\n# numerical verification of the secant equation\n@test norm(B_BFGS * s - y) < atol ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"but the approximation B_BFGS is dense.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_BFGS","category":"page"},{"location":"tutorial/#Partitioned-quasi-Newton-approximation-of-the-quadratic-function-(PBFGS)","page":"Tutorial","title":"Partitioned quasi-Newton approximation of the quadratic function (PBFGS)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to make a sparse quasi-Newton approximation of ∇²f, you may define a partitioned-matrix with the same partially separable structure than partitioned_gradient_x0 where each element-matrix is set to the identity","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_matrix = epm_from_epv(partitioned_gradient_x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It can be visualized with the Matrix constructor","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Matrix(partitioned_matrix)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The second term of the diagonal accumulates two 1.0 from the two initial element approximations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then you compute the partitioned-gradient at x1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_gradient_x1 = create_epv(U)\nset_epv!(partitioned_gradient_x1, vector_gradient_element(x1, U))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and compute the elementwise difference of the partitioned-gradients partitioned_gradient_x1 - partitioned_gradient_x0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# copy to avoid side effects on partitioned_gradient_x0\npartitioned_gradient_difference = copy(partitioned_gradient_x0)\n# applies in place an unary minus to every element-gradient\nminus_epv!(partitioned_gradient_difference)\n# add in place the element-vector of partitioned_gradient_x1 to the corresponding element-vector of partitioned_gradient_difference\nadd_epv!(partitioned_gradient_x1, partitioned_gradient_difference)\n\nbuild_v!(partitioned_gradient_difference) # computes the vector y\n@test get_v(partitioned_gradient_difference) == y","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then you can define the partitioned quasi-Newton update PBFGS","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# applies the partitioned update PBFGS to partitioned_matrix and returns Matrix(partitioned_matrix)\nB_PBFGS = update(partitioned_matrix, partitioned_gradient_difference, s; name=:pbfgs, verbose=true)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which keeps the sparsity structure of ∇²f.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition, update() informs the number of element: updated, not updated or untouched, as long as the user don't set verbose=false. The partitioned update verifies the secant equation","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"atol = sqrt(eps(eltype(s1)))\n@test norm(B_PBFGS*s - y) < atol","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which may also be calculated with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# compute the product partitioned-matrix vector\nBs = mul_epm_vector(partitioned_matrix, s)\n@test norm(Bs - y) < atol","category":"page"},{"location":"tutorial/#Others-partitioned-quasi-Newton-approximations","page":"Tutorial","title":"Others partitioned quasi-Newton approximations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There exist two categories of partitioned quasi-Newton updates. In the first category, each element-Hessian ∇²fᵢ is approximate with a dense matrix, for example: PBFGS. In the second category, each element-Hessian ∇²fᵢ is approximate with a quasi-Newton linear-operator.","category":"page"},{"location":"tutorial/#Partitioned-quasi-Newton-operators","page":"Tutorial","title":"Partitioned quasi-Newton operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the partitioned-matrix is allocated,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_matrix_PBFGS = epm_from_epv(partitioned_gradient_x0)\npartitioned_matrix_PSR1 = epm_from_epv(partitioned_gradient_x0)\npartitioned_matrix_PSE = epm_from_epv(partitioned_gradient_x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"you can apply on it any of the three partitioned updates : PBFGS, PSR1, PSE (by default) :","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PBFGS update each element approximation with BFGS;\nPSR1 update each element approximation with SR1;\nPSE each element approximation is update with BFGS if it is possible or with SR1 otherwise.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_PBFGS = update(partitioned_matrix_PBFGS, partitioned_gradient_difference, s; name=:pbfgs)\nB_PSR1 = update(partitioned_matrix_PSR1, partitioned_gradient_difference, s; name=:psr1)\nB_PSE = update(partitioned_matrix_PSE, partitioned_gradient_difference, s) # ; name=:pse by default","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All these methods satisfy the secant equation as long as every element approximation is updated","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@test norm(mul_epm_vector(partitioned_matrix_PBFGS, s) - y) < atol\n@test norm(mul_epm_vector(partitioned_matrix_PSR1, s) - y) < atol\n@test norm(mul_epm_vector(partitioned_matrix_PSE, s) - y) < atol","category":"page"},{"location":"tutorial/#Limited-memory-partitioned-quasi-Newton-operators","page":"Tutorial","title":"Limited-memory partitioned quasi-Newton operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These operators are made to apply the partitioned quasi-Newton methods to the partially separable function with large elements, whose element-Hessian approximations can't be store by dense matrices. The limited-memory partitioned quasi-Newton operators allocate for each element-Hessian approximation a quasi-Newton operator LBFGS or LSR1 defined in LinearOperators.jl. It defines three approximations:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PLBFGS, each element approximation is a LBFGSOperator;\nPLSR1, each element approximation is a LSR1Operator (issue in LinearOperator.jl);\nPLSE, each element approximation may be a LBFGSOperator or LSR1Operator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Contrary to the partitioned quasi-Newton operators, each partitioned limited-memory quasi-Newton operators has a different type","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"partitioned_linear_operator_PLBFGS = eplo_lbfgs_from_epv(partitioned_gradient_x0)\npartitioned_linear_operator_PLSR1 = eplo_lsr1_from_epv(partitioned_gradient_x0)\npartitioned_linear_operator_PLSE = eplo_lose_from_epv(partitioned_gradient_x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The different types simplify the update method, since no argument name is required to determine which update is applied","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B_PLBFGS = update(partitioned_linear_operator_PLBFGS, partitioned_gradient_difference, s)\nB_PLSE = update(partitioned_linear_operator_PLSE, partitioned_gradient_difference, s)\nB_PLSR1 = update(partitioned_linear_operator_PLSR1, partitioned_gradient_difference, s)\n\n@test norm(B_PLBFGS * s - y) < atol\n@test norm(B_PLSE * s - y) < atol\n@test norm(B_PLSR1 * s - y) < atol","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it, you have all the tools to implement a partitioned quasi-Newton method, enjoy!","category":"page"}]
}
